<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="go, 凌波威步～">
    <meta name="description" content="go笔记">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>go | 凌波威步～</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="凌波威步～" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">凌波威步～</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">凌波威步～</div>
        <div class="logo-desc">
            
            得之坦然，失之淡然，争其必然，顺其自然
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/../images/go.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">go</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/note/">
                                <span class="chip bg-color">note</span>
                            </a>
                        
                            <a href="/tags/go/">
                                <span class="chip bg-color">go</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/go/" class="post-category">
                                go
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-05-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-10-09
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    14.3k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开启module模式
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct

# 设置不走 proxy 的私有仓库，多个用逗号相隔（可选）
go env -w GOPRIVATE=*.corp.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>fmt.Print</code>有几个变种：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Print:  输出到控制台,不接受任何格式化操作
Println: 输出到控制台并换行
Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量（不可以输出别的类型）
Sprintf：格式化并返回一个字符串而不带任何输出
Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通用的占位符</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">%v     值的默认格式。
%+v   类似%v，但输出结构体时会添加字段名
%#v　 相应值的Go语法表示 
%T    相应值的类型的Go语法表示 
%%    百分号,字面上的%,非占位符含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rickiyang/p/11074171.html">Go中的fmt几种输出的区别和格式化方式</a> </p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68792989">深度解析context</a>: 不完美，但很高效解决了问题</p>
<p><strong>任何调用的默认超时时间的设置是非常有必要的</strong></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针结构图"><a href="#指针结构图" class="headerlink" title="指针结构图"></a>指针结构图</h3><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/PointerValue.png" style="zoom:67%;">

<ul>
<li>指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象</li>
<li>这个对象可以是字符串、整数、函数或者你自定义的结构体</li>
<li>指针变量的值就是 <strong>它(内存地址)</strong> 所指向数据的内存地址，普通变量的值就是我们具体存放的数据</li>
<li>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小</li>
</ul>
<h3 id="指针变量-x2F-普通变量"><a href="#指针变量-x2F-普通变量" class="headerlink" title="指针变量/普通变量"></a>指针变量/普通变量</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   name:="will"
   nameP:=&amp;name		// &amp;, 表示取地址；指针的类型是 *string
   fmt.Println("name变量的值为:",name)	// name变量的值为: will
   fmt.Println("name变量的内存地址为:",nameP)	// name变量的内存地址为: 0xc000010200
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Go 语言中使用类型名称前加 * 的方式，即可表示一个对应的指针类型</li>
<li>比如 int 类型的指针类型是 *int，float64 类型的指针类型是 *float64，自定义结构体 A 的指针类型是 *A</li>
</ul>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 也可以通过 var 关键字定义
var intP *int

//指针类型不同，无法赋值 :
intP = &amp;name 	
//  Cannot use '&amp;name' (type *string) as type *int in assignment

// 指针类型的变量如果没有分配内存，默认零值 nil，它没有指向的内存；所以无法使用，强行使用就会得到 nil 指针错误
*intP =10
// ipanic: runtime error: invalid memory address or nil pointer dereference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>通过 var 声明的指针变量不能直接赋值和取值的，因为它<code>仅仅是个变量</code>，<em>还没有对应的内存地址</em>，它的值是 <code>nil</code></p>
</li>
<li><p>而对于==值类型==来说，<code>即使只声明一个变量</code>，没有对其初始化，**<u><em>该变量也会有分配好的内存</em></u>**</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   var s string
   fmt.Printf("%p\n",&amp;s)
}
// 声明了一个变量 s，并没有对其初始化，但是可以通过 &amp;s 获取它的内存地址
// 这其实是 Go 语言帮我们做的，可以直接使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 只需要通过 new 函数给它分配一块内存就可以了
var intP *int = new(int)

// 更推荐简短声明法: 
intP := new(int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>和普通类型不一样的是</strong>，指针类型还可以通过内置的 new 函数来声明: </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">intP1 := new(int)
// 内置的 new 函数有一个参数，可以传递类型给它,它会返回对应的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h3 id="获取指针指向的值"><a href="#获取指针指向的值" class="headerlink" title="获取指针指向的值"></a>获取指针指向的值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">nameV := *nameP
fmt.Println("nameP指针指向的值为:",nameV)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>要获取指针指向的值，只需要在指针变量前加 <code>*</code> 号即可</li>
<li><code>*</code> 直接，映射到 指针中存储的内存地址 指向的指</li>
</ul>
<h3 id="修改指针指向的值"><a href="#修改指针指向的值" class="headerlink" title="修改指针指向的值"></a>修改指针指向的值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">//修改指针指向的值
*nameP = "will micro" 
fmt.Println("nameP指针指向的值为:",*nameP)
fmt.Println("name变量的值为:",name)
// 运行结果:
// nameP指针指向的值为: will micro
// name变量的值为: will micro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>==对 *nameP 赋值等于修改了指针 nameP 指向的值== </p>
<p>不光 nameP 指针指向的值被改变了，变量 name 的值也被改变了，这就是指针的作用</p>
<h3 id="指针参数"><a href="#指针参数" class="headerlink" title="指针参数"></a>指针参数</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">age:=18
modifyAge(age)
fmt.Println("age的值为:",age)

func modifyAge(age int)  {
   age = 20
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>modifyAge 中的 age 只是实参 age 的一份拷贝，所以修改它不会改变实参 age 的值</p>
<p><strong>要达到修改年龄，需要使用指针:</strong>  </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">age:=18
modifyAge(&amp;age)
fmt.Println("age的值为:",age)
func modifyAge(age *int)  {
   *age = 20
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>需要在函数中通过形参改变实参的值时，需要使用指针类型的参数</p>
</blockquote>
<h3 id="指针的优点"><a href="#指针的优点" class="headerlink" title="指针的优点"></a>指针的优点</h3><ol>
<li>可以<strong>修改</strong>指向数据的值</li>
<li>在<code>变量赋值</code>，<code>参数传值</code>的时候可以<strong>节省内存</strong></li>
</ol>
<p>Go 语言作为一种高级语言，在指针的使用上还是比较<strong>克制</strong>的。</p>
<p>它在设计的时候就对指针进行了诸多限制，比如<code>指针不能进行运算</code>，也<code>不能获取常量的指针</code>。</p>
<h3 id="指针的建议"><a href="#指针的建议" class="headerlink" title="指针的建议"></a>指针的建议</h3><ol>
<li>不要对 map、slice、channel 这类引用类型使用指针</li>
<li>如果需要修改<code>方法接收者</code><em><strong><u>内部的</u></strong></em> 数据或者状态时，需要使用指针</li>
<li>如果需要修改<code>参数的值</code>或者<code>内部数据</code>时，也需要使用指针类型的参数</li>
<li>如果是<code>比较大的结构体</code>，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针</li>
<li>像 int、bool 这样的小数据类型没必要使用指针</li>
<li>如果需要<code>并发安全</code>，则尽可能地不要使用指针，使用指针一定要保证并发安全</li>
<li>指针最好<code>不要嵌套</code>，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂</li>
</ol>
<h2 id="值类型-x2F-指针类型"><a href="#值类型-x2F-指针类型" class="headerlink" title="值类型/指针类型"></a>值类型/指针类型</h2><h3 id="指针的指向"><a href="#指针的指向" class="headerlink" title="指针的指向"></a>指针的指向</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 定义一个地址结构体
type address struct {
   province string
   city string
}

// 值类型 address 作为接收者实现了接口 fmt.Stringer
func (addr address) String()  string{
   return fmt.Sprintf("the addr is %s%s",addr.province,addr.city)
}
// 那么指针类型 *address 也实现了接口 fmt.Stringer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   add := address{province: "北京", city: "北京"}
   printString(add)
   printString(&amp;add)
}
func printString(s fmt.Stringer) {
   fmt.Println(s.String())
}
// 正常运行：
// 证明了当值类型作为接收者实现了某接口时，它的指针类型也同样实现了该接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
    var si fmt.Stringer = address{province: "上海",city: "上海"}
    printString(si)
    sip := &amp;si
    printString(sip)
}
// 错误信息：
// ./main.go:42:13: cannot use sip (type *fmt.Stringer) as type fmt.Stringer in argument to printString:
//	*fmt.Stringer is pointer to interface, not interface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>总结：<strong>指向<code>具体类型</code>的指针可以实现一个接口，但是指向<code>接口</code>的指针永远不可能实现该接口</strong> </p>
<h3 id="内存与不同类型"><a href="#内存与不同类型" class="headerlink" title="内存与不同类型"></a>内存与不同类型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个变量必须要经过<code>声明</code>、<code>内存分配</code>才能赋值，<em>才可以在声明的时候进行初始化</em> ：</p>
<ul>
<li><p>如果要对一个变量赋值，这个变量<code>必须有对应的分配好的内存</code>，这样才可以对这块内存操作，完成赋值的目的</p>
</li>
<li><p><strong>不止赋值操作</strong>，<code>对于指针变量</code>，如果没有分配内存，<em>取值操作一样会报 nil 异常</em>，<code>因为没有可以操作的内存</code></p>
</li>
</ul>
<p><code>指针类型</code>在声明的时候，<code>Go 语言并没有自动分配内存</code>，所以不能对其进行赋值操作，这和<code>值类型</code>不一样</p>
<p><code>slice</code>、<code>chan</code>和 <code>map</code> 也一样，因为它们*<u><strong>本质上也是指针类型</strong></u>*</p>
<h4 id="new-函数"><a href="#new-函数" class="headerlink" title="new 函数"></a>new 函数</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   var sp *string  // 没有分配到内存，不能对其进行赋值操作
    
   sp = new(string)	// 关键点，这可以分配到一块内存
   *sp = "will"
   fmt.Println(*sp)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>内置函数 new 的源代码:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// The new built-in function allocates memory. The first argument is a type,
// not a value, and the value returned is a pointer to a newly
// allocated zero value of that type.
func new(Type) *Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>翻译：根据传入的类型申请一块内存，然后返回指向这块内存的指针，指针指向的数据就是该类型的零值。</p>
</blockquote>
<p>指针变量初始化：（工厂函数）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">pp := NewPerson("will",20)

func NewPerson(name string,age int) *person{
   p:=new(person)
   p.name = name
   p.age = age
   return p
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="make-函数"><a href="#make-函数" class="headerlink" title="make 函数"></a>make 函数</h4><p>使用 make 函数创建 map 的时候，其实调用的是 makemap 函数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// makemap implements Go map creation for make(map[k]v, hint).
func makemap(t *maptype, hint int, h *hmap) *hmap{
  //省略无关代码
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>makemap 函数返回的是 *hmap 类型，而 hmap 是一个结构体，它的定义如下面的代码所示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// src/runtime/map.go
// A header for a Go map.
type hmap struct {
   // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
   // Make sure this stays in sync with the compiler's definition.
   count     int // # live cells == size of map.  Must be first (used by len() builtin)
   flags     uint8
   B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
   noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
   hash0     uint32 // hash seed
   buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
   oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
   nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)
   extra *mapextra // optional fields
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>map 关键字其实非常复杂，它包含 map 的大小 count、存储桶 buckets 等</p>
</li>
<li><p>要想使用这样的 hmap，不是简单地通过 new 函数返回一个 *hmap 就可以，<code>还需要对其进行初始化</code>，这就是 make 函数要做的事情</p>
</li>
</ul>
<p>其实 make 函数就是 map 类型的工厂函数，它可以根据传递它的 K-V 键值对类型，创建不同类型的 map，同时可以初始化 map 的大小。</p>
<blockquote>
<p>提示：make 函数不只是 map 类型的工厂函数，还是 chan、slice 的工厂函数。它同时可以用于 slice、chan 和 map 这三种类型的初始化。</p>
</blockquote>
<ul>
<li><a href="#Map">map</a> </li>
<li><a href="#chan">chan</a> </li>
<li><a href="#SliceHeader">slice</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p><code>new 函数只用于分配内存，并且把内存清零</code>，也就是返回一个指向对应类型零值的指针。</p>
<ul>
<li>new 函数一般用于需要显式地返回指针的情况，不是太常用。</li>
</ul>
</li>
<li><p><code>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化</code>，因为这三种类型的结构比较复杂。</p>
<ul>
<li>比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</li>
</ul>
</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p><strong>引用类型的零值都是 nil：</strong> </p>
<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AllOfTypeInGo.png" style="zoom:50%;">





<p>在 Go 语言中，函数的参数传递<code>只有值传递</code>，而且传递的 <em>实参</em> <code>都是原始数据的一份拷贝</code></p>
<ul>
<li><p>如果拷贝的内容是值类型的，那么在函数中就<code>无法修改</code>原始数据</p>
</li>
<li><p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么在函数中就<code>可以修改</code>原始数据</p>
</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wade3015/article/details/100149338">map的出生到扩展</a></p>
<h3 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   m:=make(map[string]int)
   m["will"] = 18
   fmt.Println("will的年龄为",m["will"])
   modifyMap(m)
   fmt.Println("will的年龄为",m["will"])
}
func modifyMap(p map[string]int)  {
   p["will"] =20
}
// 成功修改：
// will的年龄为 18
// will的年龄为 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 判断key是否存在

if value, ok := map[key]; ok {
    // 存在
}
if value, ok := map[key]; !ok {
    // 不存在
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 不关心索引和数据的情况
for range m {}

// 只关心索引的情况,只遍历键, 无须将值改为匿名变量形式，忽略值即可
for kwy := range m {}

// 关心索引和数据的情况
for kwy, value := range m {}


// 如果需要特定顺序的遍历结果，正确的做法是先排序
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h3><p>用<code>字面量</code>或者<code>make函数</code>的方式创建 map，都转换成 makemap 函数的调用，这个转换是 <strong>Go 语言编译器自动做的</strong> </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// src/runtime/map.go
// makemap implements Go map creation for make(map[k]v, hint).
func makemap(t *maptype, hint int, h *hmap) *hmap{
  //省略无关代码
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> Go 语言的 map 类型本质上就是 <code>*hmap</code>, <strong>本质上就是个指针</strong> </p>
<h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><p>Go 语言并发模块中的 <code>channel</code>, <strong>本质上也是个指针</strong> : </p>
<p>创建的 chan 其实是个 *hchan，所以它在参数传递中也和 map 一样</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func makechan(t *chantype, size int64) *hchan {
    //省略无关代码
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>严格来说，Go 语言没有引用类型，但是我们可以把 map、chan 称为<strong>引用类型</strong>，<strong>为了便于理解</strong>。</p>
<p>除了 map、chan 之外，Go 语言中的<code>函数</code>、<code>接口</code>、<code>slice 切片</code>都可以称为<strong>引用类型</strong> </p>
<h2 id="切片-amp-数组"><a href="#切片-amp-数组" class="headerlink" title="切片&amp;数组"></a>切片&amp;数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">a1:=[1]string{"张三"}
a2:=[2]string{"李四"}

array:=[5]string{"a","b","c","d","e"}
array:=[...]string{"a","b","c","d","e"}

// slice := []string{"a","b","c","d","e"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量 a1 的大小是 <code>1</code>，内部元素的类型是 string，也就是说 a1 <code>最多只能存储 1 个类型为 string 的元素</code></li>
<li>变量 a2 的大小是 <code>2</code>，内部元素的类型也是 string，所以 a2 <code>最多可以存储 2 个类型为 string 的元素</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ArrayOfGo.png" style="zoom:40%;">



<p>数组由两部分构成：<code>数组的大小</code>和<code>数组内的元素类型</code> </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">//数组结构伪代码表示
array{
  len
  item type
}

// 数组循环
for i,v:=range array{
    fmt.Printf("数组索引:%d,对应值:%s\n", i, v)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="数组的限制"><a href="#数组的限制" class="headerlink" title="数组的限制"></a>数组的限制</h3><ul>
<li>一旦一个数组被声明，它的<code>大小</code>和<code>内部元素的类型</code>就<strong>不能改变</strong>，<strong>不能随意</strong>地向数组添加任意多个元素.</li>
<li>与C语言不同，创建数组时，Go会将数组元素初始化为零值，因此我们无需再显式地执行此初始化操作.</li>
<li>与C不同的是，Go数组是值类型，它不是指向内存块第一个元素的指针；如果将数组传递给函数，则将复制整个数组；但仍然可以<em>传递</em> <strong>指向数组</strong>的<strong>指针</strong>以使其不被复制.</li>
</ul>
<h3 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice 切片"></a>slice 切片</h3><p>​		<code>为了解决数组以上的限制</code>，Go 语言创造了 slice，也就是切片。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">slice := array[2:5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/SliceOfGo.png" style="zoom:40%;">

<ul>
<li>array[2:5] 获取到的是 c、d、e 这三个元素；左闭右开区间</li>
</ul>
<blockquote>
<p>切片是 对数组的 <strong>抽象</strong> 和 <strong>封装</strong> </p>
<p>底层是一个数组存储所有的元素，但是它<code>可以动态地添加元素</code>，容量不足时还可以<code>自动扩容</code></p>
<p>但，其并<strong>不是指针</strong>，而是一种数据类型</p>
</blockquote>
<p><strong>切片，就是<code>动态数组</code></strong>  </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s := []string{"张三", "李四"}
// 区别于数组，没有容量个数
// a := [2]string{"张三", "李四"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 还可以使用make 函数传入一个容量参数：
slice:=make([]string,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 可以指定新创建的切片 []string 容量为 8：
slice := make([]string,4,8)
// Go 语言在内存上划分了一块容量为 8 的内容空间（容量为 8）
// 但是只有 4 个内存空间才有元素（长度为 4），其他的内存空间处于空闲状态
// 当通过 append 函数往切片中追加元素的时候，会追加到空闲的内存上，当切片的长度要超过容量的时候，会进行扩容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 通过字面量的方式声明和初始化：      (和数组的区别只是，没有容量个数)
slice := []string{"a","b","c","d","e"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过内置的 append 函数对一个切片追加元素，返回新切片，如下面的代码所示：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">//追加一个元素
slice2:=append(slice1,"f")

//多加多个元素
slice2:=append(slice1,"f","g")

//追加另一个切片
slice2:=append(slice1,slice...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>小技巧：</p>
<p>​	在创建新切片的时候，最好要让新切片的<strong>长度==容量</strong>，这样在追加操作的时候就会<strong>生成新的</strong>底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p>
<h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   // 定义slice并初始化
   ss := []string{"will","张三"}
   fmt.Println("切片ss长度为",len(ss),",容量为",cap(ss))
    
   // 动态扩容
   ss=append(ss,"李四","王五")
   fmt.Println("切片ss长度为",len(ss),",容量为",cap(ss))
    
   fmt.Println(ss)
    
   // 插入
   slice = append([]string{}, slice...)
}
// 切片ss长度为 2 ,容量为 2
// 切片ss长度为 4 ,容量为 4
// [will 张三 李四 王五]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>append 自动扩容的原理</strong>：</p>
<ol>
<li><code>新建</code>一个底层数组</li>
<li>把原来切片内的元素<code>拷贝</code>到新数组中</li>
<li>最后返回一个<code>指向新数组</code>的切片</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type SliceHeader struct {
   Data uintptr
   Len  int
   Cap  int
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>SliceHeader 是切片<code>在运行时</code>的表现形式：</p>
<ul>
<li>Data 用来<code>指向</code>存储切片元素的数组</li>
<li>Len 代表切片的<code>长度</code> </li>
<li>Cap 代表切片的<code>容量 </code></li>
</ul>
<p><code>不同切片</code>对应的<u>底层 Data</u> <code>指向</code>的可能是<code>同一个数组</code>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   // 定义并初始化数组
   a1:=[2]string{"will","张三"}
   
   // 根据数组定义slice
   s1:=a1[0:1]
   s2:=a1[:]
    
   //打印出s1和s2的Data值，是一样的
   fmt.Println((*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)).Data)
   fmt.Println((*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)).Data)
}
// 824634150744
// 824634150744<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>注意：</p>
<p>多个切片共用一个底层数组虽然可以减少内存占用，但是如果有一个切片修改内部的元素，其他切片也会受影响。</p>
<p>所以在切片作为参数在函数间传递的时候要小心，**<u><em>尽可能不要修改原切片内的元素</em></u>**。</p>
</blockquote>
<h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><p>对于数组和切片来说，Go 语言有三种不同的遍历方式：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 不关心索引和数据的情况
for range a {}

// 只关心索引的情况
for i := range a {}

// 关心索引和数据的情况
for i, elem := range a {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>









<h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><ul>
<li><p>从<code>集合类型</code>的角度考虑</p>
<ul>
<li>数组、切片和 map 都是集合类型，它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是<code>连续的内存</code>操作，<em><strong>通过索引就可以快速地找到元素存储的地址</strong></em> </li>
<li>当然 map 的价值也非常大，因为它的 Key 可以是很多类型，比如 int、int64、string 等</li>
<li>数组和切片的<code>索引</code>只能是<em><strong>整数</strong></em></li>
</ul>
</li>
<li><p>从<code>内存大小</code>的角度考虑</p>
<ul>
<li>在数组和切片中，切片又是高效的，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 SliceHeader 的三个字段就可以了，共用的还是同一个底层数组</li>
<li>切片的高效还体现在 for range 循环中，因为<code>循环得到的临时变量也是个值拷贝</code>，所以在遍历大的数组时，切片的效率更高</li>
</ul>
</li>
</ul>
<p>总结：切片<code>基于指针的封装</code>是它效率高的根本原因，因为可以减少内存的占用，以及减少内存复制时的时间消耗</p>
<h3 id="string-lt-x3D-gt-byte"><a href="#string-lt-x3D-gt-byte" class="headerlink" title="string <=> byte"></a>string &lt;=&gt; byte</h3><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p> []byte(s) 和 string(b) 这种<code>强制转换</code><strong>会重新拷贝一份字符串</strong> </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s := "will"
fmt.Printf("s的内存地址：%d\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Data)

b := []byte(s)
fmt.Printf("b的内存地址：%d\n",(*reflect.SliceHeader)(unsafe.Pointer(&amp;b)).Data)

s3 := string(b)
fmt.Printf("s3的内存地址：%d\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s3)).Data)

fmt.Println(s,string(b),s3)		// 都是 "will"

// 打印出的内存地址都不一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>提示：</p>
<p>可以通过查看 runtime.stringtoslicebyte 和 runtime.slicebytetostring 这两个函数的源代码，了解关于 string 和 []byte 类型互转的具体实现。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// StringHeader is the runtime representation of a string.
type StringHeader struct {
   Data uintptr		// 用于存放指向真实内容的指针
   Len  int
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在程序运行的时候，字符串和切片本质上就是 StringHeader 和 SliceHeader</li>
</ul>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">s:="will"
b:=[]byte(s)
// s3:=string(b)

// s4 没有申请新内存（零拷贝）,和变量 b 使用的是同一块内存，因为它们的底层 Data 字段值相同
s4 := *(*string)(unsafe.Pointer(&amp;b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p> 字符串转成byte数组：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">a := "aaa"
ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a))
b := *(*[]byte)(unsafe.Pointer(&amp;ssh))  
fmt.Printf("%v",b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址</li>
<li><code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串a转成底层结构的形式</li>
<li><code>(*[]byte)(unsafe.Pointer(&amp;ssh))</code> 可以把ssh底层结构体转成byte的切片的指针</li>
<li>再通过 <code>*</code>转为指针指向的实际内容</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rGqM1wMlqQEoJSgyrgZNLg">2 个 Header</a> </p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
 s := "脑子进煎鱼了"
 v := string2bytes1(s)
 fmt.Println(v)
}

func string2bytes1(s string) []byte {
 
 // 在程序必须保留一个单独的、正确类型的指向底层数据的指针
 stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))

 var b []byte
 pbytes := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))
 pbytes.Data = stringHeader.Data
 pbytes.Len = stringHeader.Len
 pbytes.Cap = stringHeader.Len

 return b
}


// 在性能方面，若只是期望单纯的转换，对容量（cap）等字段值不敏感，也可以使用以下方式：
func string2bytes2(s string) []byte {
 return *(*[]byte)(unsafe.Pointer(&amp;s))
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h4 id="SliceHeader-x2F-StringHeader"><a href="#SliceHeader-x2F-StringHeader" class="headerlink" title="SliceHeader/StringHeader"></a>SliceHeader/StringHeader</h4><ul>
<li><p>SliceHeader 有 Data、Len、Cap 三个字段</p>
</li>
<li><p>StringHeader 有 Data、Len 两个字段</p>
</li>
<li><p>所以 *SliceHeader 通过 unsafe.Pointer 转为 *StringHeader 的时候没有问题，因为 *SliceHeader 可以提供 *StringHeader 所需的 Data 和 Len 字段的值</p>
</li>
<li><p>但是反过来却不行了，因为 *StringHeader 缺少 *SliceHeader 所需的 Cap 字段，需要我们自己补上一个默认值</p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s:="will"
//b:=[]byte(s)

sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;s))
sh.Cap = sh.Len

b1:=*(*[]byte)(unsafe.Pointer(sh))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p>注意：</p>
<p>通过 unsafe.Pointer 把 string 转为 []byte 后，不能对 []byte 修改</p>
<p>比如不可以进行 b1[0]=12 这种操作，会报异常，导致程序崩溃。</p>
<p>这是因为在 Go 语言中 string 内存是只读的。</p>
</blockquote>
<p>扩展：<a target="_blank" rel="noopener" href="https://developer.51cto.com/art/202106/665738.htm">Go 语言中的零拷贝优化</a> </p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4jvhRQvKlMiYweSOG6xCrA">小技巧分享：在 Go 如何实现枚举？</a> </p>
<h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   i := 3
    
   // reflect.Value 是一个结构体
   iv := reflect.ValueOf(i)
    
   // reflect.Type 是一个接口
   it := reflect.TypeOf(i)
    
   fmt.Println(iv,it)
   // 3 int
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p> reflect.Value 和 int 类型互转：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   i := 3
   // int to reflect.Value
   iv := reflect.ValueOf(i)
    
   // reflect.Value to int
   i1 := iv.Interface().(int)
    
   fmt.Println(i1)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>interface{} 是空接口，可以表示任何类型，也就是说你可以把任何类型转换为空接口，它通常用于反射、类型断言，以减少重复代码，简化编程。</p>
</blockquote>
<p>修改对应的值：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   i := 3
    
   // 因为 reflect.ValueOf 函数返回的是一份值的拷贝，所以要传入变量的指针才可以
   ipv := reflect.ValueOf(&amp;i)
   
    //  因为传递的是一个指针，所以需要调用 Elem 方法找到这个指针指向的值，最后就可以使用 SetInt 方法修改值
   ipv.Elem().SetInt(4)
    
   fmt.Println(i)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>那么如何修改 <code>struct 结构体字段</code> 的值呢？</p>
<ol>
<li><p>传递一个 struct 结构体的指针，获取对应的 reflect.Value；</p>
</li>
<li><p>通过 Elem 方法获取指针指向的值；</p>
</li>
<li><p>通过 Field 方法获取要修改的字段；</p>
</li>
<li><p>通过 Set 系列方法修改成对应的值。</p>
</li>
</ol>
<p>如：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := person{Name: "will",Age: 20}
   ppv := reflect.ValueOf(&amp;p)
   ppv.Elem().Field(0).SetString("张三")
   fmt.Println(p)
}
type person struct {
   Name string
   Age int
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>通过反射修改一个值的规则：</p>
<ol>
<li><p>可被寻址，通俗地讲就是要向 reflect.ValueOf 函数<code>传递一个指针作为参数</code> </p>
</li>
<li><p>如果要修改 struct 结构体字段值的话，该字段需要是可导出的，而不是私有的，也就是<code>该字段的首字母为大写</code></p>
</li>
<li><p>记得使用 <code>Elem</code> 方法<code>获得指针指向的值</code>，这样才能调用<code> Set 系列</code>方法进行修改</p>
</li>
</ol>
<p>获取对应的底层类型：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := person{Name: "will",Age: 20}
    
   pv := reflect.ValueOf(p)
   fmt.Println(pv.Kind())
   // struct
   
   ppv := reflect.ValueOf(&amp;p)
   fmt.Println(ppv.Kind())
   // ptr
    
}
// 变量 p 的实际类型是 person，但是 person 对应的底层类型是 struct 这个结构体类型，而 &amp;p 对应的则是指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>和 reflect.Value 不同，reflect.Type <code>是一个接口</code>，而不是一个结构体，所以只能使用它的方法。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type Type interface {

   Implements(u Type) bool		// 是否实现了接口 u
   AssignableTo(u Type) bool	// 是否可以使用 =
   ConvertibleTo(u Type) bool	// 是否可以进行类型转换
   Comparable() bool			// 是否可以使用关系运算符进行比较
   
   // 以下这些方法和Value结构体的功能相同
   Kind() Kind
   Method(int) Method
   MethodByName(string) (Method, bool)
   NumMethod() int
   Elem() Type
   Field(i int) StructField
   FieldByIndex(index []int) StructField
   FieldByName(name string) (StructField, bool)
   FieldByNameFunc(match func(string) bool) (StructField, bool)
   NumField() int
}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {
   Name string
   Age int
}
func (p person) String() string{
   return fmt.Sprintf("Name is %s,Age is %d", p.Name, p.Age)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>遍历结构体的字段和方法</strong>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := person{Name: "will",Age: 20}
   pt := reflect.TypeOf(p)
    
   //遍历person的字段
   for i:=0; i&lt;pt.NumField(); i++{
      fmt.Println("字段：",pt.Field(i).Name)
   }
    
   //遍历person的方法
   for i:=0; i&lt;pt.NumMethod(); i++{
      fmt.Println("方法：",pt.Method(i).Name)
   }
}
// 输出：
// 字段： Name
// 字段： Age
// 方法： String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>可以通过 FieldByName 方法获取指定的字段，也可以通过 MethodByName 方法获取指定的方法，获取某个特定的字段或者方法时非常高效，而不是使用遍历。</p>
</blockquote>
<p><strong>是否实现某接口</strong>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := person{Name: "will",Age: 20}
   pt := reflect.TypeOf(p)
    
   // 判断是否实现了接口 fmt.Stringer 和 io.Writer
   // elem 获得指针指向的值
   stringerType := reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
   writerType := reflect.TypeOf((*io.Writer)(nil)).Elem()
    
   fmt.Println("是否实现了fmt.Stringer：",pt.Implements(stringerType))
   fmt.Println("是否实现了io.Writer：",pt.Implements(writerType))
}
// 是否实现了fmt.Stringer： true
// 是否实现了io.Writer： false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>尽可能通过类型断言的方式判断是否实现了某接口，而不是通过反射</p>
</blockquote>
<h3 id="JSON-lt-x3D-gt-Struct"><a href="#JSON-lt-x3D-gt-Struct" class="headerlink" title="JSON <=> Struct"></a>JSON &lt;=&gt; Struct</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := person{Name: "will",Age: 20}
    
   //struct to json
   jsonB,err := json.Marshal(p)
   if err == nil {
      fmt.Println(string(jsonB))
   }
    
   //json to struct
   respJSON:="{\"Name\":\"李四\",\"Age\":40}"
   json.Unmarshal([]byte(respJSON), &amp;p)
   fmt.Println(p)
}
// {"Name":"飞雪无情","Age":20}
// Name is 李四,Age is 40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>JSON 字符串的 Key 和 struct 结构体的字段名称一样，比如示例中的 Name 和 Age</li>
<li>想把输出的 json 字符串的 Key 改为小写的 name 和 age，可以通过为 struct 字段添加 tag 的方式</li>
</ul>
<h3 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h3><p>struct tag 是一个<code>添加在 struct 字段上的标记</code> ，使用它进行辅助，可以完成一些额外的操作</p>
<p>比如 json 和 struct 互转：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {
   Name string `json:"name"`
   Age int `json:"age"`
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>重点：</p>
<p>json 作为 Key，是 Go 语言自带的 json 包解析 JSON 的一种==约定==</p>
<p>它会通过 json 这个 Key 找到对应的值，<em>用于</em>  <u>JSON 的 Key 值</u></p>
</blockquote>
<p> tag 就像是我们为 struct 字段起的别名，那么 json 包是如何获得这个 tag 的呢？</p>
<ul>
<li>反射</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">//遍历person字段中key为json的tag
for i:=0; i&lt;pt.NumField(); i++{
    
   //  Field 方法返回一个 StructField 结构体，有一个字段是 Tag，存有字段的所有 tag
   sf:=pt.Field(i)
   
   fmt.Printf("字段%s上,json tag为%s\n",sf.Name, sf.Tag.Get("json"))
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>结构体的字段可以有多个 tag，用于不同的场景</p>
<ul>
<li>比如 json 转换、bson 转换、orm 解析等</li>
<li>如果有多个 tag，要使用<code>空格分隔</code></li>
<li>采用不同的 Key 可以获得不同的 tag</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {
   Name string `json:"name" bson:"b_name"`
   Age int `json:"age" bson:"b_age"`
}

// 遍历person字段中key为json、bson的tag
for i:=0; i&lt;pt.NumField(); i++{
   sf := pt.Field(i)
   fmt.Printf("字段%s上,json tag为%s\n",sf.Name, sf.Tag.Get("json"))
   fmt.Printf("字段%s上,bson tag为%s\n",sf.Name, sf.Tag.Get("bson"))
}
// 字段Name上,key为json的tag为name
// 字段Name上,key为bson的tag为b_name
// 字段Age上,key为json的tag为age
// 字段Age上,key为bson的tag为b_age<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>实现 Struct 转 JSON</strong>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := person{Name: "will",Age: 20}
   pv := reflect.ValueOf(p)
   pt := reflect.TypeOf(p)
    
   // 自己实现的struct to json
   jsonBuilder := strings.Builder{}
   jsonBuilder.WriteString("{")
   
   num := pt.NumField()
    
   for i := 0; i&lt;num; i++{
      jsonTag := pt.Field(i).Tag.Get("json") //获取json tag
      jsonBuilder.WriteString("\""+jsonTag+"\"")
      jsonBuilder.WriteString(":")
      //获取字段的值
      jsonBuilder.WriteString(fmt.Sprintf("\"%v\"",pv.Field(i)))
      if i&lt;num-1{
         jsonBuilder.WriteString(",")
      }
   }
   jsonBuilder.WriteString("}")
   fmt.Println(jsonBuilder.String())//打印json字符串
}
// {"name":"飞雪无情","age":"20"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>json 字符串的转换只是 struct tag 的一个应用场景</p>
<ul>
<li><p>完全可以把 struct tag 当成结构体中字段的元数据配置，使用它来做想做的任何事情</p>
</li>
<li><p>比如 orm 映射、xml 转换、生成 swagger 文档等</p>
</li>
</ul>
<h3 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h3><p><a target="_blank" rel="noopener" href="https://blog.golang.org/laws-of-reflection">反射的三大定律</a>：</p>
<ol>
<li><p>任何接口值，interface{} 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</p>
</li>
<li><p>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的<code>可逆性</code>，通过 reflect.Value 结构体的 Interface 方法获得。</p>
</li>
<li><p>要修改反射的对象，该值必须可设置，也就是<code>可寻址</code>。</p>
</li>
</ol>
<blockquote>
<p>提示：</p>
<p>任何类型的变量都可以转换为空接口 intferface{}，所以第 1 条定律中函数 reflect.ValueOf 和 reflect.TypeOf 的参数就是 interface{}，表示可以把任何类型的变量转换为反射对象。</p>
<p>在第 2 条定律中，reflect.Value 结构体的 Interface 方法返回的值也是 interface{}，表示可以把反射对象还原为对应的类型变量。</p>
</blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在反射中：</p>
<ul>
<li>reflect.Value 对应的是<code>变量的值</code>，如果你需要进行和变量的<em><strong>值有关</strong></em> 的操作，应该优先使用 reflect.Value比如获取变量的值、修改变量的值等。</li>
<li>reflect.Type 对应的是<code>变量的类型</code>，如果你需要进行和变量的<em><strong>类型本身有关</strong></em> 的操作，应该优先使用 reflect.Type，比如获取结构体内的字段、类型拥有的方法集等。</li>
</ul>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>原因：</p>
<ul>
<li>Go 的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<code>强类型</code>的<code>静态</code>语言</li>
<li>强类型意味着，一旦定义了，类型就不能改变</li>
<li>静态意味着，在运行前，做了类型检查</li>
<li>同时出于安全考虑，Go 语言是<code>不允许两个指针类型进行转换</code></li>
</ul>
<h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p>**如 <em>int 不能转为 <em>float64</em></em> ：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   i:= 10
   ip:=&amp;i
   var fp *float64 = (*float64)(ip)
   fmt.Println(fp)
}
// cannot convert ip (type * int) to type * float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>但如果还是需要转换呢？？？</strong> </p>
<p><code>unsafe.Pointer</code> 是一种特殊意义的指针，==可以表示任意类型的地址==，类似 C 语言里的 void* 指针，**<u><em>是全能型的</em></u>**</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   i:= 10
   ip:=&amp;i
    
   var fp *float64 = (*float64)(unsafe.Pointer(ip))
    
   *fp = *fp * 3
   fmt.Println(i)
}
// 30
// 原来变量 i 的值也被改变了，变为 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// uintptr is an integer type that is large enough 
// to hold the bit pattern of any pointer.
// 足够大，可以表示任何指针
type uintptr uintptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>uintptr 可以对<code>指针偏移</code><em>进行计算</em>，这样就<strong>可以访问特定的内存</strong>，<em>达到对特定内存读写的目的</em>，真正内存级别的操作</p>
</blockquote>
<p><strong>通过指针偏移修改 struct 结构体内的字段</strong>：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   p := new(person)
    
   // Name是person的第一个字段不用偏移，即可通过指针修改
   pName := (*string)(unsafe.Pointer(p))
   *pName = "will"
    
   // Age并不是person的第一个字段，所以需要进行偏移，这样才能正确定位到Age字段这块内存，才可以正确的修改
   pAge := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+unsafe.Offsetof(p.Age)))
   *pAge = 20
   fmt.Println(*p)
}
type person struct {
   Name string
   Age int
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>因为 Age 字段不是 person 的第一个字段，要修改它必须要进行指针偏移运算</li>
<li>所以需要先把指针变量 p 通过 unsafe.Pointer 转换为 uintptr，这样才能进行地址运算</li>
<li>偏移量可以通过函数 unsafe.Offsetof 计算出来，该函数返回的是一个 uintptr 类型的偏移量</li>
</ul>
<h3 id="unsafe-Sizeof"><a href="#unsafe-Sizeof" class="headerlink" title="unsafe.Sizeof"></a>unsafe.Sizeof</h3><p>Sizeof 函数可以返回<code>一个类型所占用的内存大小</code> ，这个大小<strong>只与类型有关</strong>，<em>和类型对应的变量存储的内容大小无关</em></p>
<ul>
<li>比如 bool 型占用一个字节、int8 也占用一个字节</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(unsafe.Sizeof(true))
fmt.Println(unsafe.Sizeof(int8(0)))
fmt.Println(unsafe.Sizeof(int16(10)))
fmt.Println(unsafe.Sizeof(int32(10000000)))
fmt.Println(unsafe.Sizeof(int64(10000000000000)))
fmt.Println(unsafe.Sizeof(int(10000000000000000)))
fmt.Println(unsafe.Sizeof(string("will")))
fmt.Println(unsafe.Sizeof([]string{"李四","张三"}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p>一个 struct 结构体的内存占用大小，等于它包含的字段类型内存占用大小之和。</p>
</blockquote>
<h3 id="指针转换规则"><a href="#指针转换规则" class="headerlink" title="指针转换规则"></a>指针转换规则</h3><p><img src="https://raw.githubusercontent.com/MicroWiller/photobed/master/PointerExchange.png"></p>
<ol>
<li>任何类型的 *T 都可以转换为 unsafe.Pointer</li>
<li>unsafe.Pointer 也可以转换为任何类型的 *T</li>
<li>unsafe.Pointer 可以转换为 uintptr</li>
<li>uintptr 也可以转换为 unsafe.Pointer</li>
</ol>
<ul>
<li>unsafe.Pointer 主要用于指针类型的转换，是各个<code>指针类型转换</code>的桥梁</li>
<li>uintptr 主要用于<code>指针运算</code>，尤其是通过偏移量定位不同的内存</li>
</ul>
<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p> <a target="_blank" rel="noopener" href="https://blog.betacat.io/post/golang-atomic-value-exploration/">atomic.Value 的前世今生</a>：“原子的”存储（Store）和加载（Load）<strong>任意类型</strong>的值</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// A Value provides an atomic load and store of a consistently typed value.
// The zero value for a Value returns nil from Load.
// Once Store has been called, a Value must not be copied.
//
// A Value must not be copied after first use.
type Value struct {
	v interface{}
}

// Load returns the value set by the most recent Store.
// It returns nil if there has been no call to Store for this Value.
func (v *Value) Load() (x interface{}) {
	......
}

// Store sets the value of the Value to x.
// All calls to Store for a given Value must use values of the same concrete type.
// Store of an inconsistent type panics, as does Store(nil).
func (v *Value) Store(x interface{}) {
    .....
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>











<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main.go
func Fibonacci(n int) int {
   if n &lt; 0 {
      return 0
   }
   if n == 0 {
      return 0
   }
   if n == 1 {
      return 1
   }
   return Fibonacci(n-1) + Fibonacci(n-2)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main_test.go
func TestFibonacci(t *testing.T) {
   //预先定义的一组斐波那契数列作为测试用例
   fsMap := map[int]int{}
   fsMap[0] = 0
   fsMap[1] = 1
   fsMap[2] = 1
   fsMap[3] = 2
   fsMap[4] = 3
   fsMap[5] = 5
   fsMap[6] = 8
   fsMap[7] = 13
   fsMap[8] = 21
   fsMap[9] = 34
   for k, v := range fsMap {
      fib := Fibonacci(k)
      if v == fib {
         t.Logf("结果正确:n为%d,值为%d", k, fib)
      } else {
         t.Errorf("结果错误：期望%d,但是计算的值是%d", v, fib)
      }
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行如下命令，进行单元测试：
go test -v ./ch18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go test -v ./ch18&nbsp;
=== RUN&nbsp; &nbsp;TestFibonacci
&nbsp; &nbsp; main_test.go:21: 结果正确:n为0,值为0
&nbsp; &nbsp; main_test.go:21: 结果正确:n为1,值为1
&nbsp; &nbsp; main_test.go:21: 结果正确:n为6,值为8
&nbsp; &nbsp; main_test.go:21: 结果正确:n为8,值为21
&nbsp; &nbsp; main_test.go:21: 结果正确:n为9,值为34
&nbsp; &nbsp; main_test.go:21: 结果正确:n为2,值为1
&nbsp; &nbsp; main_test.go:21: 结果正确:n为3,值为2
&nbsp; &nbsp; main_test.go:21: 结果正确:n为4,值为3
&nbsp; &nbsp; main_test.go:21: 结果正确:n为5,值为5
&nbsp; &nbsp; main_test.go:21: 结果正确:n为7,值为13
--- PASS: TestFibonacci (0.00s)
PASS
ok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;(cached)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h3 id="五点规则"><a href="#五点规则" class="headerlink" title="五点规则"></a>五点规则</h3><ol>
<li><p>含有单元测试代码的 go 文件必须<code>以 _test.go 结尾</code>，Go 语言测试工具只认符合这个规则的文件</p>
</li>
<li><p>单元测试文件名 _test.go <code>前面的部分</code>，最好是被测试的函数所在的 go 文件的文件名</p>
<ul>
<li>比如以上示例中单元测试文件叫 main_test.go，因为测试的 Fibonacci 函数在 main.go 文件里</li>
</ul>
</li>
<li><p>单元测试的函数名必须<code>以 Test 开头</code>，是可导出的、公开的函数</p>
</li>
<li><p>测试函数的签名必须<code>接收一个指向 testing.T 类型的指针</code>，并且<code>不能返回任何值</code></p>
</li>
<li><p>函数名最好是 <code>Test + 要测试的函数名</code></p>
<ul>
<li>比如例子中是 TestFibonacci，表示测试的是 Fibonacci 这个函数。</li>
</ul>
</li>
</ol>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go test -v --coverprofile=ch18.cover ./ch18

//1. go test -v -coverpkg=./... -coverprofile=profile.cov ./...
//2. go tool cover -func profile.cov<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>可以得到一个单元测试覆盖率文件，运行这行命令还可以同时看到测试覆盖率</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PASS
coverage: 85.7% of statements
ok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;0.367s&nbsp; coverage: 85.7% of statements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p><strong>查看详细的单元测试覆盖率报告</strong>：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go tool cover -html=ch18.cover -o=ch18.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>命令运行后，会在当前目录下生成一个 ch18.html 文件，使用浏览器打开它，查看内容</p>
<h3 id="race-检测"><a href="#race-检测" class="headerlink" title="race 检测"></a>race 检测</h3> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run -race main.go <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<ul>
<li>编译器会通过探测所有的内存访问，监听其内存地址的访问（读或写）</li>
<li>在应用运行时就能够发现对共享变量的访问和操作，进而发现问题并打印出相关的警告信息</li>
</ul>
<p>需要注意的一点是，<code>go run -race</code> 是运行时检测，并不是编译时。且 race 存在明确的性能开销，通常是正常程序的<strong>十倍</strong>，因此不要想不开在生产环境打开这个配置，很容易翻车。</p>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main_test.go
func BenchmarkFibonacci(b *testing.B){
   for i:=0;i&lt;b.N;i++{
      Fibonacci(10)
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>基准测试函数必须<code>以 Benchmark 开头</code>，必须是可导出的</li>
<li>函数的签名必须接收一个<code>指向 testing.B 类型的指针</code>，并且不能返回任何值</li>
<li>最后的 <code>for 循环</code> 很重要，<em>被测试的代码要放到循环里</em></li>
<li><code>b.N</code> 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#  -bench 表示，接受一个表达式作为参数，以匹配基准测试的函数
# "." 表示运行所有基准测试
➜ go test -bench=. ./ch18
goos: darwin
goarch: amd64
pkg: gotour/ch18
BenchmarkFibonacci-8&nbsp; &nbsp; &nbsp;3461616&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;343 ns/op
PASS
ok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;2.230s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>BenchmarkFibonacci-8 ，后面的 -8 ，表示运行基准测试时对应的 GOMAXPROCS 的值</p>
</li>
<li><p>基准测试的时间默认是 1 秒，也就是 1 秒调用 3461616 次、每次调用花费 343 纳秒</p>
</li>
<li><p>如果想让测试运行的时间更长，可以通过 -benchtime 指定，比如 3 秒</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go test -bench=. -benchtime=3s ./ch18<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h3 id="计时方法"><a href="#计时方法" class="headerlink" title="计时方法"></a>计时方法</h3><blockquote>
<p>避免因为准备数据耗时造成的干扰</p>
</blockquote>
<p>进行基准测试之前会做一些准备，比如构建测试数据等，这些准备也需要消耗时间，所以需要<code>把这部分时间排除在外</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">func BenchmarkFibonacci(b *testing.B) {
   n := 10
   b.ResetTimer() //重置计时器
   for i := 0; i &lt; b.N; i++ {
      Fibonacci(n)
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>除了 ResetTimer 方法外，还有 StartTimer 和 StopTimer 方法，灵活地控制什么时候开始计时、什么时候停止计时。</li>
</ul>
<h3 id="内存统计"><a href="#内存统计" class="headerlink" title="内存统计"></a>内存统计</h3><p>统计每次操作分配内存的次数，以及每次操作分配的字节数</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func BenchmarkFibonacci(b *testing.B) {
   n := 10
   b.ReportAllocs() //开启内存统计
   b.ResetTimer() //重置计时器
   for i := 0; i &lt; b.N; i++ {
      Fibonacci(n)
   }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go test -bench=.&nbsp; ./ch18
goos: darwin
goarch: amd64
pkg: gotour/ch18
BenchmarkFibonacci-8&nbsp; 2486265&nbsp; 486 ns/op&nbsp;&nbsp;0 B/op&nbsp; 0 allocs/op
PASS
ok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;2.533s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>0 B/op</code>，表示每次操作分配了多少字节的内存</li>
<li><code>0 allocs/op</code>，表示每次操作分配内存的次数</li>
</ul>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><h4 id="逃逸实列"><a href="#逃逸实列" class="headerlink" title="逃逸实列"></a>逃逸实列</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch19/main.go
func newString() *string{
   s:=new(string)
   *s = "will"
   return s
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>通过 new 函数申请了一块内存；</p>
</li>
<li><p>然后把它赋值给了指针变量 s；</p>
</li>
<li><p>最后通过 return 关键字返回。</p>
</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ go build -gcflags="-m -l" ./ch19/main.go
# command-line-arguments
ch19/main.go:16:8: new(string) escapes to heap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>-m 表示打印出逃逸分析信息</li>
<li>-l 表示禁止内联</li>
<li><strong>指针</strong>作为<em>函数返回值</em> 的时候，一定会发生逃逸</li>
</ul>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func newString() string{
   s:=new(string)
   *s = "will"
   return *s
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再次通过命令查看以上代码的逃逸分析，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go build -gcflags="-m -l" ./ch19/main.go
# command-line-arguments
ch19/main.go:14:8: new(string) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>





<h4 id="被已经逃逸的指针-引用-的变量-也会发生逃逸"><a href="#被已经逃逸的指针-引用-的变量-也会发生逃逸" class="headerlink" title="被已经逃逸的指针 引用 的变量 也会发生逃逸"></a>被已经逃逸的指针 引用 的变量 也会发生逃逸</h4><p>==并不是不使用指针就不会发生逃逸==</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println("will")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ go build -gcflags="-m -l" ./ch19/main.go
# command-line-arguments
ch19/main.go:13:13: ... argument does not escape
ch19/main.go:13:14: "will" escapes to heap
ch19/main.go:17:8: new(string) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>「will」<strong>逃逸</strong>到了堆上，这是因为「will」这个字符串<strong>被已经逃逸的指针变量</strong> <em>引用</em>，所以它也跟着逃逸了</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (p *pp) printArg(arg interface{}, verb rune) {
   p.arg = arg
   //省略其他无关代码
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>







<h4 id="被-slice、map-和-chan，这三种类型引用的指针也会发生逃逸"><a href="#被-slice、map-和-chan，这三种类型引用的指针也会发生逃逸" class="headerlink" title="被 slice、map 和 chan，这三种类型引用的指针也会发生逃逸"></a>被 slice、map 和 chan，这三种类型引用的指针也会发生逃逸</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   m:=map[int]*string{}
   s:="will"
   m[0] = &amp;s
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp; gotour go build -gcflags="-m -l" ./ch19/main.go
# command-line-arguments
ch19/main.go:16:2: moved to heap: s
ch19/main.go:15:20: map[int]*string literal does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量 m 没有逃逸，<strong>反而</strong>被变量 m 引用的变量 s 逃逸到了堆上</li>
<li>所以被map、slice 和 chan 这三种类型 引用 的指针一定会发生逃逸的</li>
</ul>
<blockquote>
<p>指针虽然可以减少内存的拷贝，但它同样会引起逃逸，所以要根据实际情况选择是否使用指针。</p>
</blockquote>
<h4 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h4><ol>
<li>尽可能避免逃逸，因为栈内存效率更高，还不用 GC。比如<strong>小对象的传参</strong>，array 要比 slice 效果好。</li>
<li>如果避免不了逃逸，还是在堆上分配了内存，那么对于频繁的内存申请操作，我们要学会<strong>重用内存</strong>，比如使用 sync.Pool</li>
<li>选用合适的算法，达到高性能的目的，比如<strong>空间换时间</strong> </li>
<li>尽可能避免使用锁、并发加锁的范围要尽可能小</li>
<li>使用 StringBuilder 做 string 和 [ ] byte 之间的转换</li>
<li>defer 嵌套不要太多</li>
</ol>
<blockquote>
<p>小提示：性能优化的时候，要结合基准测试，来验证自己的优化是否有提升。</p>
</blockquote>
<h3 id="并发基准测试"><a href="#并发基准测试" class="headerlink" title="并发基准测试"></a>并发基准测试</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func BenchmarkFibonacciRunParallel(b *testing.B) {
   n := 10
   b.RunParallel(func(pb *testing.PB) {
      for pb.Next() {
         Fibonacci(n)
      }
   })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>通过 RunParallel 方法运行并发基准测试</li>
<li>RunParallel 方法会创建多个 goroutine，并将 b.N 分配给这些 goroutine 执行</li>
</ul>
<h3 id="接口-依赖注入"><a href="#接口-依赖注入" class="headerlink" title="接口+依赖注入"></a>接口+依赖注入</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type transaction struct {
    ID       string
    BuyerID  int
    SellerID int
    Amount   float64
    createdAt time.Time
    Status TransactionStatus
}

func (t *transaction) Execute() bool {
    if t.Status == Executed {
        return true
    }
    if time.Now() - t.createdAt &gt; 24.hours { // 交易有有效期
        t.Status = Expired
        return false
    }
    client := BankClient.New(config.token) // 调用银行的 SDK 执行转账
    if err := client.TransferMoney(id, t.BuyerID, t.SellerID, t.Amount); err != nil {
        t.Status = Failed
        return false
    }
    t.Status = Executed
    return true
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最重要的功能集中在<code>Execute()</code>函数中，但它却不好测试，因为它有两个外部依赖：</p>
<ol>
<li>行为不确定的<code>time.Now</code>函数，每一次调用都会产生不同的结果</li>
<li>银行提供的转账 SDK，我们不可能每次测试都去真的调用一下，那测试成本也忒高了</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 先将代码里使用到的方法抽象成一个接口
type Transferer interface {
    TransferMoney(id int, buyerID int, sellerID int, amount float64) error
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>放到<code>transaction</code>的成员属性中，重构后的<code>transaction</code>类及其构造函数就变成了这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">type transaction struct {
    ID       string
    BuyerID  int
    SellerID int
    Amount   float64
    createdAt time.Time
    Status TransactionStatus
    // 增加了一个存放接口的属性
    transferer Transferer
}

func New(buyerID, sellerID int, amount float64, transferer Transferer) *transaction {
    return &amp;transaction{
        ID:         IdGenerator.generate(),
        BuyerID:    buyerID,
        SellerID:   sellerID,
        Amount:     amount,
        createdAt:  time.Now(),
        Status:     TO_BE_EXECUTD,
        transferer: transferer, // 注入进 transaction 类中
    }
}

func (t *transaction) Execute() bool {
    //...
    //不直接创建，而是使用别人注入的接口实例
    t.transferer.TransferMoney(id, t.BuyerID, t.SellerID, t.Amount)
    //...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在，可以在单元测试中就能够很方便的替换掉那个成本高昂的支付接口的调用了</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">// 定义一个满足 Transferer 接口的 mock 类
type MockedClient struct {
    responseError error // 实例化的时候可以将期望的返回值保存进来
}

func (m *MockedClient) TransferMoney(id int, buyerID int, sellerID int, amount float64) error {
    return m.responseError
}

func Test_transaction_Execute(t *testing.T) {
    // 实例化一个可以自由控制结果的 client
    transferer := &amp;MockedClient{
        responseError: errors.New("insufficient balance"),
    }
    tnx := New(buyerID, sellerID, amount, transferer)
    if succeeded := tnx.Execute(); succeeded != false {
        t.Errorf("Execute() = %v, want %v", succeeded, false)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-go" data-language="go"><code class="language-go">var nowFn = time.Now //一个全局变量，用来解耦time.Now的生产者和消费者

func (t *transaction) Execute() bool {
    if t.Status == Executed {
        return true
    }
    if nowFn() - t.createdAt &gt; 24.hours { // 不直接调用time.Now()
        t.Status = Expired
        return false
    }
    //...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样，单元测试就能随心所欲的改变“当前时间”了</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Test_expired_transaction_Execute(t *testing.T) {
    // 用同样的函数签名改写业务中需要的时间函数
    // 这里能改变私有的全局变量是因为测试代码跟业务代码处于同一个包中
    nowFn = func() time.Time {
        return time.Now().Add(-24 * time.Hour)
    }
    // 依旧需要实例化一个假的的 client
    transferer := &amp;MockedClient{
        responseError: nil,
    }
    tnx := New(buyerID, sellerID, amount, transferer)
    //...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>隐式的复用了<code>time.Now</code>的<strong>函数签名</strong>，将它当做一种“接口类型”来使用</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.betacat.io/post/2020/03/a-pattern-for-writing-testable-go-code/#mock-timenow">编写可测试 Go 代码的一种模式</a> </p>
<h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016412013">pprof</a>：runtime / net</p>
<p><a target="_blank" rel="noopener" href="https://github.com/uber-archive/go-torch">go-torch</a> </p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yZUE8N-Qb-AB81DgA1cV_w">golang性能诊断</a>：<code>pprof</code> / <code>trace</code> / <code>linux</code></p>
<h2 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h2><p>一个典型的 HTTP 服务应该如图所示：</p>
<p><img src="/go.assets/image-20210616203918882.png" alt="image-20210616203918882"></p>
<p>http服务器的工作就在于: </p>
<ul>
<li>如何接受来自客户端的请求(socket / router)</li>
<li>并向客户端返回响应</li>
</ul>
<p> Go HTTP 标准库  <code>net/http</code> 的实现原理: </p>
<p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/StanderdLibOfHttp.png"></p>
<ol>
<li>注册处理器到一个 hash 表中，可以通过键值路由匹配；</li>
<li>注册完之后就是开启循环监听，每监听到一个连接就会创建一个 Goroutine；</li>
<li>在创建好的 Goroutine 里面会循环的等待接收请求数据，然后根据请求的地址去处理器路由表中匹配对应的处理器，然后将请求交给处理器处理；</li>
</ol>
<p>这样做在连接数比较少的时候是没什么问题的，但是在连接数非常多的时候，每个连接都会创建一个 Goroutine 就会给系统带来一定的压力。</p>
<p>这也就造成了 <code>net/http</code>在处理高并发时的瓶颈。</p>
<p><code>fasthttp</code> : </p>
<p><img src="/go.assets/image-20210616205711264.png" alt="image-20210616205711264"></p>
<ol>
<li>启动监听；</li>
<li>循环监听端口获取连接；</li>
<li>获取到连接之后首先会去 ready 队列里获取 workerChan，获取不到就会去对象池获取；</li>
<li>将监听的连接传入到 workerChan 的 channel 中；</li>
<li>workerChan 有一个 Goroutine 一直循环获取 channel 中的数据，获取到之后就会对请求进行处理然后返回。</li>
</ol>
<p>实现方法: (类似于协程池)</p>
<ul>
<li>workerChan 其实就是一个连接处理对象，这个对象里面有一个 channel 用来传递连接；</li>
<li>每个 workerChan 在后台都会有一个 Goroutine 循环获取 channel 中的连接，然后进行处理。</li>
<li>如果没有设置最大同时连接处理数的话，默认是 <code>256 * 1024</code>个。</li>
<li>这样可以在并发很高的时候还可以同时保证对外提供服务。</li>
</ul>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/574">fasthttp：比net/http快十倍的Go框架(server 篇)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/561">一文说透 Go 语言 HTTP 标准库</a> </p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p><a target="_blank" rel="noopener" href="https://www.flysnow.org/2021/02/28/golang-embed-for-web.html">embed</a>：1.16 新增的embed在各流行Web框架中的应用</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1362784031968149504&amp;__biz=MzI3MjU4Njk3Ng==#wechat_redirect">Gin实战</a>：Go 语言如何玩转 RESTful API 服务？？</p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484393&amp;idx=1&amp;sn=4a27e735672c820ac266484333a806b7&amp;chksm=eb310266dc468b7081405477779b75d2b565ec8255143338f6b037f1725f91a7a468b890f7b1&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">Restful API</a> ：<code>net/http</code>请求的URL需要一个个去注册，Gin提供了URL路由的<strong>模糊匹配</strong>，比如URL路径中的参数</p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484397&amp;idx=1&amp;sn=05d25b404f117cca76dd2097d3befab3&amp;chksm=eb310262dc468b74724a03d345e9b3ef21b39a38682836f4b00683d7b04fc7264a41649d6a0e&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">路由参数</a>：<code>/users/id</code> 通过这个<code>id</code>参数，获取对应的用户信息</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
    r := gin.Default()
    r.GET("/users/:id", func(c *gin.Context) {
        id := c.Param("id")
        c.String(200, "The user id is  %s", id)
    })
    r.Run(":8080")
}
// 输入 http://localhost:8080/users/123
// The user id is  123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">Pattern: /users/:id

/users/123          匹配
/users/哈哈        匹配
/users/123/go      不匹配
/users/             不匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-go" data-language="go"><code class="language-go">Pattern: /users/*id

/users/123         匹配
/users/哈哈        匹配
/users/123/go      匹配
/users/            匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484116&amp;idx=1&amp;sn=8abf9049e47386d503d7b653541cce16&amp;chksm=eb31035bdc468a4d75b42d2f3ad82154b88665aeb46b083f466499942bb41f3483117edc1e24&amp;scene=21#wechat_redirect">HTTP路由httprouter</a>：自定义路由</p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484405&amp;idx=1&amp;sn=39eead58bac34c9b93e37f0832537e53&amp;chksm=eb31027adc468b6c9f6a8df901fc45dca2c2ad1d528e6c93a6193e15c6e8df322c72a4cdc811&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">URL查询参数的获取和原理分析</a>：Gin获取查询参数 <code>Query</code>源码分析 </p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484410&amp;idx=1&amp;sn=807f89e1d6ba0f96558a66b82b08358b&amp;chksm=eb310275dc468b63fd5f94a772413edb0c223f0bae213055f14494dc0ff76e99a66b98ffe3ac&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">接收数组和 Map</a>：<code>QueryArray</code>  / <code>QueryMap</code> </p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484425&amp;idx=1&amp;sn=2a604e79d19c091410291d690d308dd5&amp;chksm=eb310586dc468c90eb0de31503ca6c2da9fa2b29ccb22eb5f3e37ed26d3b9a60fdbc7d6fba59&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">获取Form表单参数</a>：</p>
<table>
<thead>
<tr>
<th align="left">查询参数</th>
<th align="left">Form表单</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Query</td>
<td align="left">PostForm</td>
<td align="left">获取key对应的值，不存在为空字符串</td>
</tr>
<tr>
<td align="left">GetQuery</td>
<td align="left">GetPostForm</td>
<td align="left">多返回一个key是否存在的结果</td>
</tr>
<tr>
<td align="left">QueryArray</td>
<td align="left">PostFormArray</td>
<td align="left">获取key对应的数组，不存在返回一个空数组</td>
</tr>
<tr>
<td align="left">GetQueryArray</td>
<td align="left">GetPostFormArray</td>
<td align="left">多返回一个key是否存在的结果</td>
</tr>
<tr>
<td align="left">QueryMap</td>
<td align="left">PostFormMap</td>
<td align="left">获取key对应的map，不存在返回空map</td>
</tr>
<tr>
<td align="left">GetQueryMap</td>
<td align="left">GetPostFormMap</td>
<td align="left">多返回一个key是否存在的结果</td>
</tr>
<tr>
<td align="left">DefaultQuery</td>
<td align="left">DefaultPostForm</td>
<td align="left">key不存在的话，可以指定返回的默认值</td>
</tr>
</tbody></table>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484434&amp;idx=1&amp;sn=0bd93e3ab59e4bf5f9ed2a965395647e&amp;chksm=eb31059ddc468c8b4bd003f680aaacf9a7cf2e9d539a5e20a7e4dca97e53cf1bf3d323aac923&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">分组路由源代码分析</a>：路由中间件 / 分组路由嵌套</p>
<h2 id="优雅重启"><a href="#优雅重启" class="headerlink" title="优雅重启"></a>优雅重启</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/yryqf8SCzvt-BFj8j5bZ2w">一文讲懂服务的优雅重启和更新</a> </p>
<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GracefulStopOfGo-zero.png" style="zoom:67%;">





<h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>编译Proto文件，并生成语句：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">protoc --go_out=plugins=grpc:. ./proto/*.proto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>











<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://golang2.eddycjy.com/posts/ch3/03-simple-grpc/">gRPC 的使用和了解</a> </p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6887388610367553549">gRPC服务注册发现及负载均衡的实现方案与源码解析</a> ：<code>Resolver</code> / <code>Balancer</code> / <code>RoundRobin</code> </p>
<h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Go scheduler 的主要功能是：针对在处理器上运行的 <code>OS线程</code> <em>分发可运行</em> 的 Goroutine</p>
<p>而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L404">G</a>：Goroutine，实际上我们每次调用 go func 就是生成了一个 G。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L486">M</a>：Machine，OS线程。它由操作系统的“调度器” 调度和管理。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L576">P</a>：Processor，处理器。一般 P 的数量就是处理器的核数，可以通过 GOMAXPROCS 进行修改。</p>
<p>这三者交互实际来源于 Go 的 <a target="_blank" rel="noopener" href="https://golang.design/go-questions/sched/mn-model/">M:N调度模型</a>。</p>
<p>也就是 M 必须与 P 进行绑定，一一对应，然后不断地在 M 上循环寻找 N (可运行的 G ) 来执行相应的任务。</p>
<h3 id="三足鼎力"><a href="#三足鼎力" class="headerlink" title="三足鼎力"></a>三足鼎力</h3><p>GPM 三足鼎力，共同成就 Go scheduler。G 需要在 M 上才能运行，M 依赖 P 提供的资源，P 则持有待运行的 G。</p>
<p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/GMP_WorkFlow_magic.png" alt="GMP_WorkFlow_magic"></p>
<ol>
<li>当我们执行 go func() 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。</li>
<li>新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。需要注意的一点，这里的 P 指的是创建 G 的 P。</li>
<li>唤醒或创建 M 以便执行 G。</li>
<li>不断地进行事件循环</li>
<li>寻找在可用状态下的 G 进行执行任务</li>
<li>清除后，重新进入事件循环</li>
</ol>
<p>在描述中有提到<code>全局</code>和<code>本地</code>这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 <strong>256</strong> 个。</p>
<p>并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的 <em>本地队列的一半</em> 的 G 移动到全局队列。</p>
<p>这可以理解为调度资源的共享和再平衡。</p>
<blockquote>
<p>调度器在调度时，会从处理器(P)的 <code>runq</code> 队列中，选择 <em>队列头</em> 的 Goroutine 放到线程 M 上执行。</p>
</blockquote>
<h3 id="窃取行为"><a href="#窃取行为" class="headerlink" title="窃取行为"></a>窃取行为</h3><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/GMP_Steal.png" alt="GMP_Steal"></p>
<p>在这个例子中，P2 在本地队列中找不到可以运行的 G，它会执行 work-stealing 调度算法，随机选择其它的处理器 P1，并从 P1 的本地队列中窃取了三个 G 到它自己的本地队列中去。</p>
<p>至此，P1、P2 都拥有了可运行的 G，P1 多余的 G 也不会被浪费，调度资源将会更加平均的在多个处理器中流转。</p>
<h3 id="GMP-amp-Thread"><a href="#GMP-amp-Thread" class="headerlink" title="GMP &amp; Thread"></a>GMP &amp; Thread</h3><ul>
<li><p>调度器通过使用与 CPU 数量相等的线程（CPU数量 == 线程数量）减少线程频繁切换的内存开销</p>
</li>
<li><p>同时，在每一个线程上，执行额外开销更低的 <code>Goroutine</code> 来，<strong>降低</strong>操作系统和硬件的负载</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/94.html">Go语言GOMAXPROCS</a>:</p>
<ul>
<li>默认情况下，四核机器会创建四个活跃的操作系统线程，<em>每一个线程都对应一个运行时中</em> 的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.m"><code>runtime.m</code></a> 结构体</li>
<li>传统逻辑中，开发者需要 <em>维护</em> <strong>线程池中线程</strong> 与 <strong>CPU核心数量</strong> 的对应关系。</li>
<li>GO中，可以在程序中使用 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a> 来改变最大的活跃线程数。</li>
<li>GOMAXPROCS 同时也是一个 _环境变量_，在应用程序启动前设置环境变量也可以起到相同的作用。</li>
</ul>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw">Goroutine 数量控制在多少合适，会影响 GC 和调度？</a> </p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GoWithMemoryLayout.png" style="zoom:67%;">



<p>对应的数据结构 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a>、<a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 和 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> </p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>golang10次内存泄漏，8次goroutine泄漏，1次是真正内存泄漏，还有1次是cgo导致的内存泄漏</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/memory_out_example.png" style="zoom:67%;">

<ul>
<li>RES：常驻内存</li>
</ul>
<h3 id="泄漏情况"><a href="#泄漏情况" class="headerlink" title="泄漏情况"></a>泄漏情况</h3><p>1、可能服务分配的内存小了</p>
<p>2、资源没有关闭：http请求返回的rsp的body，还有一些打开的文件资源等（defer关掉）</p>
<p>3、goroutine泄漏</p>
<p>4、cgo导致的内存泄漏（cgo都是<strong>单独开一个线程</strong>进行处理的，这种是runtime不能管理的）</p>
<h3 id="分析命令"><a href="#分析命令" class="headerlink" title="分析命令"></a>分析命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go tool pprof -inuse_space http://ip:amdin_port/debug/pprof/heap
# -inuse_space：当前服务使用的内存情况
# -alloc_space：指服务启动以来总共分配的内存情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http://ip:admin_port/debug/pprof/heap?debug=1
# 把当前内存分配的详情文件抓下来，本地会生成一个叫heap?debug=1的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http://ip:admin_port/debug/pprof/goroutine?debug=1
# debug=1：获取服务当前goroutine的数目和大致信息

wget http://ip:admin_port/debug/pprof/goroutine?debug=2
# debug=2：获取服务当前goroutine的详细信息
# 分别在本地生成了goroutine？debug=1和goroutine？debug=2文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 服务线程挂的子线程有多少
# -m：显示所有的线程
# -p：pid进程使用cpu的时间
# -o：该参数后是用户自定义格式
ps -mp 进程 -o THREAD,tid,time | wc -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FyHEiaa-UfyLStMKl2VFGA">golang：快来抓住让我内存泄漏的“真凶”！</a>  </p>
<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>Golang中time包有两个定时器，分别为ticker 和 timer。两者都可以实现定时功能，但各自都有自己的使用场景。</p>
<p>区别：</p>
<ul>
<li><strong>ticker</strong>定时器表示每隔一段时间就执行一次，一般可执行多次。</li>
<li><strong>timer</strong>定时器表示在一段时间后执行，默认情况下只执行一次，如果想再次执行的话，每次都需要调用 time.Reset()方法，此时效果类似ticker定时器。同时也可以调用stop()方法取消定时器</li>
<li>timer定时器比ticker定时器多一个Reset()方法，两者都有Stop()方法，表示停止定时器,底层都调用了stopTimer()函数。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39397165/article/details/108698640">timer 泄漏代码</a></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (b *BrokerImpl) broadcast(msg interface{}, subscribers []chan interface{}) {
	count := len(subscribers)
	concurrency := 1

	switch {
	case count &gt; 1000:
		concurrency = 3
	case count &gt; 100:
		concurrency = 2
	default:
		concurrency = 1
	}

	pub := func(start int) {
		for j := start; j &lt; count; j += concurrency {
			select {
			case subscribers[j] &lt;- msg:
        	 case &lt;-time.After(time.Millisecond * 5): // 泄漏
			case &lt;-b.exit:
				return
			}
		}
	}
	for i := 0; i &lt; concurrency; i++ {
		go pub(i)
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修复</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func (b *BrokerImpl) broadcast(msg interface{}, subscribers []chan interface{}) {
	count := len(subscribers)
	concurrency := 1

	switch {
	case count &gt; 1000:
		concurrency = 3
	case count &gt; 100:
		concurrency = 2
	default:
		concurrency = 1
	}

	//采用Timer 而不是使用time.After 原因：time.After会产生内存泄漏 在计时器触发之前，垃圾回收器不会回收Timer
	pub := func(start int) {
		idleDuration := 5 * time.Millisecond
		idleTimeout := time.NewTimer(idleDuration)	// **
		defer idleTimeout.Stop()				   // **
		for j := start; j &lt; count; j += concurrency {
            // **
			if !idleTimeout.Stop(){	
				select {
				case &lt;- idleTimeout.C:
				default:
				}
			}
			idleTimeout.Reset(idleDuration)  // **
			select {
			case subscribers[j] &lt;- msg:
			case &lt;-idleTimeout.C:
			case &lt;-b.exit:
				return
			}
		}
	}
	for i := 0; i &lt; concurrency; i++ {
		go pub(i)
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><a target="_blank" rel="noopener" href="https://flydk.gitbooks.io/go/content/ch8/ch8-07.html">ticker 泄漏</a> </p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>参考： <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">7.2 垃圾收集器</a> </p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/457220157-FTD/p/14703692.html">golang面向对象分析</a>：封装 / 继承 / 多态</p>
<p>封装：struct</p>
<p>继承：</p>
<ul>
<li>​匿名组合    (Pseudo is-a)</li>
<li>非匿名组合    (has-a)</li>
</ul>
<p>多态：接口</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a target="_blank" rel="noopener" href="https://gocn.vip/topics/Go488nfroE">字符串处理细节</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483777&amp;idx=1&amp;sn=d3d108abe68c282a4d291a432559f2cc&amp;scene=21#wechat_redirect">nil切片和空切片</a>：<code>数组指针地址都分别指向哪儿</code> </p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483698&amp;idx=1&amp;sn=352a5cddf20fe95f5ec26bfc9a6de64b&amp;scene=21#wechat_redirect">json包变量不加tag会怎么样</a>：<code>Marshal</code> [Struct Tag](#Struct Tag)</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485846&amp;idx=2&amp;sn=033931d22730a24128915d8498c9e3fb&amp;source=41#wechat_redirect">这样理解 Go 闭包，就不会出错了 (qq.com)</a>：将引用环境和函数结合的使用方法 / 变量什么情况下 是指针，什么情况下为值</p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483686&amp;idx=1&amp;sn=e48c51107191f02da5751a19a54f7d41&amp;chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&amp;token=2092782362&amp;lang=zh_CN&amp;scene=21#wechat_redirect">什么是内存逃逸</a>：<code>从栈逃到堆上</code> / <code>典型场景</code></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483692&amp;idx=1&amp;sn=d5d34fad7a4553e0b9d5714385b7af48&amp;chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&amp;token=961196008&amp;lang=zh_CN&amp;scene=21#wechat_redirect">怎么避免内存逃逸</a>：<code>noescape</code></p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483669&amp;idx=1&amp;sn=88f754ddabc04eb3f66ba8ac37ee1461&amp;chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&amp;token=2092782362&amp;lang=zh_CN&amp;scene=21#wechat_redirect">字符串转成byte数组</a>： <a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D">零拷贝</a>  </p>
<p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483735&amp;idx=1&amp;sn=6ab8ac319dc1857acf44c9bb9d21c7c3&amp;scene=21#wechat_redirect">对已经关闭的的chan进行读写，会怎么样</a>：<code>读：关闭前是否有值</code> / <code>写：Panic</code>  </p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483717&amp;idx=1&amp;sn=0c0385234cd70d72d424eb7097ebfe9a&amp;scene=21#wechat_redirect">对未初始化的的 chan 进行读写，会怎么样</a>：<code>都会阻塞</code></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/344834329">深度解密Go语言之sync.map - 知乎 (zhihu.com)</a>：读写map，两个map，read读 / dirty写</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3MDYwODc5Nw==&amp;mid=2247484826&amp;idx=1&amp;sn=cb882a297bf84f986168bc6d613a7b28&amp;scene=21#wechat_redirect">学了这么久GO，这篇文章让我读懂了汇编！ (qq.com)</a>：<strong>caller-save模式</strong>，一般在汇编中参数和返回值被放在调用方的栈中，因此Go弄了一个伪寄存器用于实现Go的汇编结构。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485773&amp;idx=1&amp;sn=0e03c22500f836512fb4016c2a111887&amp;source=41#wechat_redirect">盘点一下 Go语言的“黑暗角落” (qq.com)</a>：<a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%99%90%E5%88%B6">数组细节</a> / For循环迭代器变量被重用</p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/articles/23242?fr=sidebar">atomic.Value 源码解析</a>：</p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/21615.html">泛型编程</a>：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6965421491588431909">sync.Pool原理解析</a>：减少小块对象内存频繁申请（帮助在程序构建了对象池，提供对象可复用能力，本身是可伸缩且并发安全的。）</p>
<p><a target="_blank" rel="noopener" href="https://www.cyhone.com/articles/think-in-sync-pool/#:~:text=sync.Pool">深度分析 Golang sync.Pool 底层原理</a> 是 Golang,内置的对象池技术，可用于缓存临时对象，避免因频繁建立临时对象所带来的消耗以及对 GC 造成的压力。</p>
<h2 id="Go实战"><a href="#Go实战" class="headerlink" title="Go实战"></a>Go实战</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7126753651455950856">err 的优雅处理</a>: 错误是值</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/114340283">Go进程的HeapReleased上升，但是RSS不下降造成内存泄漏？ - 知乎 (zhihu.com)</a>：</p>
<p><a target="_blank" rel="noopener" href="https://pengrl.com/p/20031/">Go pprof内存指标含义备忘录 | yoko blog (pengrl.com)</a>：各种概念介绍</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OyiF57PcMQjeoGpShEgidQ">Go 的json 解析标准库竟然存在这样的陷阱？</a>：神技、版本变更兼容</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FyHEiaa-UfyLStMKl2VFGA">golang：快来抓住让我内存泄漏的“真凶”！</a> ：golang10次内存泄漏，8次goroutine泄漏，1次是真正内存泄漏，<strong>还有1次是cgo导致的内存泄漏</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://www.golangprograms.com/goroutines-and-channels-example.html">Goroutines and Channels Exercises</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PjNc7YLKT5JX_Obg2815Bg">DDD 到底是银弹还是垃圾 (qq.com)</a>：防腐层 等各种名词介绍</p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26695984">今日头条Go建千亿级微服务的实践</a>：<code>并发控制</code> / <code>超时控制</code> /</p>
<blockquote>
<p>wait：</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func makeThumbnails6(filenames &lt;-chan string) int64 {

    sizes := make(chan int64)
    var wg sync.WaitGroup // number of working goroutines

    for f := range filenames {
        wg.Add(1)

        // worker
        go func(f string) {
            defer wg.Done()
            thumb, err := thumbnail.ImageFile(f)
            if err != nil {
                log.Println(err)
                return
            }
            info, _ := os.Stat(thumb) // OK to ignore error
            sizes &lt;- info.Size()
        }(f)
    }
    // closer
    go func() {
        wg.Wait()
        close(sizes)
    }()

    var total int64
    for size := range sizes {
        total += size
    }
    return total
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   wg := sync.WaitGroup{}
	wg.Add(3)
	go func() {
		defer wg.Done()
		// do ...
	}()
	go func() {
		defer wg.Done()
		// do ...
	}()
	go func() {
		defer wg.Done()
		// do ...
	}()
	wg.Wait()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Cancle：</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
   ctx := context.Background()
	ctx, cancle := context.WithCancel(ctx)
	go Proc(ctx)
	go Proc(ctx)
	go Proc(ctx)
	// Cancel after 1s
	time.Sleep(time.Second)
	cancle()
}
func Proc(ctx context.Context) {
	for {
		select {
		case &lt;- ctx.Done():
			return
		default:
			// do ...
		}
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go">func Handle(r *http.Request)  {
	timeoutStr := r.FormValue("timeout")
	timeout, _ := strconv.Atoi(timeoutStr)
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout))
	defer cancel()
	done := make(chan struct{}, 1)
	go func() {
		RPC(ctx, ...)
		done &lt;- struct{}{}
	}()
	select {
	case &lt;- done:
		// nice ... 
	case &lt;- ctx.Done():
		// timeout
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247485030&amp;idx=1&amp;sn=6eb805b2ecbc123e984f563bde734812&amp;chksm=f904133bce739a2df5c3c800539d6d4a15e8d900b25f8ffb4ed08685a4135212f521825e96bc&amp;cur_album_id=1515516076481101825&amp;scene=190#rd">go并发中一些有趣的现象</a>：</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
 wg := sync.WaitGroup{}
 wg.Add(5)
 for i := 0; i &lt; 5; i++ {
  go func() {
   defer wg.Done()
   fmt.Println(i)
  }()
 }
 wg.Wait()
}
// 主要是变量 i 没有作为形参传入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>// 第一次输出：5 5 5 5 5</p>
<p>// 多输出几次：5 3 5 5 5</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {
 wg := sync.WaitGroup{}
 wg.Add(5)
 for i := 0; i &lt; 5; i++ {
  go func(i int) {
   defer wg.Done()
   fmt.Println(i)
  }(i)
 }
 wg.Wait()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>// 第一次输出：0 1 2 4 3</p>
<p>// 第二次输出：4 0 1 2 3</p>
<p>（输出的值都是无序且不稳定的）</p>
<p>其整个程序扭转实质上分为了多个阶段，也就是各自运行的时间线并不同，可以其拆分为：</p>
<ul>
<li>先创建：<code>for-loop</code> 循环创建 <code>goroutine</code>。</li>
<li>再调度：协程<code>goroutine</code> 开始调度执行。</li>
<li>才执行：开始执行 <code>goroutine</code> 内的输出。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://hackernoon.com/building-a-media-streaming-server-using-go-and-hls-protocol-j85h3wem">Golang HLS 构建流服务</a></p>
</blockquote>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/note/">
                                    <span class="chip bg-color">note</span>
                                </a>
                            
                                <a href="/tags/go/">
                                    <span class="chip bg-color">go</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/05/22/shell/">
                    <div class="card-image">
                        
                        <img src="/../images/shell.png" class="responsive-img" alt="shell">
                        
                        <span class="card-title">shell</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            shell笔记
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-05-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/shell/" class="post-category">
                                    shell
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/note/">
                        <span class="chip bg-color">note</span>
                    </a>
                    
                    <a href="/tags/shell/">
                        <span class="chip bg-color">shell</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2022/05/22/go/">
                    <div class="card-image">
                        
                        <img src="/../images/go.png" class="responsive-img" alt="go">
                        
                        <span class="card-title">go</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            go笔记
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-05-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/go/" class="post-category">
                                    go
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/note/">
                        <span class="chip bg-color">note</span>
                    </a>
                    
                    <a href="/tags/go/">
                        <span class="chip bg-color">go</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 凌波威步～<br />'
            + '文章作者: Nice Luo<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="7366720683"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <a href="/about" target="_blank">Nice Luo</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/MicroWiller" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:willer_personal@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/xxx" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/xxx" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/xxx" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/xxx" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1019614033" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1019614033" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/xxx" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/xxx" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/xxx" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/xxx" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
