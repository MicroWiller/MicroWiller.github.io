<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql</title>
      <link href="/2022/10/15/mysql/"/>
      <url>/2022/10/15/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="运维部署"><a href="#运维部署" class="headerlink" title="运维部署"></a>运维部署</h2><h3 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h3><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">docker run -p 12345:3306 --name mysql -v /will/mysql/conf:/etc/mysql/conf.d -v /will/mysql/logs:/logs -v /will/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-p 12345:3306：将主机的12345端口映射到docker容器的3306端口</li><li>–name mysql ：运行服务的名字</li><li>-v /will/mysql/conf:/etc/mysql/conf.d：将主机<code>/will/mysql</code>目录下的 <code>conf</code>目录，挂载到容器的<code>/etc/mysql/conf.d</code></li><li>-v /will/mysql/logs:/logs：将主机<code>/will/mysql</code>目录下的 <code>logs</code>目录，挂载到容器的<code>/logs</code>  </li><li>-v /will/mysql/data:/var/lib/mysql：将主机<code>/will/mysql</code>目录下的 <code>data</code>目录，挂载到容器的<code>/var/lib/mysql</code>  </li><li>-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码</li><li>-d mysql:5.6：后台程序运行mysql5.6</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 登录MySQLmysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec mysql服务容器ID sh -c 'exec mysqldump --all-databases -uroot -p"123456" ' &gt; /will/all-databases.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="相关路径"><a href="#相关路径" class="headerlink" title="相关路径"></a>相关路径</h3><table><thead><tr><th align="left">路径</th><th align="center">解释</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">/var/lib/mysql</td><td align="center">mysql数据库文件的存放路径</td><td align="center">/var/lib/mysql/will.test.pid</td></tr><tr><td align="left">/usr/share/mysql</td><td align="center">配置文件目录</td><td align="center">mysql.server命令及配置文件</td></tr><tr><td align="left">/usr/bin</td><td align="center">相关命令目录</td><td align="center">mysqladmin mysqldump等命令</td></tr><tr><td align="left">/etc/init.d/mysql</td><td align="center">启停相关脚本</td><td align="center"></td></tr></tbody></table><h3 id="主要配置文件"><a href="#主要配置文件" class="headerlink" title="主要配置文件"></a>主要配置文件</h3><ul><li>二进制日志：<a href="http://c.biancheng.net/view/7764.html">binlog</a> —— <a href="https://zhuanlan.zhihu.com/p/164518315">主从复制</a></li><li>错误日志：<a href="http://c.biancheng.net/view/7745.html">Error Log</a> —— 默认是关闭的，记录严重的警告和错误消息，每次启动和关闭的详细信息等</li><li>查询日志：[General Query Log(<a href="http://c.biancheng.net/view/7780.html">http://c.biancheng.net/view/7780.html</a>) —— 默认关闭，记录查询的sql语句，如果开启会减低mysql的整体性能，因为记录日志也是需要消耗系统资源的</li><li>数据文件<ol><li>frm文件，存放表结构</li><li>myd文件，存放表数据</li><li>myi文件，存放表索引</li></ol></li><li>如何配置：<ol><li>windows, my.ini文件</li><li>linux, /etx/my.cnf文件</li></ol></li></ul><h2 id="Mysql架构图"><a href="#Mysql架构图" class="headerlink" title="Mysql架构图"></a>Mysql架构图</h2><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/MysqlArchitecture.png" style="zoom:67%;"><h2 id="5-6版本查询过程"><a href="#5-6版本查询过程" class="headerlink" title="5.6版本查询过程"></a>5.6版本查询过程</h2><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_select.png" style="zoom:67%;"><p>①通过客户端/服务器通信协议与 MySQL 建立连接。</p><p>②查询缓存，这是 MySQL 的一个可优化查询的地方，如果开启了 Query Cache 且在查询缓存过程中查询到完全相同的 SQL 语句，则将查询结果直接返回给客户端；如果没有开启Query Cache 或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成解析树。</p><p>③预处理器生成新的解析树。</p><p>④查询优化器生成执行计划。</p><p>⑤查询执行引擎执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的 API 接口与底层存储引擎缓存或者物理文件的交互情况，得到查询结果，由MySQL Server 过滤后将查询结果缓存并返回给客户端。</p><p>⑤若开启了 Query Cache，这时也会将SQL 语句和结果完整地保存到 Query Cache 中，以后若有相同的 SQL 语句执行则直接返回结果。</p><blockquote><p>询缓存的利弊：任何一条对此表的更新操作都会把和这个表关联的所有查询缓存全部清空</p></blockquote><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/Innodb_framework.png" style="zoom:67%;"><h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/Innodb_keys.png" style="zoom:67%;"><h3 id="InnoDB-x2F-MyISAM"><a href="#InnoDB-x2F-MyISAM" class="headerlink" title="InnoDB/MyISAM"></a>InnoDB/MyISAM</h3><blockquote><p>Innodb 引擎中体现为聚集索引方式 （索引和数据是存放在<code>同一个文件</code>的）<br>Myisam引擎中体现为非聚集索引方式 （索引和数据是存放在<code>两个文件</code>中的）</p></blockquote><!-- ![Innodb_MyISAM](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/Innodb_MyISAM.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/Innodb_MyISAM.png" style="zoom:67%;"><p>InnoDB 表最大还可以支持 64TB，支持聚簇索引、支持压缩数据存储，支持数据加密，支持查询/索引/数据高速缓存，支持自适应hash索引、空间索引，支持热备份和恢复等，如下图所示。</p><!-- ![Innodb_MyISAM2](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/Innodb_MyISAM2.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/Innodb_MyISAM2.png" style="zoom:67%;"><!-- <img src="MySQL.assets/1606053678228.png" alt="1606053678228" style="zoom:67%;" /> --><h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show engine innodb status\G;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>详细的 InnoDB 运行态信息，分段记录的，包括内存、线程、信号、锁、事务等</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性(Atomicity)：事务的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节；undo log回滚日志保证事务的原子性</li><li>一致性(Consistency)：事务开始之前和事务结束之后，数据库的<strong>完整性限制</strong>未被破坏；列如银行转账，事务的执行不应该改变A/B两个账户的金额总和；undo log+redo log保证事务的一致性</li><li>隔离性(Isolation)：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的；锁和多版本控制就符合隔离性；锁（共享、排他）用来保证事务的隔离性</li><li>持久性(Durability)：事务完成之后，数据库将保存其所做的修改，不丢失；redo log重做日志用来保证事务的持久性</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li>读未提交：也就是一个事务还没有提交时，它做的变更就能被其他事务看到</li><li>读已提交：指的是一个事务只有提交了之后，其他事务才能看得到它的变更</li><li>可重复读：此方式为默认的隔离级别，它是指一个事务在执行过程中（从开始到结束）看到的数据都是一致的，在这个过程中未提交的变更对其他事务也是不可见的</li><li>串行化：是指对同一行记录的读、写都会添加读锁和写锁，后面访问的事务必须等前一个事务执行完成之后才能继续执行，所以这种事务的执行效率很低</li></ul><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/isolation_problam.png" alt="隔离级别，与可能产生的问题"></p><h2 id="ARIES三原则"><a href="#ARIES三原则" class="headerlink" title="ARIES三原则"></a>ARIES三原则</h2><p>ARIES三原则，是指 <strong>Write Ahead Logging</strong>（WAL）</p><ol><li><p>先写日志后写磁盘，日志成功写入后事务就不会丢失，后续由 <a href="https://zhuanlan.zhihu.com/p/439121577">checkpoint机制</a>来保证 <em>磁盘物理文件</em> 与<a href="https://www.cnblogs.com/hapjin/archive/2019/09/28/11521506.html">Redo日志</a>达到一致性；</p></li><li><p>利用 <code>Redo</code> 记录变更后的数据，即 <code>Redo</code> 记录事务数据<strong>变更后</strong>的值；</p></li><li><p>利用 <code>Undo</code> 记录变更前的数据，即 <code>Undo</code> 记录事务数据<strong>变更前</strong>的值，用于回滚和其他事务多版本读。</p></li></ol><h2 id="多版本控制-MVCC"><a href="#多版本控制-MVCC" class="headerlink" title="多版本控制-MVCC"></a>多版本控制-MVCC</h2><p>多版本控制也叫作 MVCC，是指在数据库中，为了实现高并发的数据访问，<em>对数据进行多版本处理</em>，并通过<strong>事务的可见性</strong>来保证事务能看到<strong>自己应该</strong>看到的数据版本。</p><blockquote><p>那个多版本是如何生成的呢？</p></blockquote><ol><li><p>每一次对数据库的修改，都会在 <code>Undo</code> 日志中, 记录当前修改记录的事务号, 以及修改前数据状态的存储地址（即 ROLL_PTR），以便在必要的时候可以回滚到老的数据版本。</p></li><li><p>例如，一个读事务查询到当前记录，<em>而最新的写事务还未提交</em>；</p></li><li><p>根据原子性，读事务看不到最新数据，但可以去<strong>回滚段</strong>中找到老版本的数据，这样就生成了多个版本。</p></li></ol><p>多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。</p><h2 id="SQL分析"><a href="#SQL分析" class="headerlink" title="SQL分析"></a>SQL分析</h2><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><p>手写:</p><!-- ![select_template](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/select_template.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/select_template.png" style="zoom:67%;"><p>机读:</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/select_analysis.png" style="zoom:67%;"><!-- ![select_analysis](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/select_analysis.png) --><p>解析：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/sql_analysis.png" style="zoom:67%;"></p><!-- ![sql_analysis](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/sql_analysis.png) --><ol><li><code>select</code>的字段只能是<strong>分组的字段类别</strong>以及使用<strong>聚合函数</strong>如，max(),min(),count()的字段；</li><li><code>group by</code>，即以其中一个字段的值来分组；</li><li><code>where</code>在前，group by在后；注意<code>group by</code>紧跟在 <code>where</code> 最后一个限制条件后面<ul><li>不能被夹在<code>where</code>限制条件之间的原因：要先用<code>where</code>过滤掉不进行分组的数据，然后在对剩下满足条件的数据进行分组</li></ul></li><li><code>having</code>是在分好组后，找出特定的分组，通常是以筛选聚合函数的结果<ul><li>如<code>sum(a) &gt; 100</code>等</li><li>且<code>having</code>必须在<code>group by</code>后面</li><li>使用了<code>having</code>必须使用<code>group by</code>，但是使用<code>group by</code> 不一定使用<code>having</code></li></ul></li><li>不允许用双重聚合函数，所以在对分组进行筛选的时候可以用<code>order by</code> 排序，然后用<code>limit</code>也可以找到极值</li></ol><h3 id="Join查询"><a href="#Join查询" class="headerlink" title="Join查询"></a>Join查询</h3><!-- ![sql_joins](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/sql_joins.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/sql_joins.png" style="zoom:67%;"><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT * FROM TableA A INNER JOIN TableB B ON A.Key=B.Key;    // 内连接SELECT * FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key;    // 左连接SELECT * FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key;    // 右连接SELECT * FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key WHERE B.Key IS NULL;SELECT * FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL;SELECT * FROM TableA A FULL OUTER JOIN TableB B ON A.Key=B.Key;    // 全连接 (MySQL 不支持)SELECT * FROM TableA A FULL OUTER JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL OR B.Key IS NULL;// 联合unionSELECT * FROM TableA A LEFT JOIN TableB B ON A.Key=B.KeyunionSELECT * FROM TableB B RIGHT JOIN TableB B ON A.Key=B.Key;// 去重unionSELECT * FROM TableA A LEFT JOIN TableB B ON A.Key=B.Key WHERE B.Key IS NULLunionSELECT * FROM TableA A RIGHT JOIN TableB B ON A.Key=B.Key WHERE A.Key IS NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>联合union：</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/unite_union.png" style="zoom:67%;"><p>去重union：</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/rm_union.png" style="zoom:67%;"><h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>起因：数据库存数据，SQL取数据，设计一个<code>可以快速查找的数据结构</code>，<em>减少磁盘的IO操作，提升性能</em></p><p>索引是一种数据结构，目的在于提高查找效率，可以类比字典。</p><p>可以简单理解为：排好序的，可以快速查找的，数据结构。</p><blockquote><p>索引, 会影响到 <code>where</code>后的查找 和 <code>order by</code> 后面的排序</p></blockquote><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/select_index_struct.png" style="zoom:67%;"><ol><li>如上图所示，左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。</li><li>为了加快Co12的查找，可以维护一个右边所示的二叉查找树;</li><li>每个节点分别包含<code>索引键值</code>, 和一个指向对应数据记录物理地址的指针;</li><li>这样就可以运用二叉查找，在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</li></ol><blockquote><p>索引有成本：增删改慢，除了updata数据，还要改变索引的指向，索引重建有一定成本</p></blockquote><h3 id="优势-x2F-劣势"><a href="#优势-x2F-劣势" class="headerlink" title="优势/劣势"></a>优势/劣势</h3><p>优势：</p><ul><li>类似大学图书馆的书目索引，提高<strong>数据检索</strong>的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低<strong>数据排序</strong>的成本，降低CPU的消耗</li></ul><p>劣势：</p><ul><li>实际上索引也是一张<code>表</code>，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是<strong>要占空间</strong>的</li><li>虽然索引大大提高了查询速度，但同时会<strong>降低更新表的速度</strong>，如对表进行INSERT/UPDATE/DELETE</li><li>更新表时，MYSQL<strong>不仅要保存数据</strong>，<strong>还要保存</strong>索引文件，每次更新，都需要添加索引列的字段</li><li>都会调整，因为更新所带来的键值变化后的索引信息</li></ul><blockquote><p>索引只是提高查询速度的一个因素</p><p>如果MySQL有大数据量的表，就需要花时间建立最优秀的索引，或者优化查询语句</p></blockquote><h3 id="mysql索引分类"><a href="#mysql索引分类" class="headerlink" title="mysql索引分类"></a>mysql索引分类</h3><ul><li><code>单值索引</code>：即一个索引只包含单个列，一个表可以有多个单值索引</li><li><code>唯一索引</code>：索引列的值，必须唯一，但允许有空值</li><li><code>复合索引</code>：即一个索引包含多个列</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 创建CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length));# 删除DROP INDEX [indexName] ON mytable;# 查看SHOW INDEX FROM tableName\G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 添加数据表的四种方式:ALTER TABLE mytable ADD PRIMARY KEY (column_list);# 添加主键，索引值必须是唯一的，且不能为nullALTER TABLE mytable ADD UNIQUE index_name (column_list); # 添加唯一索引，索引值也必须是唯一的，可以为null，可能会出现多次ALTER TABLE mytable ADD INDEX index_name (column_list);# 添加普通索引，索引值可以出现多次ALTER TABLE mytable ADD FULLTEXT index_name (column_list);# 添加全文索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一张表的索引数量，最多不要超过5个，不然适得其反</p></blockquote><h3 id="联合索引-x2F-覆盖索引"><a href="#联合索引-x2F-覆盖索引" class="headerlink" title="联合索引/覆盖索引"></a>联合索引/覆盖索引</h3><p>根据<strong>索引列个数</strong>和<strong>功能描述</strong>不同索引也可以分为：<code>联合索引</code>和<code>覆盖索引</code></p><ul><li><p>联合索引，是指在多个字段联合组建索引的；当被定义为主键时，也可叫复合主键。</p></li><li><p>覆盖索引，是指一类通过<code>索引</code> <em>就可以查询到所有记录</em>，<strong>不需要</strong><code>回表</code>到<code>聚簇索引</code>的特殊索引。</p></li></ul><blockquote><p>回表查询：如果 SQL 需要查询<code>辅助索引</code>中 <em>不包含</em> 的数据列时; 就需要先通过<code>辅助索引</code> 查找到主键值，然后<em>再回表</em>, 通过<code>主键</code>查询到其他数据列</p></blockquote><p><code>区别和联系</code>：主键查询是天然的覆盖索引，联合索引可以是覆盖索引</p><p><code>补充</code>：<a href="https://www.jianshu.com/p/8625b3b639b3">联合主键与复合主键区别</a>, 联合主键体现在多个表上，复合主键体现在一个表中的多个字段。</p><h3 id="为什么是B-树"><a href="#为什么是B-树" class="headerlink" title="为什么是B+树"></a>为什么是B+树</h3><p>什么样的数据结构，满足索引的目的：</p><ul><li>hash：不支持 <em>部分索引查询</em> 和 <em>范围查询</em>，</li><li>红黑树：<ol><li><em>读取磁盘的次数过多</em>，并且读取一页[16K]的绝大部分内容都没有用，很浪费</li><li>那为什么又可以用在HashMap的查找里面？？纯内存读取很快</li></ol></li><li>N叉树<ol><li>层级太多</li><li>不过因为空间连续，读取一页[16K]的绝大部分内容都用上</li></ol></li></ul><blockquote><p>B树： 基于二叉查找树（二叉排序树），即<code>N叉排序树</code>【B-Tree、B+Tree、B*Tree】</p></blockquote><p>M阶的Btree的几个重要特性：</p><ol><li>节点最多含有<code>m</code>颗子树(指针)，<code>m-1</code>个关键字 (m&gt;=2)</li><li>除根节点和叶子节点外，其他每个节点至少还有 <code>ceil(m / 2)</code> 个子节点（ceil为向上取整）</li><li>若根节点不是叶子节点，则至少有两颗子树</li></ol><!-- `分裂：` 当不满足以上性质时发生【红黑树，变颜色左旋右旋】- 同一磁盘块中，关键字的插入，使用插入排序- 分裂的时候，从中间[m/2] 分开，分成两棵子树- <img src="MySQL.assets/image-20200430234706659.png" alt="image-20200430234706659" style="zoom:50%;" />  **为什么不继续用B-Tree做索引：**1. 范围查找索引失效2. 空间开销大，除了数据本身 还得存数据的内存空间![image-20200501225255835](MySQL.assets/image-20200501225255835.png) --><p>二叉查找树，红黑树， B-Iree，BtTree 的区别：</p><ol><li>二叉搜索树：优点查找快，但是在某些情况下会退化成链表，它是所有高效查找树的基础。</li><li>红黑树：内存查找高效树，不适合大数据量，也不适合磁盘存储的。具体问题，是因为树的深度会很大，会造成<code>I0浪费</code>以及<code>读取资源浪费</code>；适合一些底层系统做内存运算，如epoll和Java中的hashMap。</li><li>B-Tree：可以认为是B+Tree的过度。</li><li>B+Tree：最适合大数据的磁盘索引，mysql的<em>所有数据都存在叶子节点</em>。其他都是索引，增加了系统的稳定性以及遍历查找效率。</li></ol><p>N阶：这个由磁盘的页面大小决定，<strong>磁盘块</strong>和<strong>页内存</strong>都是<code>4KB</code>。我们的节点数，也就是M值 应该要尽可能的一样。这样的好处就是，我们能一次刚好全部拿出一个节点里面存的所有数据。</p><blockquote><p>真实的情况是，3层的b+树可以表示，上百万的数据，只需要三次IO</p></blockquote><p><a href="https://mp.weixin.qq.com/s/GHLbBd9rJsNmhAjNHcB5xA">详细解析</a></p><h3 id="哪些情况不要建索引"><a href="#哪些情况不要建索引" class="headerlink" title="哪些情况不要建索引"></a>哪些情况不要建索引</h3><ol><li>表记录太少，300万以上建</li><li>经常<strong>增删改</strong>的表，索引在提高查询速度的同时，会降低更新表的速度</li><li>数据<strong>包含许多重复</strong>且<strong>分布均匀</strong>的表字段，建索引没有太大的实际效果</li></ol><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="常见优化方案"><a href="#常见优化方案" class="headerlink" title="常见优化方案"></a>常见优化方案</h3><ul><li>SQL和索引优化</li><li>数据库结构优化</li><li>系统硬件优化</li></ul><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1777">优化方案参考</a></p><p>MySQL常见瓶颈:</p><ol><li>CPU： CPU在饱和的时候, 一般发生在 <em>数据装入内存</em> 或 <em>从磁盘上读取数据</em> 时候</li><li>IO：磁盘I/0瓶颈, 发生在<code>装入数据</code> <em>远大于</em> <code>内存容量</code>的时候</li><li>服务器硬件的性能瓶颈：top, free, iostat和vmstat来查看系统的性能状态</li></ol><h3 id="Query-Optimizer"><a href="#Query-Optimizer" class="headerlink" title="Query Optimizer"></a>Query Optimizer</h3><p>MySql中有专门负责优化Select语句的优化器模块，<code>MySQL Query Optimizer</code>，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划。</p><p>但是，它认为最优的数据检索方式，不见得是DBA认为最优的，这部分最耗时间过程：</p><ol><li>当客户端向Mysql请求一条Query，命令解析器模块完成请求分类，区别出是Select并转发给Mysql Query Optimizer</li><li>Mysql Query Optimizer 首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值；</li><li>并对Query中的查询条件进行简化和转换；如去掉一些无用或显而易见的条件、结构调整等</li><li>然后分析Query中的Hint信息(如果有)，看显示Hint信息是否可以完全确定该Query的执行计划</li><li>如果没有Hint或者Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析</li><li>然后再得出最后的执行计划</li></ol><h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><ol><li><p>可以模拟优化器执行SQL查询语句，从而知道Mysql是如何处理你的SQL语句的。</p></li><li><p>分析你的查询语句或是表结构的性能瓶颈</p></li></ol><h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以被使用</li><li>哪些索引被实际使用</li><li>表之间的关系</li><li>每张表有多少行被优化器查询</li></ul><h4 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain + sql语句;# 如：explain select * from person where uname = 'nice';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="各字段解释"><a href="#各字段解释" class="headerlink" title="各字段解释"></a>各字段解释</h4><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>选择标识符。id 越大优先级越高，就越先被执行</td><td>查询的类型</td><td>输出结果集的表</td><td>匹配的分区</td><td>表的连接类型</td><td>在查询时，可能使用的索引</td><td>实际使用的索引</td><td>索引字段的长度</td><td>列与索引的比较</td><td>大概估算的行数</td><td>按表条件过滤的行百分比</td><td>执行情况的描述和说明</td></tr></tbody></table><!-- <img src="MySQL.assets/1606035919343.png" alt="1606035919343" style="zoom:67%;" /> --><h5 id="id：表的读取顺序"><a href="#id：表的读取顺序" class="headerlink" title="id：表的读取顺序"></a>id：表的读取顺序</h5><ul><li>id 相同</li></ul><!-- ![id相同](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_explain_id.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_explain_id.png" style="zoom:67%;"><p>执行顺序由上至下<br> <!-- ![](MySQL.assets/20200210202224211_17083.png ) --></p><ul><li>id 不同<!-- ![id不同](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_explain_id2.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_explain_id2.png" style="zoom:67%;"></li></ul><p>如果是子查询，id的序列化会递增，id值越大优先级越高，越先被执行</p><!-- ![](MySQL.assets/20200210203001434_23912.png ) --><ul><li>id相同和不同，同时存在<!-- ![id相同和不同](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_explain_id3.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/mysql_explain_id3.png" style="zoom:67%;"></li></ul><ol><li>id如果相同，可以认为是一组，从上往下顺序执行；</li><li>在所有组中，id值越大，优先级越高，越先执行。<!-- ![](MySQL.assets/20200210203421536_4737.png ) --></li></ol><h5 id="select-type：读取数据的操作类型"><a href="#select-type：读取数据的操作类型" class="headerlink" title="select_type：读取数据的操作类型"></a>select_type：读取数据的操作类型</h5><ol><li>SIMPLE: 简单的 select 查询,查询中不包含子查询或者UNION</li><li>PRIMARY: 查询中若包含任何复杂的子部分，最外层查询则被标记为</li><li>SUBQUERY: 在SELECT或WHERE列表中包含了子查询</li><li>DERTVED: 在FROM列表中包含的子查询被标记为DERIVED（衍生），MysQL会递归执行这些子查询，把结果放在临时表里。</li><li>UNION: 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标设为：DERIVED</li><li>UNION RESULT: 从UNION表获取结果的SELECT<!-- ![](MySQL.assets/20200210203722429_23559.png ) --><!-- ![](MySQL.assets/20200210203905730_7287.png ) --></li></ol><h5 id="table：显示这一行的数据是关于哪张表的"><a href="#table：显示这一行的数据是关于哪张表的" class="headerlink" title="table：显示这一行的数据是关于哪张表的"></a>table：显示这一行的数据是关于哪张表的</h5><h5 id="type：访问类型"><a href="#type：访问类型" class="headerlink" title="type：访问类型"></a>type：访问类型</h5><p>访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p><blockquote><p>一 般来说，得保证查询至少达到range级别，最好能达到ref。</p></blockquote><!-- ![](MySQL.assets/20200210210644944_17600.png ) --><ul><li>system：表只有一行记录（等于系统表），这是const类型的特列，平吋不会出现，这个可以忽路不计。</li><li>const：表示通过素引一次就找到了。const 用于比较 <code>primary key</code>或者<code>unique</code>素引。因为只匹配一行数据，所以很快。如：将主键置于where列表中，MysQL就能将该查询转换为一个常量。</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之几配，常见于主键或唯一索孔扫描。</li><li>ref：非唯一性索引扫描，返回匹配单个单独值的所有行。木质上也是一种素引访问，它返回所有匹配某个单独值的行；然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在你的where语句中出现了between、＜、＞、in等的查询；这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li><li>index：Full Index Scan, index与ALL区别为index类型只遍历<strong>索引树</strong>。这通常比ALL快，因为索引文件通常比数据文件小。也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的。</li><li>all：Full Table Scan，将通历全表以找到匹配的行，速度最慢。</li></ul><!-- ![](MySQL.assets/20200211143318011_29688.png ) --><h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引，一个或者多个</p><p>查询涉及到的字段上，若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong></p><h5 id="key：实际使用的索引"><a href="#key：实际使用的索引" class="headerlink" title="key：实际使用的索引"></a>key：实际使用的索引</h5><p>实际使用到的索引；如果为null，则没有使用索引</p><p>查询中，若使用了覆盖索引，则该索引和查询的select字段重叠</p><!-- ![](MySQL.assets/20200210214559813_32618.png ) --><!-- ![cover_index](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/cover_index.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/cover_index.png" style="zoom:67%;"><h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>表示<strong>索引中使用到的字节数</strong>，可通过该列计算 查询中使用到的索引的长度</p><p>在不损失精确度的情况下，长度<strong>越短越好</strong> </p><p>key_len显示的值为索引字段的最大可能长度，<strong>并非实际使用长度</strong>， 即key_len是根据<strong>表定义</strong>计算而得，不是通过表内检索出的</p><p>耗费得越多，精度越高：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/key_len_example.png" style="zoom:67%;"></p><!-- ![key_len_example](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/key_len_example.png) --><!-- ![](MySQL.assets/20200210215530575_20868.png ) --><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示<code>索引的哪一列(字段)</code>被使用了</p><p>如果可能的话，是一个常数(constant)；哪些列或常量被用于查找索引列上的值<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/ref_index.png" style="zoom:67%;"></p><!-- ![ref_index](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/ref_index.png) --><!-- ![](MySQL.assets/20200211143522061_5752.png) --><h5 id="rows：越少越好"><a href="#rows：越少越好" class="headerlink" title="rows：越少越好"></a>rows：越少越好</h5><p>每张表<strong>有多少行</strong>被优化器查询</p><p>根据表统计信息及索引选用情况，大致估算出，找到所需的记录所需要读取的行数<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/rows_index.png" style="zoom:67%;"></p><!-- ![rows_index](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/rows_index.png) --><!-- ![](MySQL.assets/20200211144715122_25420.png ) --><h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>不适合在其他列显示，但十分重要的额外信息</p><ul><li><p>Using filesort：又排了次序(折腾)，文件内排序</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/filesort_extra.png" style="zoom:67%;"><!-- ![filesort_extra](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/filesort_extra.png) --><!-- <img src="MySQL.assets/20200211150821977_31227.png" style="zoom:60%;" /> --></li><li><p>Using temporary：新建了一个内部临时表</p><!-- <img src="MySQL.assets/20200211152320077_14118.png" style="zoom:60%;" /> --><!-- ![temporary_extra](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/temporary_extra.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/temporary_extra.png" style="zoom:67%;"></li></ul><blockquote><p>order by / group by 一定要和 <code>索引的个数、顺序</code><strong>按需来</strong></p></blockquote><ul><li><p>USING index：相应的select操作中使用了 <code>覆盖索引</code> 避免了访问表的数据行</p><!-- <img src="MySQL.assets/20200211153935041_29579.png" style="zoom:60%;" /> --><!-- ![using_index](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/using_index.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/using_index.png" style="zoom:67%;"></li><li><p>Using where：表明使用了where过滤</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/using_where.png" style="zoom:67%;"><!-- ![using_where](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/using_where.png) --></li><li><p>using join buffer：使用了连接缓存</p></li><li><p>impossible where：where子句的值总是false，不能用来获取任何元素</p><!-- ![](MySQL.assets/20200211154610986_21330.png ) --><!-- ![impossibale_where](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/impossibale_where.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/impossibale_where.png" style="zoom:67%;"></li><li><p>select tables optimized away：在没有groupBY子句的情况下，对索引优化做的操作</p></li><li><p>distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</p></li></ul><h5 id="热身case"><a href="#热身case" class="headerlink" title="热身case"></a>热身case</h5><p>bug：SQL语句不全</p><!-- ![](MySQL.assets/20200211155447224_4563.png ) --><!-- ![case1](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/case1.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/case1.png" style="zoom:67%;"><!-- ![](MySQL.assets/20200211155719718_1361.png ) --><ul><li>第一行（执行顺序4）：id列为1，表示是union里的第一个select, select_type列的primary表示该查询为外层查询，table列被标<br>记为<derived3>，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……1】</derived3></li><li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name<br>from t1 where other column=’’】</li><li>第三行（执行顺序3）：select列表中的子查询select_type 为subquery，为整个查询中的第二个select.【select id from t3】</li><li>第四行（执行顺序1）：select type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li><li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行<br>union操作。【两个结果union操作】</li></ul><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/one_table.png" style="zoom:47%;"><!-- ![one_table](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/one_table.png) --><!-- ![](_v_images/20200211164234852_19905.png =700x) --><blockquote><p>from 前面的 字段(column) 最好是等于常量，<em>不要范围</em></p></blockquote><p>如果实在避免不了，使用下面方法：</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_range_index.png" style="zoom:47%;"><!-- ![](_v_images/20200211165648365_14988.png =900x) --><!-- ![no_range_index](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_range_index.png) --><h4 id="两表"><a href="#两表" class="headerlink" title="两表"></a>两表</h4><!-- ![](_v_images/20200211172835729_20464.png =800x) --><!-- ![add_index_left](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/add_index_left.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/add_index_left.png" style="zoom:47%;"><ul><li><code>左连接，右索引</code>（右表搜索行，左边一定都有）</li><li><code>右连接，左索引</code></li></ul><h4 id="三表"><a href="#三表" class="headerlink" title="三表"></a>三表</h4><pre class="line-numbers language-mysal" data-language="mysal"><code class="language-mysal">ALTER TABLE 'phone' ADD INDEX z ( 'card*);ALTER TABLE 'book' ADD INDEX Y ('card');EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card=book.card LEFT JOIN phone ON book.card= phone.card;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Join语句的优化：</p><ul><li>尽可能减少Join语句中的NestedLoop的循环总次数：“永远用小结果集，驱动大的结果集”</li><li>优先优化NestedLoop的内园循环</li><li>保证Join语句中被驱动表上，Join条件字段 已经被索引</li></ul><!-- ![](_v_images/20200211182903018_4929.png =900x) --><!-- ![](_v_images/20200211183907016_14454.png =800x) --><p>当<code>无法保证</code> 被驱动表的 join条件字段被索引，且内存资源充足的条件下，不要太吝啬JoinBuffer的设置</p><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><!-- ![](_v_images/20200211201854783_10970.png =800x) --><p>口诀：</p><ol><li>全值匹配我最爱</li><li>最佳左前缀法则</li><li>不在索引列上做任何操作（计算、两数、（自动or手动)类型转换），会导致索引失效而转向全表扫描</li><li>Mysql存储引擎，不能使用索引中范围条件右边的列【1/2/3楼，2是范園，3就不能使用】</li><li>尽量使用覆盖索引 (只访问索引的查询(索引列和查询列一致)），减少select *</li><li>mysql 在使用不等于（!= 或者 &lt; &gt;）的时候无法使用索引，会导致全表扫描</li><li>is null ,is not null 也无法使用索引</li><li>like以通配符开头（%abc.），mysql索引失效 会变成全表扫描的操作</li><li>字符串不加单引号索引失效</li><li>少用or,用它来连接时会索引失效</li></ol><p>索引多列，要遵守<em>最左前缀法则</em>：<br>查询从索引的<code>最左前列</code>开始 并且<code>不跳过索引中的列</code><br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/most_left_rule.png" style="zoom:47%;"></p><!-- ![most_left_rule](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/most_left_rule.png) --><!-- ![](_v_images/20200211200555547_24326.png =500x) --><p>索引列上操作导致失效：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_op.png" style="zoom:47%;"></p><!-- ![no_work_4_op](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_op.png) --><!-- ![](_v_images/20200211201435660_16046.png =700x) --><p>范围查询导致索引失效：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_range.png" style="zoom:47%;"></p><!-- ![no_work_4_range](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_range.png) --><!-- ![](_v_images/20200211203001753_1675.png =800x) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_range2.png" style="zoom:47%;"><!-- ![no_work_4_range2](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_range2.png) --><!-- ![](_v_images/20200211203046694_2571.png =600x) --><p>使用覆盖索引，<code>减少select*</code>：</p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/reduce_select_all.png" style="zoom:47%;"><!-- ![reduce_select_all](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/reduce_select_all.png) --><!-- ![](_v_images/20200211210938194_24113.png =700x) --><p>!= 或者 &lt; 、&gt;，导致失效：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_no.png" style="zoom:47%;"></p><!-- ![no_work_4_no](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_no.png) --><!-- ![](_v_images/20200211211406786_28312.png =700x) --><p>is null ,is not null：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_woork_4_null.png" style="zoom:47%;"></p><!-- ![no_woork_4_null](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_woork_4_null.png) --><!-- ![](_v_images/20200211211749955_15083.png =700x) --><p>like时，% 加右边：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/like_pos.png" style="zoom:47%;"></p><!-- ![like_pos](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/like_pos.png) --><!-- ![](_v_images/20200211212251112_13407.png =700x) --><p>覆盖索引来解决</p><p>varchar类型绝对<code>不能失去单引号</code>：</p><!-- ![](_v_images/20200211214450574_8206.png =700x) --><!-- ![no_work_4_varchar](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_varchar.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_varchar.png" style="zoom:47%;"><ul><li>隐式的类型转换，全表扫描</li><li>在转换规则中，这里的情况属于其他，两个比较值都会被转换成浮点型</li><li>即表里面对应的字段值也会被转换，所以这里走的是全表扫面</li></ul><p>or：</p><!-- ![](_v_images/20200211214758353_6258.png =600x) --><!-- ![no_work_4_or](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_or.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/no_work_4_or.png" style="zoom:47%;"><h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index inx_test03_c1234 on test03(c1,c2,c3,c4);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常量级别，顺序无关：</p><!-- ![](_v_images/20200212095703446_20072.png =800x) --><!-- ![constant_level](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/constant_level.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/constant_level.png" style="zoom:47%;"><p>范围后失效：</p><!-- ![](_v_images/20200212101123420_11963.png =800x)![range_type](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/range_type.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/range_type.png" style="zoom:47%;"><p>order by：</p><!-- ![](_v_images/20200212102221930_19708.png =800x)![ref_order_by](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/ref_order_by.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/ref_order_by.png" style="zoom:47%;"><p>索引使用和 联合索引键的顺序，尽量跟排序一致（<code>充分利用已有的排序</code>，<strong>避免</strong>MySQL内排序）</p><!-- ![](_v_images/20200212103341805_31945.png =800x)![order_by_and_sunxu](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_and_sunxu.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_and_sunxu.png" style="zoom:47%;"><!-- ![](_v_images/20200212104524203_19123.png =800x)![order_by_c2](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_c2.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_c2.png" style="zoom:47%;"><blockquote><p>OrderBY 只要没有跟索引的顺序一致, 基本上都会产生<code>filesort</code>，<em>除非排序字段已经是一个常量了</em></p></blockquote><!-- ![](_v_images/20200212105134296_30163.png =1000x)![group_by_bwt](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/group_by_bwt.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/group_by_bwt.png" style="zoom:47%;"><blockquote><p>GroupBy，如果和索引的顺序不一样，分组之前必排序，会有<code>临时表</code>创建<br>定值为常量，范围之后失效，最终看排序，一般 <code>OrderBy</code> 是给个范围</p></blockquote><!-- ![](_v_images/20200212105902621_9612.png =800x) --><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引，尽可能通过分析统计信息和调格query的写法来达到选择合适索引的目的</li></ul><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><!-- ![](MySQL.assets/20200212110832007_11172.png ) --><!-- ![whrere_index](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/whrere_index.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/whrere_index.png" style="zoom:47%;"><!-- ![](MySQL.assets/20200212111058887_14977.png ) --><p>【优化总结口诀】<br>全值匹配我最爱，最左前缀要遵守;<br>带头大哥不能死，中间兄弟不能断；<br>索引列上少计算，范围之后全失效；<br>LIKE百分写最右，覆盖素引不写星：<br>不等空值还有or，索引失效要少用：</p><h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><ol start="0"><li>收到监控系统报警，模拟运行环境</li><li>慢查询的开启和捕获</li><li>explain + 慢SQL分析</li><li>show profile 查询SQL 在MySQL服务器里面的执行细节和生命周期</li><li>SQL数据服务器的参数调优</li></ol><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="永远小表驱动大表"><a href="#永远小表驱动大表" class="headerlink" title="永远小表驱动大表"></a>永远小表驱动大表</h4><blockquote><p>数据库<strong>最耗费资源</strong>的是 <code>数据库连接</code></p></blockquote><p><code>in</code> 和 <code>exist</code> 的区别：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#当t_order表的数据集 小于t_user表时, 用 in 优化 exist；使用in，两表执行顺序是先查 t_order 表,再查t_user表select * from t_user where id in (select user_id from t_order)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 当t_user表的数据集小于t_order表时，用 exist 优化 in；使用 exists，两表执行顺序是先查 t_user  表,再查 t_order 表select * from t_user where exists (select 1 from B where t_order.user_id= t_user.id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>in，先往里层找</li><li>exist，先往外层找</li></ul><h4 id="OrderBy-优化"><a href="#OrderBy-优化" class="headerlink" title="OrderBy 优化"></a>OrderBy 优化</h4><ul><li>Index: 效率高，在MysQL扫描索引本身完成排序</li><li>Filesort: 方式效率较低，不按照索引的排序，数据库<strong>内部</strong>再排序一次</li></ul><!-- ![](_v_images/20200212144703052_28776.png) --><!-- ![](_v_images/20200212150838994_11693.png =800x) --><!-- ![](_v_images/20200212151104225_13825.png =800x) --><p>ORDER BY满足两情况，会使用 Index方式排序：</p><ol><li>ORDER BY语句使用索引最左前列</li><li>使用Where子句与Order BY子句条件列组合满足素引最左前列</li></ol><!-- ![](_v_images/20200212145538492_25910.png =900x) --><!-- ![order_by_exam1](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_exam1.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_exam1.png" style="zoom:47%;"><!-- ![](_v_images/20200212150335520_22692.png =900x)![order_by_exam2](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_exam2.png) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/order_by_exam2.png" style="zoom:47%;"><!-- ##### 不在索引列上，filesort有两种算法 --><!-- ![](_v_images/20200212152710488_13085.png =1000x) --><!-- ![](_v_images/20200212153259857_16825.png =900x) --><ul><li>Order by时 <code>select *</code>，是一个大忌，只Query需要的字段，这点非常重要。在这里的影响是：<ol><li>当Query的字段大小总和小于max_length_for_sort_data，而且排序宇段不是 TEXT｜BLOB 类型时，会用改进后的算法：单路排序，否则用老算法：多路排序</li><li>两种算法的数据都有可能超出 <code>sort_buffer</code> 的容量，超出之后，会创建<code>tmp文件</code>进行合并排序，导致多次IO；但是用单路排序算法的风险会更大一些，所以要提高sort buffer_ size。</li></ol></li><li>尝试提高 <code>sort_buffer_size</code>, 不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。</li><li>尝试提高 <code>max_length_for_sort_data</code>，提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出<code>sort_buffer_size</code>的概率就增大，明显症状是<strong>高磁盘IO活动</strong>和<strong>低处理器使用率</strong></li></ul><!-- ![](_v_images/20200212154436922_18322.png =600x)  --><p>实例：KEY a_b_c (a, b, c)</p><p>order by 能使用素引最左前缀：</p><ul><li>ORDER BY a</li><li>ORDER BY a,b</li><li>ORDER BY a, b, c</li><li>ORDER BY a DESC, b DESC, c DESC</li></ul><p>如果WHERE使用素引的最左前缀定义为常量，则order by能使用素引：</p><ul><li>WHERE a = const ORDER BY b, c</li><li>WHERE a = const AND b = const ORDER BY c</li><li>WHERE a = const ORDER BY b, c</li><li>WHERE a = const AND b &gt; const ORDER BY b, c</li></ul><p>不能使用素引进行排序：</p><ul><li>ORDER BY a ASC. b DESC, C DESC  【排序不一致刘】</li><li>WHERE g = const ORDER BY b, c 【丟失a索引】</li><li>WHERE a = const ORDER BY C     【丟失b索引】</li><li>WHERE a = const ORDER BY a, d 【d不是素引的一部分】</li><li>WHERE a in (…) ORDER BY b, c  【对于排序来说，多个相等条件也是范围查询】</li></ul><blockquote><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序（同升或者同降：Using Index）；</p><p>只要带头大哥在，按索引顺序 OrderBy：就不会Using filesort；</p></blockquote><h4 id="GroupBy-优化"><a href="#GroupBy-优化" class="headerlink" title="GroupBy 优化"></a>GroupBy 优化</h4><ol><li>group by 实质是，先排序后分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大max_length_for_sort_data 参数设置＋增大sort_buffer_size参数设置</li><li>where高于having，能写在where限定的条件就不要去having限定</li></ol><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">slow_query_loglong_query_time<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h4><!-- ![](_v_images/20200212164610612_8467.png =800x) --><p>MysQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</p><p>由此来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望收集超过5秒的sql，结合之前explain进行全面分析。</p><h4 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a>怎么玩</h4><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志或多或少会带来一定的性能影响。</p><p>查询日志支持将日志记录写入文件。</p><!-- ![](_v_images/20200212164753463_8295.png =800x) --><p>开启慢查询日志：</p><!-- ![slow_query_log](https://gcore.jsdelivr.net/gh/MicroWiller/photobed/slow_query_log.png) --><!-- ![](_v_images/20200212165359146_10436.png =500x) --><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/slow_query_log.png" style="zoom:47%;"><!-- ![](_v_images/20200212165651132_19359.png =800x) --><p>如果要永久生效，就必须修改配置文件my.cnf（其他系统变量也是如此）<br>slow_query_log =1<br>slow_query_log_file=/var/lib/mysql/slow.log</p><blockquote><p>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_ name-slow.log（如果没有指定参数slow_query_log_file的话）</p></blockquote><p>修改默认的阀值：<br>![](_v_images/20200212165930411_28712.png =600x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set global long_query_time = 3;    // 修改为阀值到3秒的就是慢SQL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![](_v_images/20200212170629890_11886.png =600x)</p><p>记录慢SQL并后续分析：<br>![](_v_images/20200212171247138_13935.png =800x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show global status like '%Slow_queries%';    // 查询当前系统中有多少条慢查询记录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>永久生效：在配置文件配置<br>![](_v_images/20200212171754710_7017.png =300x)</p><h4 id="日志分析工具-mysqldumpslow"><a href="#日志分析工具-mysqldumpslow" class="headerlink" title="日志分析工具 mysqldumpslow"></a>日志分析工具 mysqldumpslow</h4><p>![](_v_images/20200212172137573_5610.png =700x)<br>![](_v_images/20200212172433064_10793.png =600x)</p><h3 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h3><p>分析 当前会话中 语句执行的资源消耗情况 的明细条<br>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p><p>![](_v_images/20200213194638139_16013.png =700x)</p><p>![](_v_images/20200212182909139_1991.png =300x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">// SQL导致服务器慢，要么CPU运算复杂，要么就是频繁IOshow profile cpu, block io for query Query_ID;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>![](_v_images/20200213201014392_11266.png =500x)</p><h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>只能在测试环境用，绝不能在生产环境用<br><img src="/MySQL.assets/20200213201857044_30680.png"></p><p>配置启用：<br><img src="/MySQL.assets/20200213201939144_517.png"></p><p>编码启用：<br><img src="/MySQL.assets/20200213202250528_3100.png"></p><h3 id="慢查询日志-1"><a href="#慢查询日志-1" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>可以通过设置“slow_query_log=1”来开启慢查询，它的开启方式有两种：</p><ol><li>命令行的模式进行开启</li></ol><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set global slow_query_log=1# 重启 MySQL 服务之后就会失效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>修改 MySQL 配置文件的方式进行开启</li></ol><ul><li>配置 my.cnf 中的“slow_query_log=1”即可</li><li>并且可以通过设置“slow_query_log_file=/tmp/mysql_slow.log”来配置慢查询日志的存储目录</li><li>但这种方式配置完成之后需要重启 MySQL 服务器才可生效。</li></ul><blockquote><p>需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能。</p></blockquote><h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><p>![](_v_images/20200213203045844_24303.png =300x)<br>![](_v_images/20200213203120633_4708.png =800x)</p><p>![](_v_images/20200213203528140_13996.png =600x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">lock table 表名字 read / write , 表名字2 read / write , 其他;show open tables;    // 查看表上加过的锁unlock tables;       // 释放表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h3><h4 id="加读锁"><a href="#加读锁" class="headerlink" title="加读锁"></a>加读锁</h4><p>![](_v_images/20200213205614501_1680.png =900x)<br>![](_v_images/20200213205822672_13981.png =900x)<br>![](_v_images/20200213205853640_1400.png =900x)<br>![](_v_images/20200213205928510_336.png =900x)</p><h4 id="加写锁"><a href="#加写锁" class="headerlink" title="加写锁"></a>加写锁</h4><p>![](_v_images/20200213211149680_18149.png =800x)<br>![](_v_images/20200213211042190_16223.png =800x)</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>![](_v_images/20200213211541027_1763.png =900x)</p><p>![](_v_images/20200213212504095_31147.png =800x)</p><ul><li>读锁：自己可以读，别人也可以读；自己不能写，别人也不能写；自己不能对其他表操作，别人可以操作</li><li>写锁：自己可以读，别人不可以读；自己可以写，别人不能写；自己不能对其他表操作，别人可以操作</li></ul><h4 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h4><p>![](_v_images/20200213213720910_31620.png =200x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show open tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![](_v_images/20200213213735027_4026.png =600x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show status like 'table%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![](_v_images/20200213214020721_15558.png =900x)</p><p>![](_v_images/20200213214252845_5066.png =900x)</p><h3 id="行锁-偏写"><a href="#行锁-偏写" class="headerlink" title="行锁(偏写)"></a>行锁(偏写)</h3><p>![](_v_images/20200213214545167_25268.png =1000x)</p><h4 id="行锁定演示"><a href="#行锁定演示" class="headerlink" title="行锁定演示"></a>行锁定演示</h4><p>![](_v_images/20200214142621739_11006.png =900x)</p><h4 id="无索引-行锁升级为表锁"><a href="#无索引-行锁升级为表锁" class="headerlink" title="无索引 行锁升级为表锁"></a>无索引 行锁升级为表锁</h4><p>索引失效(varchar类型字段没加单引号) ==》行锁升级为表锁<br>![](_v_images/20200214145033514_14244.png =700x)</p><h4 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h4><p>![](_v_images/20200214155554460_6142.png =700x)<br>![](_v_images/20200214160323837_7104.png =700x)</p><p>![](_v_images/20200214160419749_32160.png =800x)</p><h4 id="如何锁定一行-面试题"><a href="#如何锁定一行-面试题" class="headerlink" title="如何锁定一行(面试题)"></a>如何锁定一行(面试题)</h4><p>![](_v_images/20200214160700357_26458.png =900x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from test_table where  &lt;where_condition&gt; for update;    // 手动锁定某一行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>![](_v_images/20200214163959658_22284.png =802x)</p><h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><p>![](_v_images/20200214164141356_12417.png =700x)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show status like 'innodb_row_lock%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![](_v_images/20200214164627045_23796.png =500x)<br>![](_v_images/20200214164829003_21973.png =800x)</p><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>![](_v_images/20200214165031245_13942.png =600x)</p><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><p>![](_v_images/20200214165215722_8434.png =800x)</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><p>slave会从master读取<code>bin-log</code>来进行数据同步</p><p><img src="/MySQL.assets/20200214173955144_28132.png"></p><h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><p><img src="/MySQL.assets/20200214174103257_3718.png"></p><h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><p>延时</p><h3 id="一主-一从"><a href="#一主-一从" class="headerlink" title="一主 一从"></a>一主 一从</h3><p><img src="/MySQL.assets/20200214174955496_2896.png"></p><p><img src="/MySQL.assets/20200214175438582_8532.png"></p><p><img src="/MySQL.assets/20200214175709049_210.png"></p><p><img src="/MySQL.assets/20200214180001571_27049.png"><br><img src="/MySQL.assets/20200214180038534_5473.png"></p><p><img src="/MySQL.assets/20200214180553287_10997.png"></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show master status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL.assets/20200214180628962_32181.png"></p><p><img src="/MySQL.assets/20200214181421275_29166.png"></p><p><img src="/MySQL.assets/20200214181927152_6918.png"></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">stop slave;    // 停止从机的复制<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p><a href="https://cloud.tencent.com/developer/article/1398937">全量备份</a> : <code>percona-xtrabackup</code> </p><h2 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h2><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 有返回值public String getUserInfo1() {    ......    return user.toString();}//无返回值public void getUserInfo2() {    ......}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建函数如果报错：<strong>Thies function has none of DETERMINISTIC……</strong></p><ul><li><p>由于开启过<code>慢查询日志</code>，因为开启了<code>bin-log</code>, 就必须为<code>function</code> 指定一个参数</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show variables like 'log_bin_trust_function_creators';set global log_bin_trust_function_creators = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>MySql重启后，上述参数会消失，永久方法：</p><ul><li>windows下，my.ini[mysqld] 加上 <code>log_bin_trust_function_creators=1</code> </li><li>linux 下，/etc/my.cnf下 my.conf[mysqld] 加上<code>log_bin_trust_function_creators=1</code></li></ul></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>随机字符串：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER $$CREATE FUNCTION rand_string(n INT) RETURN VARCHAR(255)BEGIN  DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';  DECLARE return_str VARCHAR(255) DEFAULT '';  DECLARE i INT DEFAULT 0;  WHILE i &lt; n DO  SET return_str =CONCAT(return_str,SUBSTRING(chars_str, FLOOR(1+RAND()*52),1));  SET i = i + 1;  END WHILE;  RETURN return_str;END $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>随机编号：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER $$CREATE FUNCTION rand_num( ) RETURN INT(5)BEGIN  DECLARE i INT DEFAULT 0;  SET i = FLOOR(100+RAND()*10);  RETURN i;END $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除函数：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop function rand_num;    //假如要删除<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><strong>插入数据的过程：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER ;;CREATE PROCEDURE insert_emp(IN START INT(10), IN max_num INT(10))BEGINDECLARE i INT DEFAULT 0;SET autocommit = 0; # 自动提交，设置为0# 循环体REPEAT  SET i = i + 1;# 插入数据时，可以调用函数INSERT INTO emp(empno, ename, create_time) VALUES ((START+i), rand_string(6), now());UNTIL i = max_numEND REPEAT ;commit;END;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER ;;CREATE PROCEDURE insert_dept(IN START INT(10), IN max_num INT(10))BEGINDECLARE i INT DEFAULT 0;SET autocommit = 0; # 自动提交，设置为0# 循环体REPEAT  SET i = i + 1;# 插入数据时，可以调用函数INSERT INTO dept(deptno, dname, loc) VALUES ((START+i), rand_string(10), rand_string(8));UNTIL i = max_numEND REPEAT ;commit;END;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER ;    CALL insert_dept(100, 10);    // 调用过程用callCALL insert_emp(100001,500000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="hacker"><a href="#hacker" class="headerlink" title="hacker"></a>hacker</h2><p><a href="https://www.sqlsec.com/2020/11/mysql.html#toc-heading-1">MySQL 漏洞利用与提权</a></p><h2 id="生产实例"><a href="#生产实例" class="headerlink" title="生产实例"></a>生产实例</h2><p><a href="https://juejin.cn/post/6907115764545748999">Mysql6000w数据表的查询优化到0.023S</a></p><p><a href="https://juejin.cn/post/6919263740122628109#heading-6">如何一步步存储一条数据</a>：<code>表空间</code> / <code>页结构</code>  </p><p><a href="https://juejin.cn/post/6923788859712995336#heading-1">简单明了的介绍MySql重要的概念</a>：<code>不同维度的索引类型</code>/ <code>索引结构的演进</code> / <code>回表</code> / <code>覆盖索引的结构树</code> / <code>索引下推</code></p><p><a href="https://www.cnblogs.com/zhurong/p/10062315.html">Select count(*)和Count(1)的区别和执行方式</a>：并无区别，展示了详细的执行计划</p><p><a href="https://juejin.cn/post/6924591827286753288">MySQL海量数据优化</a>：<code>很精彩的案列</code>/ <code>limit优化</code></p><!-- ![](https://raw.githubusercontent.com/MicroWiller/photobed/master/paging.png) --><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 使用前一次查询的最大IDSelect * From t_user where id &gt; 999990 order by id limit 10;# 受影响的行：0# 时间：0.011s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li><p>聚簇索引和非聚簇索引的 <a href="https://my.oschina.net/xiaoyoung/blog/3046779">区别</a></p><blockquote><p>数据和索引是否存储在一起, 辅助索引的叶子节点存储不同</p></blockquote></li><li><p>为什么主键通常建议使用自增id</p><blockquote><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据在磁盘上存放也一定是相邻的。</p></blockquote></li><li><p>Innodb和MyISAM的<a href="https://blog.csdn.net/qq_35642036/article/details/82820178">区别</a></p><blockquote><p>Innodb支持事务，行[表]锁，聚簇索引，外键，必须有主键；<br>MyISAM不支持事务，表锁，非聚簇索引，不支持外键，可以没有主键；<br>ISAM: Indexed Sequential Access Method 有索引的顺序访问方法；<br>行锁：InnoDB行锁是通过给索引项加锁来实现的，即<em>只有通过索引条件查找数据</em>，InnoDB才使用行级锁，否则将使用表锁！</p></blockquote></li><li><p>InnoDB<a href="https://www.cnblogs.com/jianzh5/p/11643151.html">如何</a>保证事务特性</p><blockquote><p>A：undo log    C：undo log + redo log    I：锁    D：redo log</p></blockquote></li><li><p>如何排查慢查询？一条SQL语句执行得很慢的原因有哪些？</p><blockquote><p>就像要考你计算机网络的知识时，问你“输入URL回车之后，究竟发生了什么”一样，看看你能说出多少了。<br><a href="https://www.sohu.com/a/312754751_355142">总分两种情况</a></p></blockquote></li></ul><h2 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#基础配置datadir=/data/datafilesocket=/var/lib/mysql/mysql.socklog-error=/data/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pidcharacter_set_server=utf8#允许任意IP访问bind-address = 0.0.0.0#是否支持符号链接，即数据库或表可以存储在my.cnf中指定datadir之外的分区或目录，为0不开启#symbolic-links=0#支持大小写lower_case_table_names=1#二进制配置server-id = 1log-bin = /data/log/mysql-bin.loglog-bin-index =/data/log/binlog.indexlog_bin_trust_function_creators=1expire_logs_days=7#sql_mode定义了mysql应该支持的sql语法，数据校验等#mysql5.0以上版本支持三种sql_mode模式：ANSI、TRADITIONAL和STRICT_TRANS_TABLES。#ANSI模式：宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告。#TRADITIONAL模式：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误。用于事物时，会进行事物的回滚。#STRICT_TRANS_TABLES模式：严格模式，进行数据的严格校验，错误数据不能插入，报error错误。sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION#InnoDB存储数据字典、内部数据结构的缓冲池，16MB已经足够大了。innodb_additional_mem_pool_size = 16M#InnoDB用于缓存数据、索引、锁、插入缓冲、数据字典等#如果是专用的DB服务器，且以InnoDB引擎为主的场景，通常可设置物理内存的60%#如果是非专用DB服务器，可以先尝试设置成内存的1/4innodb_buffer_pool_size = 4G#InnoDB的log buffer，通常设置为 64MB 就足够了innodb_log_buffer_size = 64M#InnoDB redo log大小，通常设置256MB 就足够了innodb_log_file_size = 256M#InnoDB redo log文件组，通常设置为 2 就足够了innodb_log_files_in_group = 2#共享表空间:某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。默认的文件名为:ibdata1 初始化为10M。#独占表空间:每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。#设置参数为1启用InnoDB的独立表空间模式，便于管理innodb_file_per_table = 1#InnoDB共享表空间初始化大小，默认是 10MB，改成 1GB，并且自动扩展innodb_data_file_path = ibdata1:1G:autoextend#设置临时表空间最大4Ginnodb_temp_data_file_path=ibtmp1:500M:autoextend:max:4096M#启用InnoDB的status file，便于管理员查看以及监控innodb_status_file = 1#当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。#当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务。#当设置为2，该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。innodb_flush_log_at_trx_commit = 1#设置事务隔离级别为 READ-COMMITED，提高事务效率，通常都满足事务一致性要求#transaction_isolation = READ-COMMITTED#max_connections：针对所有的账号所有的客户端并行连接到MYSQL服务的最大并行连接数。简单说是指MYSQL服务能够同时接受的最大并行连接数。#max_user_connections : 针对某一个账号的所有客户端并行连接到MYSQL服务的最大并行连接数。简单说是指同一个账号能够同时连接到mysql服务的最大连接数。设置为0表示不限制。#max_connect_errors：针对某一个IP主机连接中断与mysql服务连接的次数，如果超过这个值，这个IP主机将会阻止从这个IP主机发送出去的连接请求。遇到这种情况，需执行flush hosts。#执行flush host或者 mysqladmin flush-hosts，其目的是为了清空host cache里的信息。可适当加大，防止频繁连接错误后，前端host被mysql拒绝掉#在 show global 里有个系统状态Max_used_connections,它是指从这次mysql服务启动到现在，同一时刻并行连接数的最大值。它不是指当前的连接情况，而是一个比较值。如果在过去某一个时刻，MYSQL服务同时有1000个请求连接过来，而之后再也没有出现这么大的并发请求时，则Max_used_connections=1000.请注意与show variables 里的max_user_connections的区别。#Max_used_connections / max_connections * 100% ≈ 85%max_connections=600max_connect_errors=1000max_user_connections=400#设置临时表最大值，这是每次连接都会分配，不宜设置过大 max_heap_table_size 和 tmp_table_size 要设置一样大max_heap_table_size = 100Mtmp_table_size = 100M#每个连接都会分配的一些排序、连接等缓冲，一般设置为 2MB 就足够了sort_buffer_size = 2Mjoin_buffer_size = 2Mread_buffer_size = 2Mread_rnd_buffer_size = 2M#建议关闭query cache，有些时候对性能反而是一种损害query_cache_size = 0#如果是以InnoDB引擎为主的DB，专用于MyISAM引擎的 key_buffer_size 可以设置较小，8MB 已足够#如果是以MyISAM引擎为主，可设置较大，但不能超过4Gkey_buffer_size = 8M#设置连接超时阀值，如果前端程序采用短连接，建议缩短这2个值，如果前端程序采用长连接，可直接注释掉这两个选项，是用默认配置(8小时)#interactive_timeout = 120#wait_timeout = 120#InnoDB使用后台线程处理数据页上读写I/0请求的数量,允许值的范围是1-64#假设CPU是2颗4核的，且数据库读操作比写操作多，可设置#innodb_read_io_threads=5#innodb_write_io_threads=3#通过show engine innodb status的FILE I/O选项可查看到线程分配#设置慢查询阀值，单位为秒long_query_time = 120slow_query_log=1 #开启mysql慢sql的日志log_output=table,File #日志输出会写表，也会写日志文件，为了便于程序去统计，所以最好写表slow_query_log_file=/data/log/slow.log##针对log_queries_not_using_indexes开启后，记录慢sql的频次、每分钟记录的条数#log_throttle_queries_not_using_indexes = 5##作为从库时生效,从库复制中如何有慢sql也将被记录#log_slow_slave_statements = 1##检查未使用到索引的sql#log_queries_not_using_indexes = 1#快速预热缓冲池innodb_buffer_pool_dump_at_shutdown=1innodb_buffer_pool_load_at_startup=1#打印deadlock日志innodb_print_all_deadlocks=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程概述</title>
      <link href="/2022/10/05/wang-luo-bian-cheng-gai-shu/"/>
      <url>/2022/10/05/wang-luo-bian-cheng-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>我们在处理⽹络问题时，经常处理的是 _I/O 问题_，即输⼊和输出；说⽩了就是，如何把⽹卡收到的数据给到指定的程序，程序如何将数据拷⻉到⽹卡。 所以，当数据到达⽹卡之后，操作系统会做哪些操作？程序⼜是怎么接收到的数据呐？</p><h2 id="从⽹卡到操作系统"><a href="#从⽹卡到操作系统" class="headerlink" title="从⽹卡到操作系统"></a>从⽹卡到操作系统</h2><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/networkCardToProcess.png" alt="networkCardToProcess"></p><p>从上图可以看出，Frames（传⼊⽹卡的数据这⾥抽象为Frames，⼀个 Frame 是<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a>的传输单位或封包）到达⽹卡之后，⾸先需要把数据拷⻉到内存；⽤户进程的访问，需要再拷⻉⼀次。</p><p>注意，将数据从内存中的⼀个区域拷⻉到另⼀个区域，这是⼀个 CPU 密集型操作。数据的拷⻉, 归根结底要⼀个字节⼀个字节去做。</p><p>从⽹卡到内核空间的这步操作，可以⽤ DMA（Direct Memory Access）技术控制。<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a> 是⼀种⼩型设备，⽤ DMA 拷⻉数据可以不使⽤ CPU，从⽽节省计算资源。遗憾的是，通常我们写程序的时候，并不能直接控制 DMA，因此 DMA 仅仅⽤于硬件设备传输数据到内存中，这解决了⽹卡到内存的拷⻉。不过内核到⽤户空间的这次拷⻉，可以使⽤内存映射技术，将内核空间的数据映射到⽤户空间。</p><p>Linux 中⽤⼀个<strong>双向链表</strong>作为缓冲区，之所以这样做，是因为⽹卡没有⼤量的内存空间，只能做简单的缓冲，所以必须 赶紧将它们保存下来。如上图中的 Buffer，看上去像⼀个有很多个凹槽的线性结构，每个凹槽（节点）可以存储⼀个封包，这个封包可以从⽹络层看（IP封包），也可以从传输层看（TCP封包）。操作系统不断地从 Buffer 中取出数据， 数据通过⼀个协议栈，可以把它理解成很多个协议的集合。在协议栈中，数据封包找到对应的协议程序处理完之后，就会形成 Socket ⽂件。</p><p>在⾼并发的场景下，如果请求量级过⼤，把buffer沾满了；此时，操作系统就会拒绝服务。这就是⽹络上⼀种常⽤攻击⽅式的原理，<a href="https://zh.wikipedia.org/zh-cn/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A">DoS攻击</a>。</p><p>这里完整的流程是：⽹卡使⽤ DMA 技术，将 Frame 写⼊缓冲区（Buffer），然后再触发<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7">CPU中断</a>交给操作系统处理，随后操作系统从缓冲区中不断取出 Frame，通过协进栈（具体的协议）进⾏还原，将还原后的Socket供⽤户程序使⽤。</p><p>那Socket⼜是怎么和⽤户程序进⾏数据传输的呐？</p><h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>⾸先，Socket 是⽂件（UNIX系）；在⽂件的基础上，⼜封装了⼀段程序；这段程序提供了⼀组API，负责数据传输。 但对于进程⽽⾔，Socket更多的是⼀种编程模型，将其抽象出来，⽽不管各种操作系统的具体实现。</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/socket.png" alt="socket"></p><p>如上图所示，Socket 连接了应⽤和协议，客户端将数据发送给在客户端侧的Socket，然后客户端侧的 Socket 将数据 发送给服务端侧的 Socket 。Socket 负责提供通信能⼒，并处理底层的 TCP/UDP 连接，具体的操作都是由Socket进⾏封装。具体来说，对于 UNIX 系的操作系统，是利⽤ Socket ⽂件系统，⼀种特殊的⽂件——每个都是⼀个双向的管道。</p><p>那么作为⼀个服务端的应⽤，如何知道有哪些 Socket 呢？也就是，怎么知道哪些客户端连接过来了呢？这是就需要⼀ 种特殊类型的 Socket，也就是服务端 Socket ⽂件。</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/server_socket.png" alt="server_socket"></p><p>如上图所示，当⼀个客户端连接服务端时，服务端OS 会创建⼀个连接客户端的Socket⽂件；然后服务端OS 会将这个⽂件的⽂件描述符，写⼊服务端程序创建的服务端 Socket ⽂件中。这就是服务端Socket⽂件的特殊之处，不仅仅是双向管道，还相当于⼀个客户端 Socket 的<code>⽬录</code>；这样线程就可以通过 accept() 操作，每次从服务端Socket⽂件，拿⾛⼀个客户端⽂件描述符。线程拿到客户端⽂件描述符，_就相当于拿到了和客户端进⾏通信的接⼝_。</p><p>Socket和⽤户程序之间的数据传输: 当线程想要读取 Client 传输来的数据时，就从连接客户端的Socket ⽂件 中读取数据；当线程想要发送数据到 Client 时，就向连接客户端的Socket ⽂件中写⼊数据。</p><p>这⾥有个⼩细节，Linux 中的管道⽂件都是单向的，Socket ⽂件是⼀种区别于其操作系统管道的单独的实现。</p><p>可是⼀台服务器⾥⾯，⼤概率不仅仅只有⼀个服务；那⼀个客户端连接进来，怎么知道连接到哪个服务，把 FD 写到哪个服务的服务端Socket呐？</p><p>所以为了<strong>区分不同服务</strong>，对于服务端 Socket ⽂件，需要设置它监听的<code>端⼝</code>。⽐如 Nginx 监听 80 端⼝、Node 监听 3000 端⼝、SSH 监听 22 端⼝、Tomcat 监听 8080 端⼝（可修改）。</p><p>这样操作系统就会，把连接到不同端⼝的客户端Socket分类，将该 <em>Socket⽂件</em> 的FD 存到对应不同端⼝的 <em>服务端Socket⽂件</em> 中。因此，服务端监听端⼝的本质，是将服务端 Socket ⽂件和端⼝绑定，这个操作也称为 <code>bind</code>。</p><p>那其中⼀个客户端有新的数据传输过来，服务端服务是如何确定是哪个Socket连接传输过来的呐？</p><h2 id="I-x2F-O-多路复⽤技术"><a href="#I-x2F-O-多路复⽤技术" class="headerlink" title="I/O 多路复⽤技术"></a>I/O 多路复⽤技术</h2><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/multiplexing.png" alt="multiplexing"></p><p>⾸先，服务端程序会定期扫描 <em>服务端Socket⽂件</em> 的变更，来了解有哪些客户端想要连接进来。</p><p>如果在服务端 Socket ⽂件中读取到⼀个客户端连接的⽂件描述符，就会将这个⽂件描述符实例化成⼀个 Socket对象；随后，将这个Socket对象加⼊到服务端程序的⼀个集合中。</p><p>通过这个过程，服务端程序从操作系统的所有的Socket中，筛选出了⾃⼰关注 的⼀个<code>⼦集</code>。</p><p>服务端程序，定期的遍历这个Socket⼦集，来查看每个Socket对象背后的Socket⽂件状态，从⽽确定是否有新的数据从客户端传输过来。</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/server_multiplex_socket.png" alt="server_multiplex_socket"></p><p>这种通过⼀个线程就可以响应多个客户端的连接，被称作<code>I/O多路复⽤技术</code>。</p><p>处理 I/O 多路复⽤的问题，需要操作系统提供内核级别的⽀持。Linux 下有三种提供 I/O 多路复⽤的 API系统调⽤，分 别是：<a href="https://zh.wikipedia.org/wiki/Select_(Unix)">select</a> / poll / <a href="https://zh.wikipedia.org/wiki/Epoll">epoll</a>；freeBSD 系统下有 <a href="https://zh.wikipedia.org/wiki/Kqueue">kqueue</a>，以及 Windows 系统下有 iocp。</p><p>内核了解⽹络的状态，因此不难知道具体发⽣了什么消息，⽐如内核知道某个 Socket⽂件状态发⽣了变化。</p><p>但是内核 如何知道该把哪个消息给哪个进程呢？</p><p>进程和Socket⽂件是多对多的关系，⼀个进程有多个Socket⽂件，⼀个Socket⽂件可能被多个进程使⽤，而⼀个Socket⽂件⾃身也有不同的消息类型。</p><p>因此在 I/O 多路复⽤技术中，服务端程序中需要有⼀个<code>数据结构</code>，来描述⾃⼰会关注哪些Sockect⽂件的哪些消息（读、写、异常等）。</p><p>这个数据结构的设计，有两种⽅案：</p><p>⼀种是<strong>线性结构</strong>，如数组、链表等，每次内核产⽣消息，就遍历这个线性结构（O(n)），看看这个消息是不是该程序关注的。</p><p>另⼀种是<strong>索引结构</strong>，如红⿊树、B树等(O(logn))，内核发⽣了消息，可以通过索引结构⻢上知道这个消息进程关不关注。这也是Select/poll和epoll 最本质的区别。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>select 和 poll 都采⽤线性结构，在C程序中，该系统调⽤在 sys/select.h 或 <a href="https://zh.wikipedia.org/wiki/Unistd.h">unistd.h</a> 中声明，语法如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds, struct timeval* timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了维护fd_set类型的参数，会使⽤下⾯四个宏：FD_SET(), FD_CLR(), FD_ZERO() 和 FD_ISSET()。</p><p>返回值：这个函数将返回描述符集的个数，如果超时返回为0，错误则返回-1。</p><p>每次 select 操作会<strong>阻塞</strong>当前线程，在阻塞期间所有操作系统产⽣的每个消息，都会通过<code>遍历</code>的⼿段查看是否在 3 个集合当中。</p><p>如下⾯这段程序所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd_set read_fd_set, write_fd_set, error_fd_set;while(true) { select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>⽤户程序可以根据不同集合中，是否有某个 Socket 判断发⽣的消息类型，程序如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd_set read_fd_set, write_fd_set, error_fd_set;while(true) { select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set);  for (i = 0; i &lt; FD_SETSIZE; ++i) if (FD_ISSET (i, &amp;read_fd_set)){ // Socket可以读取 } else if(FD_ISSET(i, &amp;write_fd_set)) { // Socket可以写入 } else if(FD_ISSET(i, &amp;error_fd_set)) { // Socket发生错误 } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上⾯程序中的 FD_SETSIZE 是⼀个系统的默认设置，32位机默认是1024个，64位机默认是2048，具体数⽬可以 <code>cat /proc/sys/fs/file-max</code> 察看，⼀般来说这个数⽬和系统内存关系很⼤。因为 Select 对 Socket 进⾏扫描时是线性扫描， 即采⽤轮询的⽅法，效率较低，当并发请求过多的时候， Select 就⽆能为⼒了。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>从写程序的⻆度来看，select 并不是⼀个很好的编程模型。⼀个好的编程模型应该直达本质：当⽹络请求发⽣状态变化的时候，核⼼是会发⽣<code>事件</code>。</p><p>_将消息抽象成事件_，⽤户不需要⽤ select 来设置⾃每个集合，⽽是可以通过系统的 API 直接拿到对应的事件，从⽽处理对应的⽂件描述符。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">while(true) { events = poll(fds, ...) for(evt in events) { fd = evt.fd; type = evt.revents; if(type &amp; POLLIN ) { // 有数据需要读，读取fd中的数据 } else if(type &amp; POLLOUT) { // 可以写入数据 }  else ... }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上⾯这段伪代码就是⼀个更好的编程模型，具体的分析如下：</p><ol><li>poll 是⼀个<strong>阻塞调⽤</strong>，它将某段时间内 <em>操作系统内发⽣的且进程关注的</em> 事件告知⽤户程序；</li><li>⽤户程序通过直接调⽤ poll 函数拿到事件； </li><li>poll 函数的第⼀个参数告知内核 poll 关注哪些 Socket ； </li><li>poll 调⽤后，经过⼀段时间的等待（阻塞），就拿到了是⼀个事件的数组； </li><li>通过遍历这个数组中的事件，能够知道关联的⽂件描述符和事件类型； </li><li>通过事件类型判断接下来该进⾏读取还是写⼊操作； </li><li>通过⽂件描述符，可以进⾏实际地读、写、错误处理。</li></ol><p>poll 虽然优化了编程模型，但是从<code>性能⻆度</code>分析，它和 select 差距不⼤。因为内核在产⽣⼀个事件之后，依然需要遍历 poll 关注的所有⽂件描述符来确定这条事件是否跟⽤户程序相关。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>为了解决上述问题，epoll 通过更好的⽅案实现，_从操作系统订阅消息_：epoll 将进程关注的⽂件描述符存⼊⼀棵<code>⼆叉搜索树</code>(通常是<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红⿊树</a>的实现)。</p><p>在这棵红⿊树当中，Key 是Socket的编号，Value 是Socket关注的消息。</p><p>因此，当内核发⽣了⼀个事件：⽐如 Socket 编号 1000 可以读取。这个时候，进程可以⻢上从红⿊树中找到进程是否关注这个事件（再次感叹，如果代码写复杂了，那肯定是数据结构有问题）。</p><p>下⾯这段程序，对于每⼀个新的客户端连接，都使⽤ accept 拿到这个连接的⽂件描述符，并且创建⼀个客户端的 Socket。然后通过 epoll_ctl 将客户端的⽂件描述符和关注的事件类型放⼊ epoll 实例的红⿊树上，并注册⼀个回调函数。 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// Asynchronous Socket server - accepting multiple clients concurrently,// multiplexing the connections with epoll.//// Eli Bendersky [http://eli.thegreenplace.net]// This code is in the public domain.#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/Socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include "utils.h"#define MAXFDS 16 * 1024typedef enum { INITIAL_ACK, WAIT_FOR_MSG, IN_MSG } ProcessingState;#define SENDBUF_SIZE 1024typedef struct {  ProcessingState state;  uint8_t sendbuf[SENDBUF_SIZE];  int sendbuf_end;  int sendptr;} peer_state_t;// Each peer is globally identified by the file descriptor (fd) it's connected// on. As long as the peer is connected, the fd is unique to it. When a peer// disconnects, a new peer may connect and get the same fd. on_peer_connected// should initialize the state properly to remove any trace of the old peer on// the same fd.peer_state_t global_state[MAXFDS];// Callbacks (on_XXX functions) return this status to the main loop; the status// instructs the loop about the next steps for the fd for which the callback was// invoked.// want_read=true means we want to keep monitoring this fd for reading.// want_write=true means we want to keep monitoring this fd for writing.// When both are false it means the fd is no longer needed and can be closed.typedef struct {  bool want_read;  bool want_write;} fd_status_t;// These constants make creating fd_status_t values less verbose.const fd_status_t fd_status_R = {.want_read = true, .want_write = false};const fd_status_t fd_status_W = {.want_read = false, .want_write = true};const fd_status_t fd_status_RW = {.want_read = true, .want_write = true};const fd_status_t fd_status_NORW = {.want_read = false, .want_write = false};fd_status_t on_peer_connected(int sockfd, const struct sockaddr_in* peer_addr, socklen_t peer_addr_len) {  assert(sockfd &lt; MAXFDS);  report_peer_connected(peer_addr, peer_addr_len);  // Initialize state to send back a '*' to the peer immediately.  peer_state_t* peerstate = &amp;global_state[sockfd];  peerstate-&gt;state = INITIAL_ACK;  peerstate-&gt;sendbuf[0] = '*';  peerstate-&gt;sendptr = 0;  peerstate-&gt;sendbuf_end = 1;  // Signal that this Socket is ready for writing now.  return fd_status_W;}fd_status_t on_peer_ready_recv(int sockfd) {  assert(sockfd &lt; MAXFDS);  peer_state_t* peerstate = &amp;global_state[sockfd];  if (peerstate-&gt;state == INITIAL_ACK ||peerstate-&gt;sendptr &lt; peerstate-&gt;sendbuf_end) {    // Until the initial ACK has been sent to the peer, there's nothing we    // want to receive. Also, wait until all data staged for sending is sent to    // receive more data.    return fd_status_W;  }  uint8_t buf[1024];  int nbytes = recv(sockfd, buf, sizeof buf, 0);  if (nbytes == 0) {    // The peer disconnected.    return fd_status_NORW;  } else if (nbytes &lt; 0) {    if (errno == EAGAIN || errno == EWOULDBLOCK) {      // The Socket is not *really* ready for recv; wait until it is.      return fd_status_R;    } else {      perror_die("recv");    }  }  bool ready_to_send = false;  for (int i = 0; i &lt; nbytes; ++i) {    switch (peerstate-&gt;state) {    case INITIAL_ACK:      assert(0 &amp;&amp; "can't reach here");      break;    case WAIT_FOR_MSG:      if (buf[i] == '^') {        peerstate-&gt;state = IN_MSG;      }      break;    case IN_MSG:      if (buf[i] == '$') {        peerstate-&gt;state = WAIT_FOR_MSG;      } else {        assert(peerstate-&gt;sendbuf_end &lt; SENDBUF_SIZE);        peerstate-&gt;sendbuf[peerstate-&gt;sendbuf_end++] = buf[i] + 1;        ready_to_send = true;      }      break;    }  }  // Report reading readiness iff there's nothing to send to the peer as a  // result of the latest recv.  return (fd_status_t){.want_read = !ready_to_send, .want_write = ready_to_send};}fd_status_t on_peer_ready_send(int sockfd) {  assert(sockfd &lt; MAXFDS);  peer_state_t* peerstate = &amp;global_state[sockfd];  if (peerstate-&gt;sendptr &gt;= peerstate-&gt;sendbuf_end) {    // Nothing to send.    return fd_status_RW;  }  int sendlen = peerstate-&gt;sendbuf_end - peerstate-&gt;sendptr;  int nsent = send(sockfd, &amp;peerstate-&gt;sendbuf[peerstate-&gt;sendptr], sendlen, 0);  if (nsent == -1) {    if (errno == EAGAIN || errno == EWOULDBLOCK) {      return fd_status_W;    } else {      perror_die("send");    }  }  if (nsent &lt; sendlen) {    peerstate-&gt;sendptr += nsent;    return fd_status_W;  } else {    // Everything was sent successfully; reset the send queue.    peerstate-&gt;sendptr = 0;    peerstate-&gt;sendbuf_end = 0;    // Special-case state transition in if we were in INITIAL_ACK until now.    if (peerstate-&gt;state == INITIAL_ACK) {      peerstate-&gt;state = WAIT_FOR_MSG;    }    return fd_status_R;  }}int main(int argc, const char** argv) {  setvbuf(stdout, NULL, _IONBF, 0);  int portnum = 9090;  if (argc &gt;= 2) {    portnum = atoi(argv[1]);  }  printf("Serving on port %d\n", portnum);  int listener_sockfd = listen_inet_Socket(portnum);  make_Socket_non_blocking(listener_sockfd);  int epollfd = epoll_create1(0);  if (epollfd &lt; 0) {    perror_die("epoll_create1");  }  struct epoll_event accept_event;  accept_event.data.fd = listener_sockfd;  accept_event.events = EPOLLIN;  if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listener_sockfd, &amp;accept_event) &lt; 0) {    perror_die("epoll_ctl EPOLL_CTL_ADD");  }  struct epoll_event* events = calloc(MAXFDS, sizeof(struct epoll_event));  if (events == NULL) {    die("Unable to allocate memory for epoll_events");  }  while (1) {    int nready = epoll_wait(epollfd, events, MAXFDS, -1);    for (int i = 0; i &lt; nready; i++) {      if (events[i].events &amp; EPOLLERR) {        perror_die("epoll_wait returned EPOLLERR");      }      if (events[i].data.fd == listener_sockfd) {        // The listening Socket is ready; this means a new peer is connecting.        struct sockaddr_in peer_addr;        socklen_t peer_addr_len = sizeof(peer_addr);        int newsockfd = accept(listener_sockfd, (struct sockaddr*)&amp;peer_addr, &amp;peer_addr_len);        if (newsockfd &lt; 0) {          if (errno == EAGAIN || errno == EWOULDBLOCK) {            // This can happen due to the nonblocking Socket mode; in this            // case don't do anything, but print a notice (since these events            // are extremely rare and interesting to observe...)            printf("accept returned EAGAIN or EWOULDBLOCK\n");          } else {            perror_die("accept");          }        } else {          make_Socket_non_blocking(newsockfd);          if (newsockfd &gt;= MAXFDS) {            die("Socket fd (%d) &gt;= MAXFDS (%d)", newsockfd, MAXFDS);          }          fd_status_t status = on_peer_connected(newsockfd, &amp;peer_addr, peer_addr_len);          struct epoll_event event = {0};          event.data.fd = newsockfd;          if (status.want_read) {            event.events |= EPOLLIN;          }          if (status.want_write) {            event.events |= EPOLLOUT;          }          if (epoll_ctl(epollfd, EPOLL_CTL_ADD, newsockfd, &amp;event) &lt; 0) {            perror_die("epoll_ctl EPOLL_CTL_ADD");          }        }      } else {        // A peer Socket is ready.        if (events[i].events &amp; EPOLLIN) {          // Ready for reading.          int fd = events[i].data.fd;          fd_status_t status = on_peer_ready_recv(fd);          struct epoll_event event = {0};          event.data.fd = fd;          if (status.want_read) {            event.events |= EPOLLIN;          }          if (status.want_write) {            event.events |= EPOLLOUT;          }          if (event.events == 0) {            printf("Socket %d closing\n", fd);            if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL) &lt; 0) {              perror_die("epoll_ctl EPOLL_CTL_DEL");            }            close(fd);          } else if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0) {            perror_die("epoll_ctl EPOLL_CTL_MOD");          }        } else if (events[i].events &amp; EPOLLOUT) {          // Ready for writing.          int fd = events[i].data.fd;          fd_status_t status = on_peer_ready_send(fd);          struct epoll_event event = {0};          event.data.fd = fd;          if (status.want_read) {            event.events |= EPOLLIN;          }          if (status.want_write) {            event.events |= EPOLLOUT;          }          if (event.events == 0) {            printf("Socket %d closing\n", fd);            if (epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL) &lt; 0) {              perror_die("epoll_ctl EPOLL_CTL_DEL");            }            close(fd);          } else if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event) &lt; 0) {            perror_die("epoll_ctl EPOLL_CTL_MOD");          }        }      }    }  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作系统每次监测到⼀个新的消息产⽣，就会通过红⿊树对⽐这个消息是不是进程关注的（当然这段代码你看不到，因为它在内核程序中）。当有关注的事件发⽣时，epoll 会将事件添加到就绪链表中。⽤户调⽤epoll_wait时候，就会从链表中返回⼀个事件。</p><p>如果链表中没有事件，并且 epoll_wait 中的参数 timeout 设置为 0，epoll_wait可以⻢上返回，因此epoll是⼀个<code>⾮阻塞模型</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);// 当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。// 因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>epoll⾮阻塞模型的核⼼价值，并不是性能更好。毕竟当⾼并发真的来临时，所有的 CPU 资源，所有的⽹络资源可能都会被⽤完。这个时候⽆论是阻塞还是⾮阻塞，结果都不会相差太⼤（前提是程序没有写错）。</p><p>epoll有 2 个最⼤的优势：</p><ol><li>内部使⽤红⿊树减少了内核的⽐较操作；</li><li>对程序员⽽⾔，⾮阻塞的模型更容易处理各种各样的情况。程序员习惯了写出每⼀条语句就可以⻢上得到结果，这样不容易出 Bug。</li></ol><h2 id="I-x2F-O-模型"><a href="#I-x2F-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>从以上可知，select/poll 是<code>阻塞模型</code>，epoll 是<code>⾮阻塞模型</code>，阻塞和⾮阻塞强调的是 _线程的状态_。</p><p>BIO（Blocking I/O，阻塞 I/O），API 的设计会阻塞程序调⽤。⽐如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">byte a = readKey()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设 readKey ⽅法会从键盘中读取⼀个⽤户的按键，如果是阻塞 I/O 的设计，ReadKey 会阻塞当前⽤户线程 <em>直到</em> ⽤户按键。</p><p>这个阻塞指的是线程进⼊阻塞态。进⼊阻塞态的线程，状态会被存在内存中，执⾏会被中断，也就是不会占⽤ CPU 资源。阻塞态的线程要恢复执⾏，先要进⼊就绪态排队，然后轮到⾃⼰才能够继续执⾏。</p><p>从⼀个线程执⾏切换到另⼀个线程执⾏，也叫作线程的<a href="https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%8F%9B">上下⽂切换</a>（Context Switch），是⼀个相对耗时的操作。</p><p>NIO （None Blocking I/O，⾮阻塞 IO），API 的设计不会阻塞程序的调⽤，还是这行代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">byte a = readKey()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设readKey⽅法从键盘读取⼀个按键，如果是⾮阻塞 I/O 的设计，readKey不会阻塞当前的线程。</p><p>有同学可能会问：那如果⽤户没有按键怎么办？在阻塞 I/O 的设计中，如果⽤户没有按键线程会阻塞等待⽤户按键，在 ⾮阻塞 I/O 的设计中，线程不会阻塞，没有按键会返回⼀个空值，⽐如 null。</p><p>还有⼀组概念是同步（Synchrounous）和异步（Asynchrounous），select/poll/epoll 三者都是同步调⽤。</p><p>同步强调的是<strong>顺序</strong>，所谓同步调⽤，就是可以确定程序执⾏的顺序的调⽤。⽐如说执⾏⼀个调⽤，知道调⽤返回之前下⼀⾏代码不会执⾏。这种顺序是确定的情况，就是同步。</p><p>⽽异步调⽤则恰恰相反，异步调⽤不明确执⾏顺序。</p><p>AIO（Asynchronous I/O， 异步 I/O），API 的设计会多 _创造⼀条时间线_。⽐如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">func callBackFunction(byte keyCode) { // 处理按键}// 传入回调函数readKey( callBackFunction )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在异步 I/O 中，readKey⽅法会直接返回，但是没有结果。结果需要⼀个回调函数 callBackFunction 去接收。</p><p>从这个 ⻆度看，其实有两条时间线。第⼀条是程序的<strong>主⼲时间线</strong>，readKey的执⾏和readKey下⽂的程序都在这条主⼲时间线 中。</p><p>⽽callBackFunction的执⾏会在⽤户按键时触发，也就是时间不确定，因此callBackFunction中的程序是另⼀条时间线也是基于这种原因产⽣的，我们称作<code>异步</code>，异步描述的就是这种时间线上⽆法同步的现象，你不知道callbackFunc tion何时会执⾏。</p><p>但是我们通常说某某语⾔提供了异步 I/O，不仅仅是说提供上⾯程序这种写法，上⾯的写法会产⽣⼀个叫作<code>回调地狱</code>的问题，本质是异步程序的时间线错乱，导致维护成本较⾼。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">request("/order/123", (data1) -&gt; { //.. request("/product/456", (data2) -&gt; { // .. request("/sku/789", (data3) -&gt; { //... }) })})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上⾯这段程序（称作回调地狱）维护成本较⾼，因此通常提供异步 API 编程模型时，我们会提供⼀种 <em>将异步转化为同步程序</em> 的语法。⽐如下⾯这段伪代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">Future future1 = request("/order/123")Future future2 = request("/product/456")Future future3 = request("/sku/789")// ...// ...order = future1.get()product = future2.get()sku = future3.get()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>request 函数是⼀次⽹络调⽤，请求订单 ID=123 的订单数据。本身 request 函数不会阻塞，会⻢上执⾏完成，⽽⽹络 调⽤是⼀次异步请求，调⽤不会在request(“/order/123”)下⼀⾏结束，⽽是会在未来的某个时间结束。</p><p>因此，我们⽤⼀个 Future 对象封装这个异步操作。future.get()是⼀个阻塞操作，会阻塞直到⽹络调⽤返回。</p><p>在request和future.get之间，我们还可以进⾏很多别的操作，⽐如获取其他数据、发送更多的请求。 </p><p>像 Future 这样能够将异步操作再同步回主时间线的操作，我们称作<code>异步转同步</code>，也叫作 _异步编程_。</p><p>通常⼀⻔语⾔如果提供异步编程的能⼒，指的是提供异步转同步的能⼒，程序员更适应同步操作，同步程序更好维护。</p><p>由此可⻅，<strong>⾮阻塞不⼀定是异步，阻塞也未必就是同步</strong>。</p><p>⽐如⼀个带有回调函数的⽅法，阻塞了线程 100 毫秒，⼜提供 了回调函数，那这个⽅法是异步阻塞。例如下⾯的伪代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">asleep(100ms, () -&gt; { // 100ms 或更多后到这里 // ...do some thing})// 100 ms 后到这里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结下，操作系统给我们提供了各种各样的 API，是希望满⾜各种各样程序架构的诉求。</p><p>但总体诉求其实是⼀致的：希望程序员写的单机代码，能够在多线程甚⾄分布式的环境下执⾏。这样就不需要再去学习复杂的<code>并发控制算法</code>。</p><p>从这个⻆度去看，⾮阻塞加上同步的编程模型确实省去了编程过程当中的很多思考，符合我们的思维模式。</p><p>到这里，我们已经知道，服务可以确定是哪个Socket连接传输过来的了；那数据传输，数据⼜是怎么进⾏传输的呐？</p><h2 id="流、缓冲区"><a href="#流、缓冲区" class="headerlink" title="流、缓冲区"></a>流、缓冲区</h2><p>数据传输，实际上就是数据从⼀个地⽅到另⼀个地⽅。</p><p>将数据抽象出来，类⽐为⽔，⽔从⼀个地⽅流到另⼀个地⽅，数据也是从⼀个地⽅流到另⼀个地⽅；不过⽔的流是动词，_⽽数据的流，是内存中的⼀个<code>对象</code>，⼀个<code>结构</code>_。</p><p>当⽤户读取⽂件内容的时候，通过流进⾏读取，看上去好像从流中读取了数据，⽽本质上读取的是⽂件的数据。</p><p>从这个⻆度去观察整体的设计，数据从⽂件到了流，然后再到了⽤户线程，数据是经过流的。所以，_流也代表数据_，具体来说 是随着时间产⽣的数据。</p><p>那可不可以将数据直接从⽂件传输到⽤户线程呢？</p><p>可以的，流对象中只设计⼀个整数型指针，⼀开始指向⽂件的头部，每次发⽣读取，都从⽂件中读出内容，然后再返回给⽤户线程。做完这次操作，指针⾃增。</p><p>通过这样的设计，流中就不需要再有数据了。可⻅，流中不⼀定要有数据。<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/steam_data.png" alt="steam_data"></p><p>如上图，把⽂件看作是⼀系列线性排列连续字节的合集，⽤户线程调⽤流对象的读取数据⽅法，每次从⽂件中读取⼀个字节。流中只保留⼀个读取位置 position，指向下⼀个要读取的字节。</p><p>看上去这个⽅案可⾏，但实际上性能极差。因为从⽂件中读取数据这个操作，是⼀次磁盘的 I/O 操作，⾮常耗时。</p><p>正确的做法是每次读取 <strong>2k</strong>、<strong>4k</strong> 这样⼤⼩的数据，这是因为操作系统中的<code>内存分⻚</code>通常是这样的⼤⼩，_⽽磁盘的读写往往是会适配⻚表⼤⼩_。</p><p>⽽且现在的⽂件系统主要都是<code>⽇志⽂件系统</code>，存储的并不是原始数据本身；也就是说，多数情况下，你看到的⽂件并不是⼀个连续紧密的字节线性排列，⽽是⽇志。</p><p>简单来说，就是你向磁盘读取 2k 数据，读取到的不⼀定是 2k 实际的数据，很有可能会⽐ 2k 少，这是因为⽂件内容是以⽇志形式存储，会有冗余。</p><p>所以流对象的设计，⾄少应该⽀持两种操作：⼀种是读取⼀个字节，另⼀种是读取多个字节。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// bufio.go// Reader implements buffering for an io.Reader object.type Reader struct { buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⽽⽆论读取⼀个字节还是 读取多个字节，_都应该适配内核的底层⾏为_。也就是说，每次流对象读取⼀个字节，内核可能会读取 2k、4k 的数据。这样的⾏为，才能真的做到减少磁盘的 I/O 操作。</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/stream_kernel.png" alt="stream_kernel"></p><p>所以如上图，采⽤两个缓冲区：内核中的缓冲区，⽤于缓冲读取⽂件中的数据；流中的缓冲区，⽤于缓冲内核中拷⻉过来的数据。</p><p>有同学可能不理解，为什么不把内核的缓冲区直接给到流呢？这是因为流对象⼯作在⽤户空间，内核中的缓冲区⼯作在内核空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本⽂通过 数据达到⽹卡，再到操作系统，最后到达⽤户程序的过程，来展开讲解其中的细节和 I/O 模型、select/epoll、异步等编程模型。其中涉及到的概念知识较多，不⾜之处，还望扶正。</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel</title>
      <link href="/2022/07/16/kernel/"/>
      <url>/2022/07/16/kernel/</url>
      
        <content type="html"><![CDATA[<h2 id="从开机加电到执行main函数之前的过程"><a href="#从开机加电到执行main函数之前的过程" class="headerlink" title="从开机加电到执行main函数之前的过程"></a>从开机加电到执行main函数之前的过程</h2><p>第一步，启动BIOS，准备实模式下的中断向量表和中断服务程序；<br>第二步，从启动盘加载操作系统程序到内存，加载操作系统程序的工作就是利用第一步中准备的中断服务程序实现的；<br>第三步，为执行32位的main函数做过渡工作。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p><a href="https://baike.sogou.com/v45346.htm?ch=op.wx.read">BIOS</a>: 是在通电引导阶段 运行硬件初始化，以及为操作系统和程序提供运行时服务的固件。</p><p>启动时BIOS在内存的状态及初始执行位置:</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/BIOS_inMemory.png" alt="BIOS_inMemory"></p><p>CS（Code Segment Register）：<strong>代码段</strong>寄存器，存在于CPU中，指向CPU <strong>当前执行代码</strong> 在<u>内存中</u>的<strong>区域</strong>（定义了存放代码的存储器的起始地址）。</p><p>IP/EIP（Instruction Pointer）：<strong>指令指针</strong>寄存器，存在于CPU中，记录将要执行的指令在代码段内的偏移地址，和CS组合即为将要执行的指令的内存地址。实模式为绝对地址，指令指针为16位，即IP；保护模式下为线性地址，指令指针为32位，即EIP。</p><p>BIOS程序的入口地址恰恰就是0xFFFF0 ！ 也就是说，BIOS程序的第一条指令就设计在这个位置。</p><p>BIOS在内存中加载中断向量表和中断服务程序：<br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/BIOS_loadTable.png" alt="BIOS_loadTable"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/05/22/redis/"/>
      <url>/2022/05/22/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="部署运维"><a href="#部署运维" class="headerlink" title="部署运维"></a>部署运维</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p 6379:6379 -v /will/myredis/data:/data -v /will/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis redis-server /usr/local/etc/redis/redis.conf--appendonly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 连接进入Redisdocker exec -it redis_name /bin/bash./redis-cli# 查询所有的键keys * # 获取键对应的value的类型type key # 删除指定的key valuedel key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ul><li>Redis其实也是多线程？？，只不过是用单线程？？来接收请求，在客户端看起来？？是串行接收执行，所以效果上就是单线程？？。但是<code>IO多路复用</code>？？才是Redis能<strong>高并发</strong>的底层保证。？？</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>Redis 属于单线程还是多线程？</p></blockquote><ul><li><p>Redis 是单线程的，主要是指 Redis 的<strong>网络 I/O</strong> 线程，以及键值的 SET 和 GET 等<strong>读写操作</strong>都是由一个线程来完成</p></li><li><p>但Redis 的持久化、集群同步等操作，则是由另外的线程来执行的</p></li><li><p>可以在无锁的情况下完成所有操作，不存在死锁和线程切换带来的性能和时间上的开销</p></li><li><p>但同时单线程也不能发挥多核 CPU 的性能</p></li></ul><p><a href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8">文件事件处理器</a> </p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=592#/detail/pc?id=6063">需要掌握的Redis原理</a> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisOfHigh.png" style="zoom:50%;"><blockquote><p>单线程的redis为什么这么快</p></blockquote><ul><li>纯内存操作，采用了高效的数据结构，比如哈希表和跳表</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞I/O多路复用机制，因为基于非阻塞的 I/O 模型，就意味着 I/O 的读写流程不再阻塞</li><li>Redis 4.0 版本之后，Redis 添加了多线程的支持，但这时的多线程主要体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等</li><li>Redis 6.0 版本之后，为了更好地提高 Redis 的性能，新增了多线程 I/O 的读写并发能力，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上，所以为了提高网络请求处理的并行度，Redis 6.0 对于网络请求采用多线程来处理。</li><li>但是对于读写命令，Redis 仍然使用单线程来处理。</li></ul><blockquote><p>Reids 为什么先执行命令，再把数据写入日志呢？（写后日志，正好和Mysql的“写前日志”相反）</p></blockquote><ul><li><p>因为 ，Redis 在写入日志之前，不对命令进行<strong>语法检查</strong>；</p></li><li><p>所以，只记录执行成功的命令，避免了出现记录错误命令的情况； </p></li><li><p>并且，在命令执行完之后再记录，<strong>不会阻塞</strong>当前的写操作</p></li></ul><p>这样做也会带来风险：</p><ul><li>数据可能会丢失 </li><li>可能阻塞其他操作： 虽然 AOF 是写后日志，避免阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是<strong>会阻塞后续</strong>的操作无法执行。</li></ul><blockquote><p>RDB 做快照时会阻塞线程吗？</p></blockquote><ul><li>因为 Redis 的单线程模型决定了它所有操作都要尽量避免阻塞主线程，所以对于 RDB 快照也不例外，这关系到是否会降低 Redis 的性能。</li><li>为了解决这个问题，Redis 提供了两个命令来生成 RDB 快照文件，分别是 <strong>save</strong> 和 <strong>bgsave</strong>。save 命令在主线程中执行，会导致阻塞。而 bgsave 命令则会<em>创建一个子进程</em> ，用于写入 RDB 文件的操作，避免了对主线程的阻塞，这也是 Redis RDB 的默认配置。</li></ul><blockquote><p>RDB 做快照的时候数据能修改吗？</p></blockquote><p><strong>这个问题非常重要</strong>，考察候选人对 RDB 的技术掌握得够不够深。你可以思考一下，如果在执行快照的过程中，数据如果能被修改或者不能被修改都会带来什么影响？</p><ol><li>如果此时可以执行写操作：意味着 Redis 还能正常处理写操作，就可能出现正在执行快照的数据是已经被修改了的情况；</li><li>如果此时不可以执行写操作：意味着 Redis 的所有写操作都得等到快照执行完成之后才能执行，那么就又出现了阻塞主线程的问题。</li></ol><p>那Redis 是如何解决这个问题的呢？ 它利用了 bgsave 的子进程，具体操作如下：</p><ul><li>如果主线程执行<em>读操作</em>，则主线程和 bgsave 子进程互相不影响；</li><li>如果主线程执行<em>写操作</em>，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RDB_ProcessOfRedis.png" style="zoom:67%;"><blockquote><p>redis的常用数据结构</p></blockquote><ul><li>string/hash/list/set/sortedsort</li></ul><blockquote><p>zset的数据结构</p></blockquote><ul><li>set 关联一个double类型的分数 ==&gt;有序集合</li></ul><blockquote><p>zset的中插入一个元素的时间复杂度</p></blockquote><ul><li>向有序集合添加 score和element 的时间复杂度为 O(logN)   ||  删除或获取element的时间复杂度都为O(1)</li></ul><blockquote><p>redis如何保证高可用？</p></blockquote><ul><li>redis持久化机制【dump.rdb/appendonly.aof】、主从复制、哨兵机制</li></ul><blockquote><p>什么是redis的哨兵模式？</p></blockquote><ul><li>通过后台监测主机是否宕机，如果宕机了按投票选举，票数多的从机成为新的主机，整个过程是自动的</li></ul><blockquote><p>缓存穿透、缓存击穿、缓存雪崩区别和解决方案</p></blockquote><ul><li><a href="https://blog.csdn.net/kongtiao5/article/details/82771694">详细内容</a></li></ul><p></p><h2 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h2><p> <strong>通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升</strong> </p><p>•缓存（数据查询、短连接、新闻内容、商品内容等等）<br>•聊天室的在线好友列表<br>•任务队列（秒杀、抢购、12306等等）<br>•应用排行榜  (zsort)<br>•网站访问统计<br>•数据过期处理（可以精确到毫秒)<br>•分布式集群架构中的session分离</p><h2 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 类似Map&lt;string, value&gt;;    // key 都是字符串类型// 而且其他几种数据结构都是在字符串类型基础上构建的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="value的数据结构"><a href="#value的数据结构" class="headerlink" title="value的数据结构"></a>value的数据结构</h3><table><thead><tr><th align="left">类型</th><th align="center">类似</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">字符串</td><td align="center">string</td><td align="center">可以存放数字，并加减；但需进行转换成int64</td></tr><tr><td align="left">哈希</td><td align="center">hash</td><td align="center">map&lt;key, value&gt;</td></tr><tr><td align="left">列表</td><td align="center">linkedlist</td><td align="center">双端节点, 支持重复元素</td></tr><tr><td align="left">集合</td><td align="center">hashSet</td><td align="center">不允许重复元素</td></tr><tr><td align="left">有序集合</td><td align="center">sortedset</td><td align="center">不允许重复元素，且元素有顺序</td></tr></tbody></table><p>Redis的数据结构：<br>        <img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/DataStructureOfRedis.png"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisStringCommand.png" style="zoom:47%;"><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有3种：</p><ul><li>int：8个字节的长整型</li><li>embstr：小于等于39个字节的字符串</li><li>raw：大于39个字节的字符串</li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisHashCommand.png" style="zoom:67%;"><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认<strong>512</strong>个）、同时所有值都小于hash-max-ziplist-value配置（默认<strong>64字节</strong>）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</li><li>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O(1)。</li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/InterStructOfRedisHash.png" style="zoom:67%;"><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表中的每个字符串称为元素（element），一个列表最多可以存储2^32-1个元素</p><p>列表两端插入和弹出操作：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisLIstOfPushAndPop.png" style="zoom:67%;"><p>子列表获取、删除等操作：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisLIstOfGetAndDel.png" style="zoom:67%;"><p>列表类型有两个特点：</p><p>第一、列表中的元素是有序的</p><ul><li>可以通过索引下标获取某个元素或者某个范围内的元素列表</li></ul><p>第二、列表中的元素可以是重复的</p><blockquote><p>这两个特点和集合/有序集合比较后，会显得更加突出，因此在考虑是否使用该数据结构前，首先需要弄清楚列表数据结构的特点。</p></blockquote><h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisCommandOfList.png" style="zoom:67%;"><ul><li>索引下标有两个特点：</li><li>第一，索引下标<strong>从左到右分别是0到N-1</strong>，但是<strong>从右到左分别是-1到-N</strong>。</li><li>第二，lrange中的<strong>end选项包含了自身</strong>，这个和很多编程语言不包含end不太相同，lrange操作会获取列表指定索引范围所有的元素。</li></ul><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisOfSet.png" style="zoom:67%;"><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li><p>intset（整数集合）</p><p>当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）将会使用intset来作为集合的内部实现，从而减少内存的使用。</p></li><li><p>hashtable（哈希表）</p><p>当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisDifferentOfLIstAndSet.png" style="zoom:67%;"><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisOfZsetOfCommand.png" style="zoom:67%;"><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><table><thead><tr><th align="center">基础数据类型</th><th align="center">可能的编码方式</th></tr></thead><tbody><tr><td align="center">字符串</td><td align="center">int, embstr, raw</td></tr><tr><td align="center">列表</td><td align="center">之前是 ziplist, linkedlist。3.2开始都是quicklist</td></tr><tr><td align="center">集合</td><td align="center">intset, hashtable</td></tr><tr><td align="center">有序集合</td><td align="center">ziplist, skiplist, ??hash??</td></tr><tr><td align="center">散列</td><td align="center">ziplist, hashtable</td></tr></tbody></table><p>参考：<a href="https://mp.weixin.qq.com/s/DZexS3gy_xdxxp2tsuHE3w">一文理解Redis底层数据结构</a> </p><h2 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h2><p> <a href="https://www.cnblogs.com/javastack/p/12848446.html">Redis 到底是单线程还是多线程？</a> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/SingleThreadOfRedis.png" style="zoom:57%;"><ul><li>文件事件处理器：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。</li><li>因为文件事件分派器队列的<strong>消费</strong>是单线程的，所以Redis才叫单线程模型。</li></ul><h2 id="穿透-x2F-击穿-x2F-雪崩"><a href="#穿透-x2F-击穿-x2F-雪崩" class="headerlink" title="穿透/击穿/雪崩"></a>穿透/击穿/雪崩</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247486528&amp;idx=1&amp;sn=3f7b09eb21969fdb16f5b0805ff69fed&amp;scene=21#wechat_redirect">小故事</a></p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/BUfferDesign.png" style="zoom:67%;"><ul><li><p><strong>缓存击穿</strong>：缓存中没有，但数据库中有的数据</p></li><li><p><strong>缓存穿透</strong>：缓存和数据库中都没有的数据，并发查同一条数据</p><ul><li>解决：</li><li>最常见的则是采用<em>布隆过滤器</em>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li><li>还有一个更为<strong>简单粗暴的方法</strong>，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟</li></ul></li><li><p><strong>缓存雪崩</strong>：缓存中数据大批量到过期时间</p><ul><li>解决：</li><li>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上</li><li>还有一个简单方案就是<u><em>分散开</em></u> 缓存失效时间</li></ul></li></ul><h2 id="缓存过期-x2F-内存淘汰"><a href="#缓存过期-x2F-内存淘汰" class="headerlink" title="缓存过期/内存淘汰"></a>缓存过期/内存淘汰</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1779">过期淘汰策略和内存淘汰策略有什么区别</a></p><p><a href="https://blog.csdn.net/DQWERww/article/details/126453008">redis的删除策略</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247486528&amp;idx=1&amp;sn=3f7b09eb21969fdb16f5b0805ff69fed&amp;scene=21#wechat_redirect">个中原由</a></p><h3 id="过期淘汰策略"><a href="#过期淘汰策略" class="headerlink" title="过期淘汰策略"></a>过期淘汰策略</h3><p>原因：</p><p><strong>新增</strong> Redis 缓存时可以<strong>设置缓存的过期时间</strong>，该时间保证了数据在规定的时间内失效，可以借助这个特性来实现很多功能</p><ul><li>超时时间有了，该在什么时候去干这个清理的活呢？ ？</li><li>不能一口气把所有过期的都给删除掉，redis里面存了大量的数据，要全面扫一遍的话那不知道要花多久时间，会严重影响接待新的客户请求！！</li></ul><p>时间紧任务重，只好随机选择一部分来清理，能缓解内存压力就行！！！</p><p>策略：</p><ol><li>定时删除：为每个设置了过期时间的key，都需要*<u>创建一个定时器，到过期时间就会立即清除</u>*；但需要消耗大量的CPU资源去清除过期的数据，<code>可能会影响缓存服务的性能</code></li><li>惰性删除： 原来逃脱了redis 随机选择算法的键值，<u>一旦遇到查询请求，被发现已经超期了，立即删除</u>； 是被动式触发的，不查询就不会发生；导致缓存中出现<code>大量的过期key无法被删除</code></li><li>定期删除：添加一个<code>即将过期的缓存字典</code>，<u>每隔一定的时间，会扫描一定数量的key</u>，并清除其中已过期的key</li></ol><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看当前 Redis 的内存淘汰策略config get maxmemory-policy# 修改内存淘汰策略的方式，无需重启 Redis 服务器，次重启 Redis 服务器之后设置的内存淘汰策略就会丢失config set maxmemory-policy noeviction# 也可以通过配置文件来修改，redis.conf 对应的配置项是“maxmemory-policy noeviction”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>noeviction：不淘汰任何数据，当内存不足时，执行缓存新增操作会报错，它是 Redis 默认内存淘汰策略</li><li>allkeys-random：随机淘汰任意键值</li><li>volatile-random：随机淘汰设置了过期时间的任意键值</li><li>allkeys-lru：淘汰整个键值中最久未使用的键值</li><li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值</li><li>volatile-ttl：优先淘汰更早过期的键值</li><li>volatile-lfu，淘汰所有设置了过期时间的键值中最少使用的键值</li><li>allkeys-lfu，淘汰整个键值中最少使用的键值</li></ul><p>注：LFU在4.0后添加的</p><blockquote><p>小贴士：从以上内存淘汰策略中可以看出，allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p></blockquote><p>内存淘汰算法：</p><p>LRU（ Least Recently Used，最近最少使用）淘汰算法：是一种常用的页面置换算法，也就是说<code>最久没有使用</code>的缓存将会被淘汰</p><p>LFU（Least Frequently Used，最不常用的）淘汰算法：最不常用的算法是根据<code>总访问次数</code>来淘汰数据的，它的核心思想是<u>“如果数据过去被访问多次，那么将来被访问的频率也更高”</u>。</p><p>LFU 相对来说比 LRU 更“智能”，因为它解决了使用频率很低的缓存，只是最近被访问了一次就不会被删除的问题。</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1782">高可用</a></p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247486926&amp;idx=1&amp;sn=58e99f81d6d6ee31c9a5c8f93122e108&amp;scene=21#wechat_redirect">RDB / AOF</a></p><p><a href="https://www.cnblogs.com/YMWH/articles/16526724.html">混合模式</a></p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis DataBase（<strong>快照</strong>方式）：按照一定的 <u><em>时间周期策略</em></u> 把内存的数据以快照的形式保存到硬盘的二进制文件。</p><p>实现：</p><ol><li>单独fork()创建一个子进程</li><li>将当前父进程的全部数据复制到子进程的内存中，然后由子进程写入到临时文件中(需上一个持久化的过程结束了)</li><li>再用这个<strong>临时文件</strong> <u><em>覆盖</em></u> 上次的快照文件</li><li>然后子进程退出，内存释放</li></ol><p>在一定的间隔时间中，<strong>检测key的变化情况</strong>，然后持久化数据</p><ol><li><p>编辑redis.windwos.conf文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重新启动redis服务器，并指定配置文件名称<br>…\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf</p></li></ol><p></p><ul><li>RDB 默认的保存文件为 dump.rdb</li><li>优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑</li><li>与 AOF 相比，RDB 具备更快的重启恢复能力</li><li>RDB对Redis对外提供的读写服务，影响非常小，可以让Redis保持高性能，因为Redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>Append Only File（文件追加方式）：将每一个<strong>收到的写命令</strong>都通过Write函数追加到文件最后，类似于MySQL的binlog</p><ul><li>当Redis重启，会通过重新执行文件中，保存的写命令来在内存中重建整个数据内容</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly no（关闭aof） --&gt; appendonly yes （开启aof）appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化appendfsync no ： 不进行持久化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>AOF 默认的保存文件为 appendonly.aof</li><li>优点是存储频率更高，因此丢失数据的风险就越低，并且 AOF 并不是以二进制存储，存储信息更易懂</li><li>缺点是占用空间大，重启之后的数据恢复速度比较慢 （大到一定程度，redis会进行 rewrite操作）</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>AOF可以更好的保护数据不丢失，一般每隔1S，通过一个后台线程执行一次<strong>fsync</strong>操作，保证 os cache中的数据写入磁盘，最多丢失1秒数据</li><li>AOF日志文件以append-only模式写入，所以没有任何<strong>磁盘寻址</strong>开销，写入性能高，而且文件不容易破损；即使文件破损，也有工具可以恢复</li><li>AOF文件过大时候，会出现<strong>rewrite</strong>操作，但并不影响客户端的读写；因为在rewrite log的时候，会对其中的数据进行压缩，创建出一份需要恢复数据的最小日志出来；在创建新日志文件的时候，老的日志文件还是照常写入，当新的merge后的日志文件ready的时候，再交换新老日志文件即可；基于redis当前内存中最新的数据进行<strong>指令的重新构建</strong> </li><li>AOF日志文件的命令通过，可读的方式进行记录，这个特性非常适合做灾难新的误删除的紧急恢复</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>占用磁盘空间更多</li><li>做数据恢复比较慢，冷备不太方便</li></ol><h5 id="Rewrite过程"><a href="#Rewrite过程" class="headerlink" title="Rewrite过程"></a>Rewrite过程</h5><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AOF Rewrite.png" alt="AOF Rewrite" style="zoom:67%;"><h5 id="AOF文件修复"><a href="#AOF文件修复" class="headerlink" title="AOF文件修复"></a>AOF文件修复</h5><p>如果redis <strong>在append数据到AOF文件时</strong>，<em>机器宕机了</em>，可能会导致AOF文件破损(只保存到完整命令的一部分)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修复方法./redis-check-aof [--fix] &lt;file.aof&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>Redis 4.0 推出了<strong>混合</strong>持久化</p><p>混合持久化的功能指的是 Redis 可以使用 RDB + AOF 两种格式来进行数据持久化 </p><p>AOF 和 RDB 混合的数据持久化机制： 把数据以 RDB 的方式写入文件，再将后续的操作命令以 AOF 的格式存入文件，既保证了 Redis 重启速度，又降低数据丢失风险。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; config get aof-use-rdb-preamble1) "aof-use-rdb-preamble"2) "yes"# 打开config set aof-use-rdb-preamble yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Redis 混合持久化的存储模式是，开始的数据以 RDB 的格式进行存储，因此只会占用少量的空间</li><li>之后的命令会以 AOF 的方式进行数据追加，这样就可以减低数据丢失的风险，同时可以提高数据恢复的速度</li><li>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AOF%E5%92%8CRDB%E5%90%8C%E6%97%B6%E5%B7%A5%E4%BD%9C.png"></p><p>Redis企业级备份：</p><p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisBackup.png" alt=""></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><blockquote><p>Redis主从架构 -&gt; 读写分离架构 -&gt; 可支持水平扩展的读高并发架构</p></blockquote><ul><li>写多读少的业务，得考虑MQ，做异步分离</li></ul><h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ReplicationTheroyOfRedis.png" style="zoom:80%;"><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247487533&amp;idx=1&amp;sn=49b600ef7eac342dad1f5a8048361099&amp;scene=21#wechat_redirect">Redis主从复制/哨兵模式的原理解析</a>  </p><p>全量复制使用<code>snyc</code>命令来实现，其流程是：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisSnyc.png" style="zoom:67%;"><p>旧版本全量复制功能，其最大的问题是从服务器断线重连时，<strong>即便</strong>在从服务器上已经有一部分数据了，也需要进行全量复制，这样做的<code>效率很低</code>，于是新版本的redis在这部分做了改进？？<strong>序列号</strong></p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisNumber.png" style="zoom:67%;"><p>新版本redis使用==psync==命令来代替sync命令，该命令既可以实现完整全同步也可以实现部分同步。</p><ol><li><strong>复制偏移量</strong>：<ul><li>执行复制的双方，主从服务器，分别会维护一个复制偏移量：</li><li>主服务器每次向从服务器同步了N字节数据之后，将修改自己的复制偏移量+N。</li><li>从服务器每次从主服务器同步了N字节数据之后，将修改自己的复制偏移量+N。</li></ul></li><li><strong>复制积压缓冲区</strong>：<ul><li>主服务器内部维护了一个固定长度的先进先出队列做为复制积压缓冲区，其默认大小为1MB。</li><li>在主服务器进行命令传播时，不仅会将写命令同步到从服务器，还会将写命令写入复制积压缓冲区。</li></ul></li></ol><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p> Redis 哨兵模块存储在 Redis 的 src/redis-sentinel 目录下 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动哨兵功能./src/redis-sentinel sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>三个监控任务：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisSentinel;.png" style="zoom:67%;"><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisBetweenSentinel.png" style="zoom:50%;"><blockquote><p>每隔2秒，每个哨兵节点将会向redis数据节点的__sentinel__:hello频道同步自身得到的主节点信息以及当前哨兵节点的信息</p><p>由于其他哨兵节点也订阅了这个频道，因此实际上这个操作可以<strong>交换</strong>哨兵节点之间关于主节点以及哨兵节点的信息。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisSentinelTheory.png" style="zoom:57%;"><blockquote><p>哨兵的工作原理是每个哨兵会以每秒钟 1 次的频率，向已知的主服务器和从服务器，发送一个 PING 命令。</p><p>如果最后一次有效回复 PING 命令的时间，超过了配置的最大下线时间（Down-After-Milliseconds）时，默认是 30s，那么这个实例会被哨兵标记为主观下线。 </p><p>如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有哨兵节点，要以每秒 1 次的频率确认主服务器是否进入了主观下线的状态。</p><p>如果有足够数量（quorum 配置值）的哨兵证实该主服务器为主观下线，那么这个主服务器被标记为客观下线。</p><p>此时所有的哨兵会按照规则（协商）自动选出新的主节点服务器，并自动完成主服务器的自动切换功能，而整个过程都是无须人工干预的。 </p></blockquote><p>发现新的哨兵节点：</p><p>如果有新的哨兵节点加入，此时保存下来这个新哨兵节点的信息，后续与该哨兵节点建立连接。<br>交换主节点的状态信息，作为后续客观判断主节点下线的依据。</p><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>Redis Cluster 是一种分布式去中心化的运行模式，是在 Redis 3.0 版本中推出的 Redis 集群方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><img src="Redis.assets/image-20210424232749103.png" alt="image-20210424232749103" style="zoom:67%;"><p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。</p><ul><li><p>根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。</p></li><li><p>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽</p></li></ul><p>剩下的一个问题就是，这些哈希槽怎么被映射到具体的 Redis 实例上的呢？有两种方案。</p><ul><li><p>平均分配： 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群实例上。比如集群中有 9 个实例，则每个实例上槽的个数为 16384/9 个。</p></li><li><p>手动分配： 可以使用 cluster meet 命令手动建立实例间的连接，组成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数，</p></li></ul><p>数据、哈希槽，以及实例三者的映射分布关系：</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1780">来龙去脉</a></p><p>分布式锁是<em>控制</em>  <strong>分布式系统之间</strong> <u>同步访问</u> <strong>共享资源</strong> 的一种方式。</p><p>是为了解决分布式系统中，不同的系统或是同一个系统的不同主机<strong>共享同一个资源</strong>的问题，它通常会采用<strong>互斥</strong>来保证程序的一致性，这就是分布式锁的用途以及执行原理。</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/DistributeOfRedis.png" style="zoom:57%;"><p>分布式锁的常见实现方式有四种：</p><ul><li>基于 MySQL 的悲观锁来实现分布式锁，这种方式使用的最少，因为这种实现方式的性能不好，且容易造成死锁</li><li>基于 Memcached 实现分布式锁，可使用 add 方法来实现，如果添加成功了则表示分布式锁创建成功</li><li>基于 Redis 实现分布式锁，这也是要介绍的重点，使用 <code>setnx</code> 方法来实现，set if not exists（不存在则创建）</li><li>基于 ZooKeeper 实现分布式锁，利用 ZooKeeper <strong>顺序临时节点</strong>来实现</li></ul><p><strong>分布式锁得以实现的基本前提：</strong> </p><p>之所以可以使用以上四种方式来实现分布式锁，是因为以上四种方式都属于程序调用的“<code>外部系统</code>”，而分布式的程序是需要<strong>共享</strong>“外部系统”的</p><h2 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h2><p>一、</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setnx lock true(integer) 1 #创建锁成功#逻辑业务处理...127.0.0.1:6379&gt; del lock(integer) 1 #释放锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码有一个问题，就是<strong>没有设置锁的超时时间</strong> </p><p>如果出现异常情况，会导致锁未被释放，而其他线程又在排队等待此锁就会导致程序不可用</p><p>二、</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setnx lock true(integer) 1 #创建锁成功127.0.0.1:6379&gt; expire lock 30 #设置锁的(过期)超时时间为 30s(integer) 1 #逻辑业务处理...127.0.0.1:6379&gt; del lock(integer) 1 #释放锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这样执行仍然会有问题，因为 setnx lock true 和 expire lock 30 命令是<strong>非原子的</strong>  </p><p> 如果在 setnx 命令执行完之后，发生了异常情况，那么就会导致 expire 命令不会执行，因此依然没有解决死锁的问题</p><p>三、</p><p> Redis 2.6.12 中我们可以使用一条 set 命令来执行键值存储，并且可以判断键是否存在以及设置超时时间了，如下代码所示： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set lock true ex 30 nxOK #创建锁成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>ex 是用来设置超时时间的，expire</li><li>nx 是 not exists 的意思，用来判断键是否存在 </li><li>“OK”则表示创建锁成功，否则表示此锁有人在使用</li></ul><p>四、</p><p> 锁误删：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/20210220182119.png" style="zoom:67%;"> <p>锁被误删的解决方案是在使用 set 命令创建锁时，给 value 值设置一个归属标识。</p><p>例如，在 value 中插入一个 UUID，每次在删除之前先要判断 UUID 是不是属于当前的线程，如果属于再删除，这样就避免了锁被误删的问题。 </p><p>五、</p><p> 注意：在锁的归属判断和删除的过程中，<em>不能</em> 先判断锁再删除锁，如下代码所示： </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(uuid.equals(uuid)){ // 判断是否是自己的锁del(luck); // 删除锁}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 把判断和删除放到一个<strong>原子单元</strong>中去执行，因此需要借助 Lua 脚本来执行 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 释放分布式锁 * @param jedis Redis客户端 * @param lockKey 锁的 key * @param flagId 锁归属标识 * @return 是否释放成功 */public static boolean unLock(Jedis jedis, String lockKey, String flagId) {    String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(flagId));    if ("1L".equals(result)) { // 判断执行结果        return true;    }    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>六、</p><p>锁超时可以通过以下方案来解决：</p><ol><li>把执行耗时的方法从锁中剔除，减少锁中代码的执行时间，保证锁在超时之前，代码一定可以执行完；</li><li>把锁的超时时间设置的长一些，正常情况下我们在使用完锁之后，会调用删除的方法手动删除锁，因此可以把超时时间设置的稍微长一些；</li><li>续超时时间，在删除锁前，判断是否执行完分布式锁的逻辑；若还没有执行完，续约超时时间。</li></ol><h2 id="Redis-实现消息队列"><a href="#Redis-实现消息队列" class="headerlink" title="Redis 实现消息队列"></a>Redis 实现消息队列</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1781">Redis如何实现消息队列？？实现的方式有几种？？</a></p><table><thead><tr><th>实现方式</th><th align="center">持久化</th><th align="center">重复消费</th><th align="center">主题订阅</th><th align="center">消费消息确认</th><th align="center">延迟消息队列</th></tr></thead><tbody><tr><td>List (2.0 之前)</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr><tr><td>Zset (2.0 之前)</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">Y</td></tr><tr><td>Publisher/Subscriber (2.0 之后)</td><td align="center">N</td><td align="center">N</td><td align="center">Y</td><td align="center">N</td><td align="center"></td></tr><tr><td>Stream (5.0 之后)</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center"></td></tr></tbody></table><ul><li>List和Zset 可以借助 Redis 本身的持久化功能，AOF 或者是 RDB 或混合持久化的方式，用于把数据保存至磁盘</li></ul><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>下载jedis的jar包</li><li>使用</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">      //1. 获取连接Jedis jedis = new Jedis("localhost",6379);//2. 操作jedis.set("username","zhangsan");//3. 关闭连接jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">   //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口//2. 操作//存储jedis.set("username","zhangsan");//获取String username = jedis.get("username");System.out.println(username);//可以使用setex()方法存储可以 "指定过期时间的 key value"jedis.setex("activecode",20,"hehe");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对//3. 关闭连接jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p> map格式  </p><pre><code>        hset        hget        hgetAll</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">   //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口//2. 操作// 存储hashjedis.hset("user","name","lisi");jedis.hset("user","age","23");jedis.hset("user","gender","female");// 获取hashString name = jedis.hget("user", "name");System.out.println(name);// 获取hash的所有map中的数据// Map结构中存储的全是 stringMap&lt;String, String&gt; user = jedis.hgetAll("user");// 得到所有keyset（field）Set&lt;String&gt; keySet = user.keySet();for (String key : keySet) {    //获取value    String value = user.get(key);    System.out.println(key + ":" + value);}//3. 关闭连接jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>linkedlist格式。支持重复元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1. 获取连接     Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口     //2. 操作     // list 存储     jedis.lpush("mylist","a","b","c");//从左边存     jedis.rpush("mylist","a","b","c");//从右边存     // list 范围获取     List&lt;String&gt; mylist = jedis.lrange("mylist", 0, -1);     System.out.println(mylist);          // list 弹出     String element1 = jedis.lpop("mylist");//c     System.out.println(element1);     String element2 = jedis.rpop("mylist");//c     System.out.println(element2);     // list 范围获取     List&lt;String&gt; mylist2 = jedis.lrange("mylist", 0, -1);     System.out.println(mylist2);     //3. 关闭连接     jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p> 不允许重复元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1. 获取连接      Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口      //2. 操作      // set 存储      jedis.sadd("myset","java","php","c++");      // set 获取      Set&lt;String&gt; myset = jedis.smembers("myset");      System.out.println(myset);      //3. 关闭连接      jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sortedset"><a href="#sortedset" class="headerlink" title="sortedset"></a>sortedset</h4><p>不允许重复元素，且元素有顺序, 分数可以覆盖（排行榜，热搜）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1. 获取连接      Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口      //2. 操作      // sortedset 存储      jedis.zadd("mysortedset",3,"亚瑟");      jedis.zadd("mysortedset",30,"后裔");      jedis.zadd("mysortedset",55,"孙悟空");      // sortedset 获取      Set&lt;String&gt; mysortedset = jedis.zrange("mysortedset", 0, -1);      System.out.println(mysortedset);      //3. 关闭连接      jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h4><ol><li>创建JedisPool连接池对象</li><li>调用方法 getResource()方法获取Jedis连接</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//0.创建一个配置对象      JedisPoolConfig config = new JedisPoolConfig();      config.setMaxTotal(50);      config.setMaxIdle(10);      //1.创建Jedis连接池对象      JedisPool jedisPool = new JedisPool(config,"localhost",6379);      //2.获取连接      Jedis jedis = jedisPool.getResource();      //3. 使用      jedis.set("hehe","heihei");      //4. 关闭 归还到连接池中      jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JedisPoolUtils {    private static JedisPool jedisPool;    static{        //读取配置文件        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");        //创建Properties对象        Properties pro = new Properties();        //关联文件        try {            pro.load(is);        } catch (IOException e) {            e.printStackTrace();        }        //获取数据，设置到JedisPoolConfig中        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal")));        config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle")));        //初始化JedisPool        jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port")));    }    /**     * 获取连接方法     */    public static Jedis getJedis(){        return jedisPool.getResource();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go</title>
      <link href="/2022/05/22/go/"/>
      <url>/2022/05/22/go/</url>
      
        <content type="html"><![CDATA[<h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开启module模式go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.io,direct# 设置不走 proxy 的私有仓库，多个用逗号相隔（可选）go env -w GOPRIVATE=*.corp.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>fmt.Print</code>有几个变种：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Print:  输出到控制台,不接受任何格式化操作Println: 输出到控制台并换行Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量（不可以输出别的类型）Sprintf：格式化并返回一个字符串而不带任何输出Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通用的占位符</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">%v     值的默认格式。%+v   类似%v，但输出结构体时会添加字段名%#v　 相应值的Go语法表示 %T    相应值的类型的Go语法表示 %%    百分号,字面上的%,非占位符含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://www.cnblogs.com/rickiyang/p/11074171.html">Go中的fmt几种输出的区别和格式化方式</a> </p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><a href="https://zhuanlan.zhihu.com/p/68792989">深度解析context</a>: 不完美，但很高效解决了问题</p><p><strong>任何调用的默认超时时间的设置是非常有必要的</strong></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针结构图"><a href="#指针结构图" class="headerlink" title="指针结构图"></a>指针结构图</h3><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/PointerValue.png" style="zoom:67%;"><ul><li>指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象</li><li>这个对象可以是字符串、整数、函数或者你自定义的结构体</li><li>指针变量的值就是 <strong>它(内存地址)</strong> 所指向数据的内存地址，普通变量的值就是我们具体存放的数据</li><li>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小</li></ul><h3 id="指针变量-x2F-普通变量"><a href="#指针变量-x2F-普通变量" class="headerlink" title="指针变量/普通变量"></a>指针变量/普通变量</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   name:="will"   nameP:=&amp;name// &amp;, 表示取地址；指针的类型是 *string   fmt.Println("name变量的值为:",name)// name变量的值为: will   fmt.Println("name变量的内存地址为:",nameP)// name变量的内存地址为: 0xc000010200}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Go 语言中使用类型名称前加 * 的方式，即可表示一个对应的指针类型</li><li>比如 int 类型的指针类型是 *int，float64 类型的指针类型是 *float64，自定义结构体 A 的指针类型是 *A</li></ul><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 也可以通过 var 关键字定义var intP *int//指针类型不同，无法赋值 :intP = &amp;name //  Cannot use '&amp;name' (type *string) as type *int in assignment// 指针类型的变量如果没有分配内存，默认零值 nil，它没有指向的内存；所以无法使用，强行使用就会得到 nil 指针错误*intP =10// ipanic: runtime error: invalid memory address or nil pointer dereference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过 var 声明的指针变量不能直接赋值和取值的，因为它<code>仅仅是个变量</code>，<em>还没有对应的内存地址</em>，它的值是 <code>nil</code></p></li><li><p>而对于==值类型==来说，<code>即使只声明一个变量</code>，没有对其初始化，**<u><em>该变量也会有分配好的内存</em></u>**</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   var s string   fmt.Printf("%p\n",&amp;s)}// 声明了一个变量 s，并没有对其初始化，但是可以通过 &amp;s 获取它的内存地址// 这其实是 Go 语言帮我们做的，可以直接使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 只需要通过 new 函数给它分配一块内存就可以了var intP *int = new(int)// 更推荐简短声明法: intP := new(int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>和普通类型不一样的是</strong>，指针类型还可以通过内置的 new 函数来声明: </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">intP1 := new(int)// 内置的 new 函数有一个参数，可以传递类型给它,它会返回对应的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取指针指向的值"><a href="#获取指针指向的值" class="headerlink" title="获取指针指向的值"></a>获取指针指向的值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">nameV := *namePfmt.Println("nameP指针指向的值为:",nameV)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>要获取指针指向的值，只需要在指针变量前加 <code>*</code> 号即可</li><li><code>*</code> 直接，映射到 指针中存储的内存地址 指向的指</li></ul><h3 id="修改指针指向的值"><a href="#修改指针指向的值" class="headerlink" title="修改指针指向的值"></a>修改指针指向的值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">//修改指针指向的值*nameP = "will micro" fmt.Println("nameP指针指向的值为:",*nameP)fmt.Println("name变量的值为:",name)// 运行结果:// nameP指针指向的值为: will micro// name变量的值为: will micro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==对 *nameP 赋值等于修改了指针 nameP 指向的值== </p><p>不光 nameP 指针指向的值被改变了，变量 name 的值也被改变了，这就是指针的作用</p><h3 id="指针参数"><a href="#指针参数" class="headerlink" title="指针参数"></a>指针参数</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">age:=18modifyAge(age)fmt.Println("age的值为:",age)func modifyAge(age int)  {   age = 20}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modifyAge 中的 age 只是实参 age 的一份拷贝，所以修改它不会改变实参 age 的值</p><p><strong>要达到修改年龄，需要使用指针:</strong>  </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">age:=18modifyAge(&amp;age)fmt.Println("age的值为:",age)func modifyAge(age *int)  {   *age = 20}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要在函数中通过形参改变实参的值时，需要使用指针类型的参数</p></blockquote><h3 id="指针的优点"><a href="#指针的优点" class="headerlink" title="指针的优点"></a>指针的优点</h3><ol><li>可以<strong>修改</strong>指向数据的值</li><li>在<code>变量赋值</code>，<code>参数传值</code>的时候可以<strong>节省内存</strong></li></ol><p>Go 语言作为一种高级语言，在指针的使用上还是比较<strong>克制</strong>的。</p><p>它在设计的时候就对指针进行了诸多限制，比如<code>指针不能进行运算</code>，也<code>不能获取常量的指针</code>。</p><h3 id="指针的建议"><a href="#指针的建议" class="headerlink" title="指针的建议"></a>指针的建议</h3><ol><li>不要对 map、slice、channel 这类引用类型使用指针</li><li>如果需要修改<code>方法接收者</code><em><strong><u>内部的</u></strong></em> 数据或者状态时，需要使用指针</li><li>如果需要修改<code>参数的值</code>或者<code>内部数据</code>时，也需要使用指针类型的参数</li><li>如果是<code>比较大的结构体</code>，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针</li><li>像 int、bool 这样的小数据类型没必要使用指针</li><li>如果需要<code>并发安全</code>，则尽可能地不要使用指针，使用指针一定要保证并发安全</li><li>指针最好<code>不要嵌套</code>，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂</li></ol><h2 id="值类型-x2F-指针类型"><a href="#值类型-x2F-指针类型" class="headerlink" title="值类型/指针类型"></a>值类型/指针类型</h2><h3 id="指针的指向"><a href="#指针的指向" class="headerlink" title="指针的指向"></a>指针的指向</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 定义一个地址结构体type address struct {   province string   city string}// 值类型 address 作为接收者实现了接口 fmt.Stringerfunc (addr address) String()  string{   return fmt.Sprintf("the addr is %s%s",addr.province,addr.city)}// 那么指针类型 *address 也实现了接口 fmt.Stringer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   add := address{province: "北京", city: "北京"}   printString(add)   printString(&amp;add)}func printString(s fmt.Stringer) {   fmt.Println(s.String())}// 正常运行：// 证明了当值类型作为接收者实现了某接口时，它的指针类型也同样实现了该接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {    var si fmt.Stringer = address{province: "上海",city: "上海"}    printString(si)    sip := &amp;si    printString(sip)}// 错误信息：// ./main.go:42:13: cannot use sip (type *fmt.Stringer) as type fmt.Stringer in argument to printString://*fmt.Stringer is pointer to interface, not interface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<strong>指向<code>具体类型</code>的指针可以实现一个接口，但是指向<code>接口</code>的指针永远不可能实现该接口</strong> </p><h3 id="内存与不同类型"><a href="#内存与不同类型" class="headerlink" title="内存与不同类型"></a>内存与不同类型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个变量必须要经过<code>声明</code>、<code>内存分配</code>才能赋值，<em>才可以在声明的时候进行初始化</em> ：</p><ul><li><p>如果要对一个变量赋值，这个变量<code>必须有对应的分配好的内存</code>，这样才可以对这块内存操作，完成赋值的目的</p></li><li><p><strong>不止赋值操作</strong>，<code>对于指针变量</code>，如果没有分配内存，<em>取值操作一样会报 nil 异常</em>，<code>因为没有可以操作的内存</code></p></li></ul><p><code>指针类型</code>在声明的时候，<code>Go 语言并没有自动分配内存</code>，所以不能对其进行赋值操作，这和<code>值类型</code>不一样</p><p><code>slice</code>、<code>chan</code>和 <code>map</code> 也一样，因为它们*<u><strong>本质上也是指针类型</strong></u>*</p><h4 id="new-函数"><a href="#new-函数" class="headerlink" title="new 函数"></a>new 函数</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   var sp *string  // 没有分配到内存，不能对其进行赋值操作       sp = new(string)// 关键点，这可以分配到一块内存   *sp = "will"   fmt.Println(*sp)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内置函数 new 的源代码:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// The new built-in function allocates memory. The first argument is a type,// not a value, and the value returned is a pointer to a newly// allocated zero value of that type.func new(Type) *Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>翻译：根据传入的类型申请一块内存，然后返回指向这块内存的指针，指针指向的数据就是该类型的零值。</p></blockquote><p>指针变量初始化：（工厂函数）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">pp := NewPerson("will",20)func NewPerson(name string,age int) *person{   p:=new(person)   p.name = name   p.age = age   return p}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="make-函数"><a href="#make-函数" class="headerlink" title="make 函数"></a>make 函数</h4><p>使用 make 函数创建 map 的时候，其实调用的是 makemap 函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// makemap implements Go map creation for make(map[k]v, hint).func makemap(t *maptype, hint int, h *hmap) *hmap{  //省略无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>makemap 函数返回的是 *hmap 类型，而 hmap 是一个结构体，它的定义如下面的代码所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// src/runtime/map.go// A header for a Go map.type hmap struct {   // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.   // Make sure this stays in sync with the compiler's definition.   count     int // # live cells == size of map.  Must be first (used by len() builtin)   flags     uint8   B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)   noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details   hash0     uint32 // hash seed   buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.   oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing   nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)   extra *mapextra // optional fields}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>map 关键字其实非常复杂，它包含 map 的大小 count、存储桶 buckets 等</p></li><li><p>要想使用这样的 hmap，不是简单地通过 new 函数返回一个 *hmap 就可以，<code>还需要对其进行初始化</code>，这就是 make 函数要做的事情</p></li></ul><p>其实 make 函数就是 map 类型的工厂函数，它可以根据传递它的 K-V 键值对类型，创建不同类型的 map，同时可以初始化 map 的大小。</p><blockquote><p>提示：make 函数不只是 map 类型的工厂函数，还是 chan、slice 的工厂函数。它同时可以用于 slice、chan 和 map 这三种类型的初始化。</p></blockquote><ul><li><a href="#Map">map</a> </li><li><a href="#chan">chan</a> </li><li><a href="#SliceHeader">slice</a></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p><code>new 函数只用于分配内存，并且把内存清零</code>，也就是返回一个指向对应类型零值的指针。</p><ul><li>new 函数一般用于需要显式地返回指针的情况，不是太常用。</li></ul></li><li><p><code>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化</code>，因为这三种类型的结构比较复杂。</p><ul><li>比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</li></ul></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p><strong>引用类型的零值都是 nil：</strong> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AllOfTypeInGo.png" style="zoom:50%;"><p>在 Go 语言中，函数的参数传递<code>只有值传递</code>，而且传递的 <em>实参</em> <code>都是原始数据的一份拷贝</code></p><ul><li><p>如果拷贝的内容是值类型的，那么在函数中就<code>无法修改</code>原始数据</p></li><li><p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么在函数中就<code>可以修改</code>原始数据</p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://blog.csdn.net/wade3015/article/details/100149338">map的出生到扩展</a></p><h3 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   m:=make(map[string]int)   m["will"] = 18   fmt.Println("will的年龄为",m["will"])   modifyMap(m)   fmt.Println("will的年龄为",m["will"])}func modifyMap(p map[string]int)  {   p["will"] =20}// 成功修改：// will的年龄为 18// will的年龄为 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 判断key是否存在if value, ok := map[key]; ok {    // 存在}if value, ok := map[key]; !ok {    // 不存在}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 不关心索引和数据的情况for range m {}// 只关心索引的情况,只遍历键, 无须将值改为匿名变量形式，忽略值即可for kwy := range m {}// 关心索引和数据的情况for kwy, value := range m {}// 如果需要特定顺序的遍历结果，正确的做法是先排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h3><p>用<code>字面量</code>或者<code>make函数</code>的方式创建 map，都转换成 makemap 函数的调用，这个转换是 <strong>Go 语言编译器自动做的</strong> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// src/runtime/map.go// makemap implements Go map creation for make(map[k]v, hint).func makemap(t *maptype, hint int, h *hmap) *hmap{  //省略无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Go 语言的 map 类型本质上就是 <code>*hmap</code>, <strong>本质上就是个指针</strong> </p><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><p>Go 语言并发模块中的 <code>channel</code>, <strong>本质上也是个指针</strong> : </p><p>创建的 chan 其实是个 *hchan，所以它在参数传递中也和 map 一样</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func makechan(t *chantype, size int64) *hchan {    //省略无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>严格来说，Go 语言没有引用类型，但是我们可以把 map、chan 称为<strong>引用类型</strong>，<strong>为了便于理解</strong>。</p><p>除了 map、chan 之外，Go 语言中的<code>函数</code>、<code>接口</code>、<code>slice 切片</code>都可以称为<strong>引用类型</strong> </p><h2 id="切片-amp-数组"><a href="#切片-amp-数组" class="headerlink" title="切片&amp;数组"></a>切片&amp;数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">a1:=[1]string{"张三"}a2:=[2]string{"李四"}array:=[5]string{"a","b","c","d","e"}array:=[...]string{"a","b","c","d","e"}// slice := []string{"a","b","c","d","e"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>变量 a1 的大小是 <code>1</code>，内部元素的类型是 string，也就是说 a1 <code>最多只能存储 1 个类型为 string 的元素</code></li><li>变量 a2 的大小是 <code>2</code>，内部元素的类型也是 string，所以 a2 <code>最多可以存储 2 个类型为 string 的元素</code></li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ArrayOfGo.png" style="zoom:40%;"><p>数组由两部分构成：<code>数组的大小</code>和<code>数组内的元素类型</code> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">//数组结构伪代码表示array{  len  item type}// 数组循环for i,v:=range array{    fmt.Printf("数组索引:%d,对应值:%s\n", i, v)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组的限制"><a href="#数组的限制" class="headerlink" title="数组的限制"></a>数组的限制</h3><ul><li>一旦一个数组被声明，它的<code>大小</code>和<code>内部元素的类型</code>就<strong>不能改变</strong>，<strong>不能随意</strong>地向数组添加任意多个元素.</li><li>与C语言不同，创建数组时，Go会将数组元素初始化为零值，因此我们无需再显式地执行此初始化操作.</li><li>与C不同的是，Go数组是值类型，它不是指向内存块第一个元素的指针；如果将数组传递给函数，则将复制整个数组；但仍然可以<em>传递</em> <strong>指向数组</strong>的<strong>指针</strong>以使其不被复制.</li></ul><h3 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice 切片"></a>slice 切片</h3><p>​<code>为了解决数组以上的限制</code>，Go 语言创造了 slice，也就是切片。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">slice := array[2:5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/SliceOfGo.png" style="zoom:40%;"><ul><li>array[2:5] 获取到的是 c、d、e 这三个元素；左闭右开区间</li></ul><blockquote><p>切片是 对数组的 <strong>抽象</strong> 和 <strong>封装</strong> </p><p>底层是一个数组存储所有的元素，但是它<code>可以动态地添加元素</code>，容量不足时还可以<code>自动扩容</code></p><p>但，其并<strong>不是指针</strong>，而是一种数据类型</p></blockquote><p><strong>切片，就是<code>动态数组</code></strong>  </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := []string{"张三", "李四"}// 区别于数组，没有容量个数// a := [2]string{"张三", "李四"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 还可以使用make 函数传入一个容量参数：slice:=make([]string,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 可以指定新创建的切片 []string 容量为 8：slice := make([]string,4,8)// Go 语言在内存上划分了一块容量为 8 的内容空间（容量为 8）// 但是只有 4 个内存空间才有元素（长度为 4），其他的内存空间处于空闲状态// 当通过 append 函数往切片中追加元素的时候，会追加到空闲的内存上，当切片的长度要超过容量的时候，会进行扩容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 通过字面量的方式声明和初始化：      (和数组的区别只是，没有容量个数)slice := []string{"a","b","c","d","e"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过内置的 append 函数对一个切片追加元素，返回新切片，如下面的代码所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">//追加一个元素slice2:=append(slice1,"f")//多加多个元素slice2:=append(slice1,"f","g")//追加另一个切片slice2:=append(slice1,slice...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小技巧：</p><p>​在创建新切片的时候，最好要让新切片的<strong>长度==容量</strong>，这样在追加操作的时候就会<strong>生成新的</strong>底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   // 定义slice并初始化   ss := []string{"will","张三"}   fmt.Println("切片ss长度为",len(ss),",容量为",cap(ss))       // 动态扩容   ss=append(ss,"李四","王五")   fmt.Println("切片ss长度为",len(ss),",容量为",cap(ss))       fmt.Println(ss)       // 插入   slice = append([]string{}, slice...)}// 切片ss长度为 2 ,容量为 2// 切片ss长度为 4 ,容量为 4// [will 张三 李四 王五]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>append 自动扩容的原理</strong>：</p><ol><li><code>新建</code>一个底层数组</li><li>把原来切片内的元素<code>拷贝</code>到新数组中</li><li>最后返回一个<code>指向新数组</code>的切片</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type SliceHeader struct {   Data uintptr   Len  int   Cap  int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SliceHeader 是切片<code>在运行时</code>的表现形式：</p><ul><li>Data 用来<code>指向</code>存储切片元素的数组</li><li>Len 代表切片的<code>长度</code> </li><li>Cap 代表切片的<code>容量 </code></li></ul><p><code>不同切片</code>对应的<u>底层 Data</u> <code>指向</code>的可能是<code>同一个数组</code>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   // 定义并初始化数组   a1:=[2]string{"will","张三"}      // 根据数组定义slice   s1:=a1[0:1]   s2:=a1[:]       //打印出s1和s2的Data值，是一样的   fmt.Println((*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)).Data)   fmt.Println((*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)).Data)}// 824634150744// 824634150744<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>多个切片共用一个底层数组虽然可以减少内存占用，但是如果有一个切片修改内部的元素，其他切片也会受影响。</p><p>所以在切片作为参数在函数间传递的时候要小心，**<u><em>尽可能不要修改原切片内的元素</em></u>**。</p></blockquote><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><p>对于数组和切片来说，Go 语言有三种不同的遍历方式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 不关心索引和数据的情况for range a {}// 只关心索引的情况for i := range a {}// 关心索引和数据的情况for i, elem := range a {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><ul><li><p>从<code>集合类型</code>的角度考虑</p><ul><li>数组、切片和 map 都是集合类型，它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是<code>连续的内存</code>操作，<em><strong>通过索引就可以快速地找到元素存储的地址</strong></em> </li><li>当然 map 的价值也非常大，因为它的 Key 可以是很多类型，比如 int、int64、string 等</li><li>数组和切片的<code>索引</code>只能是<em><strong>整数</strong></em></li></ul></li><li><p>从<code>内存大小</code>的角度考虑</p><ul><li>在数组和切片中，切片又是高效的，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 SliceHeader 的三个字段就可以了，共用的还是同一个底层数组</li><li>切片的高效还体现在 for range 循环中，因为<code>循环得到的临时变量也是个值拷贝</code>，所以在遍历大的数组时，切片的效率更高</li></ul></li></ul><p>总结：切片<code>基于指针的封装</code>是它效率高的根本原因，因为可以减少内存的占用，以及减少内存复制时的时间消耗</p><h3 id="string-lt-x3D-gt-byte"><a href="#string-lt-x3D-gt-byte" class="headerlink" title="string <=> byte"></a>string &lt;=&gt; byte</h3><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p> []byte(s) 和 string(b) 这种<code>强制转换</code><strong>会重新拷贝一份字符串</strong> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := "will"fmt.Printf("s的内存地址：%d\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Data)b := []byte(s)fmt.Printf("b的内存地址：%d\n",(*reflect.SliceHeader)(unsafe.Pointer(&amp;b)).Data)s3 := string(b)fmt.Printf("s3的内存地址：%d\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s3)).Data)fmt.Println(s,string(b),s3)// 都是 "will"// 打印出的内存地址都不一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：</p><p>可以通过查看 runtime.stringtoslicebyte 和 runtime.slicebytetostring 这两个函数的源代码，了解关于 string 和 []byte 类型互转的具体实现。</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">// StringHeader is the runtime representation of a string.type StringHeader struct {   Data uintptr// 用于存放指向真实内容的指针   Len  int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在程序运行的时候，字符串和切片本质上就是 StringHeader 和 SliceHeader</li></ul><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">s:="will"b:=[]byte(s)// s3:=string(b)// s4 没有申请新内存（零拷贝）,和变量 b 使用的是同一块内存，因为它们的底层 Data 字段值相同s4 := *(*string)(unsafe.Pointer(&amp;b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 字符串转成byte数组：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a := "aaa"ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a))b := *(*[]byte)(unsafe.Pointer(&amp;ssh))  fmt.Printf("%v",b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址</li><li><code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串a转成底层结构的形式</li><li><code>(*[]byte)(unsafe.Pointer(&amp;ssh))</code> 可以把ssh底层结构体转成byte的切片的指针</li><li>再通过 <code>*</code>转为指针指向的实际内容</li></ul><p>参考：<a href="https://mp.weixin.qq.com/s/rGqM1wMlqQEoJSgyrgZNLg">2 个 Header</a> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() { s := "脑子进煎鱼了" v := string2bytes1(s) fmt.Println(v)}func string2bytes1(s string) []byte {  // 在程序必须保留一个单独的、正确类型的指向底层数据的指针 stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) var b []byte pbytes := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b)) pbytes.Data = stringHeader.Data pbytes.Len = stringHeader.Len pbytes.Cap = stringHeader.Len return b}// 在性能方面，若只是期望单纯的转换，对容量（cap）等字段值不敏感，也可以使用以下方式：func string2bytes2(s string) []byte { return *(*[]byte)(unsafe.Pointer(&amp;s))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SliceHeader-x2F-StringHeader"><a href="#SliceHeader-x2F-StringHeader" class="headerlink" title="SliceHeader/StringHeader"></a>SliceHeader/StringHeader</h4><ul><li><p>SliceHeader 有 Data、Len、Cap 三个字段</p></li><li><p>StringHeader 有 Data、Len 两个字段</p></li><li><p>所以 *SliceHeader 通过 unsafe.Pointer 转为 *StringHeader 的时候没有问题，因为 *SliceHeader 可以提供 *StringHeader 所需的 Data 和 Len 字段的值</p></li><li><p>但是反过来却不行了，因为 *StringHeader 缺少 *SliceHeader 所需的 Cap 字段，需要我们自己补上一个默认值</p></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">s:="will"//b:=[]byte(s)sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;s))sh.Cap = sh.Lenb1:=*(*[]byte)(unsafe.Pointer(sh))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>通过 unsafe.Pointer 把 string 转为 []byte 后，不能对 []byte 修改</p><p>比如不可以进行 b1[0]=12 这种操作，会报异常，导致程序崩溃。</p><p>这是因为在 Go 语言中 string 内存是只读的。</p></blockquote><p>扩展：<a href="https://developer.51cto.com/art/202106/665738.htm">Go 语言中的零拷贝优化</a> </p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p> <a href="https://mp.weixin.qq.com/s/4jvhRQvKlMiYweSOG6xCrA">小技巧分享：在 Go 如何实现枚举？</a> </p><h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i := 3       // reflect.Value 是一个结构体   iv := reflect.ValueOf(i)       // reflect.Type 是一个接口   it := reflect.TypeOf(i)       fmt.Println(iv,it)   // 3 int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p> reflect.Value 和 int 类型互转：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i := 3   // int to reflect.Value   iv := reflect.ValueOf(i)       // reflect.Value to int   i1 := iv.Interface().(int)       fmt.Println(i1)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>interface{} 是空接口，可以表示任何类型，也就是说你可以把任何类型转换为空接口，它通常用于反射、类型断言，以减少重复代码，简化编程。</p></blockquote><p>修改对应的值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i := 3       // 因为 reflect.ValueOf 函数返回的是一份值的拷贝，所以要传入变量的指针才可以   ipv := reflect.ValueOf(&amp;i)       //  因为传递的是一个指针，所以需要调用 Elem 方法找到这个指针指向的值，最后就可以使用 SetInt 方法修改值   ipv.Elem().SetInt(4)       fmt.Println(i)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么如何修改 <code>struct 结构体字段</code> 的值呢？</p><ol><li><p>传递一个 struct 结构体的指针，获取对应的 reflect.Value；</p></li><li><p>通过 Elem 方法获取指针指向的值；</p></li><li><p>通过 Field 方法获取要修改的字段；</p></li><li><p>通过 Set 系列方法修改成对应的值。</p></li></ol><p>如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   ppv := reflect.ValueOf(&amp;p)   ppv.Elem().Field(0).SetString("张三")   fmt.Println(p)}type person struct {   Name string   Age int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射修改一个值的规则：</p><ol><li><p>可被寻址，通俗地讲就是要向 reflect.ValueOf 函数<code>传递一个指针作为参数</code> </p></li><li><p>如果要修改 struct 结构体字段值的话，该字段需要是可导出的，而不是私有的，也就是<code>该字段的首字母为大写</code></p></li><li><p>记得使用 <code>Elem</code> 方法<code>获得指针指向的值</code>，这样才能调用<code> Set 系列</code>方法进行修改</p></li></ol><p>获取对应的底层类型：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}       pv := reflect.ValueOf(p)   fmt.Println(pv.Kind())   // struct      ppv := reflect.ValueOf(&amp;p)   fmt.Println(ppv.Kind())   // ptr    }// 变量 p 的实际类型是 person，但是 person 对应的底层类型是 struct 这个结构体类型，而 &amp;p 对应的则是指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>和 reflect.Value 不同，reflect.Type <code>是一个接口</code>，而不是一个结构体，所以只能使用它的方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Type interface {   Implements(u Type) bool// 是否实现了接口 u   AssignableTo(u Type) bool// 是否可以使用 =   ConvertibleTo(u Type) bool// 是否可以进行类型转换   Comparable() bool// 是否可以使用关系运算符进行比较      // 以下这些方法和Value结构体的功能相同   Kind() Kind   Method(int) Method   MethodByName(string) (Method, bool)   NumMethod() int   Elem() Type   Field(i int) StructField   FieldByIndex(index []int) StructField   FieldByName(name string) (StructField, bool)   FieldByNameFunc(match func(string) bool) (StructField, bool)   NumField() int}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {   Name string   Age int}func (p person) String() string{   return fmt.Sprintf("Name is %s,Age is %d", p.Name, p.Age)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历结构体的字段和方法</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   pt := reflect.TypeOf(p)       //遍历person的字段   for i:=0; i&lt;pt.NumField(); i++{      fmt.Println("字段：",pt.Field(i).Name)   }       //遍历person的方法   for i:=0; i&lt;pt.NumMethod(); i++{      fmt.Println("方法：",pt.Method(i).Name)   }}// 输出：// 字段： Name// 字段： Age// 方法： String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以通过 FieldByName 方法获取指定的字段，也可以通过 MethodByName 方法获取指定的方法，获取某个特定的字段或者方法时非常高效，而不是使用遍历。</p></blockquote><p><strong>是否实现某接口</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   pt := reflect.TypeOf(p)       // 判断是否实现了接口 fmt.Stringer 和 io.Writer   // elem 获得指针指向的值   stringerType := reflect.TypeOf((*fmt.Stringer)(nil)).Elem()   writerType := reflect.TypeOf((*io.Writer)(nil)).Elem()       fmt.Println("是否实现了fmt.Stringer：",pt.Implements(stringerType))   fmt.Println("是否实现了io.Writer：",pt.Implements(writerType))}// 是否实现了fmt.Stringer： true// 是否实现了io.Writer： false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>尽可能通过类型断言的方式判断是否实现了某接口，而不是通过反射</p></blockquote><h3 id="JSON-lt-x3D-gt-Struct"><a href="#JSON-lt-x3D-gt-Struct" class="headerlink" title="JSON <=> Struct"></a>JSON &lt;=&gt; Struct</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}       //struct to json   jsonB,err := json.Marshal(p)   if err == nil {      fmt.Println(string(jsonB))   }       //json to struct   respJSON:="{\"Name\":\"李四\",\"Age\":40}"   json.Unmarshal([]byte(respJSON), &amp;p)   fmt.Println(p)}// {"Name":"飞雪无情","Age":20}// Name is 李四,Age is 40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>JSON 字符串的 Key 和 struct 结构体的字段名称一样，比如示例中的 Name 和 Age</li><li>想把输出的 json 字符串的 Key 改为小写的 name 和 age，可以通过为 struct 字段添加 tag 的方式</li></ul><h3 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h3><p>struct tag 是一个<code>添加在 struct 字段上的标记</code> ，使用它进行辅助，可以完成一些额外的操作</p><p>比如 json 和 struct 互转：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {   Name string `json:"name"`   Age int `json:"age"`}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>重点：</p><p>json 作为 Key，是 Go 语言自带的 json 包解析 JSON 的一种==约定==</p><p>它会通过 json 这个 Key 找到对应的值，<em>用于</em>  <u>JSON 的 Key 值</u></p></blockquote><p> tag 就像是我们为 struct 字段起的别名，那么 json 包是如何获得这个 tag 的呢？</p><ul><li>反射</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">//遍历person字段中key为json的tagfor i:=0; i&lt;pt.NumField(); i++{       //  Field 方法返回一个 StructField 结构体，有一个字段是 Tag，存有字段的所有 tag   sf:=pt.Field(i)      fmt.Printf("字段%s上,json tag为%s\n",sf.Name, sf.Tag.Get("json"))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体的字段可以有多个 tag，用于不同的场景</p><ul><li>比如 json 转换、bson 转换、orm 解析等</li><li>如果有多个 tag，要使用<code>空格分隔</code></li><li>采用不同的 Key 可以获得不同的 tag</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {   Name string `json:"name" bson:"b_name"`   Age int `json:"age" bson:"b_age"`}// 遍历person字段中key为json、bson的tagfor i:=0; i&lt;pt.NumField(); i++{   sf := pt.Field(i)   fmt.Printf("字段%s上,json tag为%s\n",sf.Name, sf.Tag.Get("json"))   fmt.Printf("字段%s上,bson tag为%s\n",sf.Name, sf.Tag.Get("bson"))}// 字段Name上,key为json的tag为name// 字段Name上,key为bson的tag为b_name// 字段Age上,key为json的tag为age// 字段Age上,key为bson的tag为b_age<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现 Struct 转 JSON</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   pv := reflect.ValueOf(p)   pt := reflect.TypeOf(p)       // 自己实现的struct to json   jsonBuilder := strings.Builder{}   jsonBuilder.WriteString("{")      num := pt.NumField()       for i := 0; i&lt;num; i++{      jsonTag := pt.Field(i).Tag.Get("json") //获取json tag      jsonBuilder.WriteString("\""+jsonTag+"\"")      jsonBuilder.WriteString(":")      //获取字段的值      jsonBuilder.WriteString(fmt.Sprintf("\"%v\"",pv.Field(i)))      if i&lt;num-1{         jsonBuilder.WriteString(",")      }   }   jsonBuilder.WriteString("}")   fmt.Println(jsonBuilder.String())//打印json字符串}// {"name":"飞雪无情","age":"20"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>json 字符串的转换只是 struct tag 的一个应用场景</p><ul><li><p>完全可以把 struct tag 当成结构体中字段的元数据配置，使用它来做想做的任何事情</p></li><li><p>比如 orm 映射、xml 转换、生成 swagger 文档等</p></li></ul><h3 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h3><p><a href="https://blog.golang.org/laws-of-reflection">反射的三大定律</a>：</p><ol><li><p>任何接口值，interface{} 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</p></li><li><p>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的<code>可逆性</code>，通过 reflect.Value 结构体的 Interface 方法获得。</p></li><li><p>要修改反射的对象，该值必须可设置，也就是<code>可寻址</code>。</p></li></ol><blockquote><p>提示：</p><p>任何类型的变量都可以转换为空接口 intferface{}，所以第 1 条定律中函数 reflect.ValueOf 和 reflect.TypeOf 的参数就是 interface{}，表示可以把任何类型的变量转换为反射对象。</p><p>在第 2 条定律中，reflect.Value 结构体的 Interface 方法返回的值也是 interface{}，表示可以把反射对象还原为对应的类型变量。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在反射中：</p><ul><li>reflect.Value 对应的是<code>变量的值</code>，如果你需要进行和变量的<em><strong>值有关</strong></em> 的操作，应该优先使用 reflect.Value比如获取变量的值、修改变量的值等。</li><li>reflect.Type 对应的是<code>变量的类型</code>，如果你需要进行和变量的<em><strong>类型本身有关</strong></em> 的操作，应该优先使用 reflect.Type，比如获取结构体内的字段、类型拥有的方法集等。</li></ul><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>原因：</p><ul><li>Go 的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<code>强类型</code>的<code>静态</code>语言</li><li>强类型意味着，一旦定义了，类型就不能改变</li><li>静态意味着，在运行前，做了类型检查</li><li>同时出于安全考虑，Go 语言是<code>不允许两个指针类型进行转换</code></li></ul><h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p>**如 <em>int 不能转为 <em>float64</em></em> ：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i:= 10   ip:=&amp;i   var fp *float64 = (*float64)(ip)   fmt.Println(fp)}// cannot convert ip (type * int) to type * float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但如果还是需要转换呢？？？</strong> </p><p><code>unsafe.Pointer</code> 是一种特殊意义的指针，==可以表示任意类型的地址==，类似 C 语言里的 void* 指针，**<u><em>是全能型的</em></u>**</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i:= 10   ip:=&amp;i       var fp *float64 = (*float64)(unsafe.Pointer(ip))       *fp = *fp * 3   fmt.Println(i)}// 30// 原来变量 i 的值也被改变了，变为 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// uintptr is an integer type that is large enough // to hold the bit pattern of any pointer.// 足够大，可以表示任何指针type uintptr uintptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>uintptr 可以对<code>指针偏移</code><em>进行计算</em>，这样就<strong>可以访问特定的内存</strong>，<em>达到对特定内存读写的目的</em>，真正内存级别的操作</p></blockquote><p><strong>通过指针偏移修改 struct 结构体内的字段</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := new(person)       // Name是person的第一个字段不用偏移，即可通过指针修改   pName := (*string)(unsafe.Pointer(p))   *pName = "will"       // Age并不是person的第一个字段，所以需要进行偏移，这样才能正确定位到Age字段这块内存，才可以正确的修改   pAge := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+unsafe.Offsetof(p.Age)))   *pAge = 20   fmt.Println(*p)}type person struct {   Name string   Age int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>因为 Age 字段不是 person 的第一个字段，要修改它必须要进行指针偏移运算</li><li>所以需要先把指针变量 p 通过 unsafe.Pointer 转换为 uintptr，这样才能进行地址运算</li><li>偏移量可以通过函数 unsafe.Offsetof 计算出来，该函数返回的是一个 uintptr 类型的偏移量</li></ul><h3 id="unsafe-Sizeof"><a href="#unsafe-Sizeof" class="headerlink" title="unsafe.Sizeof"></a>unsafe.Sizeof</h3><p>Sizeof 函数可以返回<code>一个类型所占用的内存大小</code> ，这个大小<strong>只与类型有关</strong>，<em>和类型对应的变量存储的内容大小无关</em></p><ul><li>比如 bool 型占用一个字节、int8 也占用一个字节</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(unsafe.Sizeof(true))fmt.Println(unsafe.Sizeof(int8(0)))fmt.Println(unsafe.Sizeof(int16(10)))fmt.Println(unsafe.Sizeof(int32(10000000)))fmt.Println(unsafe.Sizeof(int64(10000000000000)))fmt.Println(unsafe.Sizeof(int(10000000000000000)))fmt.Println(unsafe.Sizeof(string("will")))fmt.Println(unsafe.Sizeof([]string{"李四","张三"}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一个 struct 结构体的内存占用大小，等于它包含的字段类型内存占用大小之和。</p></blockquote><h3 id="指针转换规则"><a href="#指针转换规则" class="headerlink" title="指针转换规则"></a>指针转换规则</h3><p><img src="https://raw.githubusercontent.com/MicroWiller/photobed/master/PointerExchange.png"></p><ol><li>任何类型的 *T 都可以转换为 unsafe.Pointer</li><li>unsafe.Pointer 也可以转换为任何类型的 *T</li><li>unsafe.Pointer 可以转换为 uintptr</li><li>uintptr 也可以转换为 unsafe.Pointer</li></ol><ul><li>unsafe.Pointer 主要用于指针类型的转换，是各个<code>指针类型转换</code>的桥梁</li><li>uintptr 主要用于<code>指针运算</code>，尤其是通过偏移量定位不同的内存</li></ul><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p> <a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">atomic.Value 的前世今生</a>：“原子的”存储（Store）和加载（Load）<strong>任意类型</strong>的值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// A Value provides an atomic load and store of a consistently typed value.// The zero value for a Value returns nil from Load.// Once Store has been called, a Value must not be copied.//// A Value must not be copied after first use.type Value struct {v interface{}}// Load returns the value set by the most recent Store.// It returns nil if there has been no call to Store for this Value.func (v *Value) Load() (x interface{}) {......}// Store sets the value of the Value to x.// All calls to Store for a given Value must use values of the same concrete type.// Store of an inconsistent type panics, as does Store(nil).func (v *Value) Store(x interface{}) {    .....}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main.gofunc Fibonacci(n int) int {   if n &lt; 0 {      return 0   }   if n == 0 {      return 0   }   if n == 1 {      return 1   }   return Fibonacci(n-1) + Fibonacci(n-2)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main_test.gofunc TestFibonacci(t *testing.T) {   //预先定义的一组斐波那契数列作为测试用例   fsMap := map[int]int{}   fsMap[0] = 0   fsMap[1] = 1   fsMap[2] = 1   fsMap[3] = 2   fsMap[4] = 3   fsMap[5] = 5   fsMap[6] = 8   fsMap[7] = 13   fsMap[8] = 21   fsMap[9] = 34   for k, v := range fsMap {      fib := Fibonacci(k)      if v == fib {         t.Logf("结果正确:n为%d,值为%d", k, fib)      } else {         t.Errorf("结果错误：期望%d,但是计算的值是%d", v, fib)      }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行如下命令，进行单元测试：go test -v ./ch18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go test -v ./ch18&nbsp;=== RUN&nbsp; &nbsp;TestFibonacci&nbsp; &nbsp; main_test.go:21: 结果正确:n为0,值为0&nbsp; &nbsp; main_test.go:21: 结果正确:n为1,值为1&nbsp; &nbsp; main_test.go:21: 结果正确:n为6,值为8&nbsp; &nbsp; main_test.go:21: 结果正确:n为8,值为21&nbsp; &nbsp; main_test.go:21: 结果正确:n为9,值为34&nbsp; &nbsp; main_test.go:21: 结果正确:n为2,值为1&nbsp; &nbsp; main_test.go:21: 结果正确:n为3,值为2&nbsp; &nbsp; main_test.go:21: 结果正确:n为4,值为3&nbsp; &nbsp; main_test.go:21: 结果正确:n为5,值为5&nbsp; &nbsp; main_test.go:21: 结果正确:n为7,值为13--- PASS: TestFibonacci (0.00s)PASSok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;(cached)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五点规则"><a href="#五点规则" class="headerlink" title="五点规则"></a>五点规则</h3><ol><li><p>含有单元测试代码的 go 文件必须<code>以 _test.go 结尾</code>，Go 语言测试工具只认符合这个规则的文件</p></li><li><p>单元测试文件名 _test.go <code>前面的部分</code>，最好是被测试的函数所在的 go 文件的文件名</p><ul><li>比如以上示例中单元测试文件叫 main_test.go，因为测试的 Fibonacci 函数在 main.go 文件里</li></ul></li><li><p>单元测试的函数名必须<code>以 Test 开头</code>，是可导出的、公开的函数</p></li><li><p>测试函数的签名必须<code>接收一个指向 testing.T 类型的指针</code>，并且<code>不能返回任何值</code></p></li><li><p>函数名最好是 <code>Test + 要测试的函数名</code></p><ul><li>比如例子中是 TestFibonacci，表示测试的是 Fibonacci 这个函数。</li></ul></li></ol><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go test -v --coverprofile=ch18.cover ./ch18//1. go test -v -coverpkg=./... -coverprofile=profile.cov ./...//2. go tool cover -func profile.cov<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以得到一个单元测试覆盖率文件，运行这行命令还可以同时看到测试覆盖率</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PASScoverage: 85.7% of statementsok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;0.367s&nbsp; coverage: 85.7% of statements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>查看详细的单元测试覆盖率报告</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go tool cover -html=ch18.cover -o=ch18.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令运行后，会在当前目录下生成一个 ch18.html 文件，使用浏览器打开它，查看内容</p><h3 id="race-检测"><a href="#race-检测" class="headerlink" title="race 检测"></a>race 检测</h3> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run -race main.go <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编译器会通过探测所有的内存访问，监听其内存地址的访问（读或写）</li><li>在应用运行时就能够发现对共享变量的访问和操作，进而发现问题并打印出相关的警告信息</li></ul><p>需要注意的一点是，<code>go run -race</code> 是运行时检测，并不是编译时。且 race 存在明确的性能开销，通常是正常程序的<strong>十倍</strong>，因此不要想不开在生产环境打开这个配置，很容易翻车。</p><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main_test.gofunc BenchmarkFibonacci(b *testing.B){   for i:=0;i&lt;b.N;i++{      Fibonacci(10)   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>基准测试函数必须<code>以 Benchmark 开头</code>，必须是可导出的</li><li>函数的签名必须接收一个<code>指向 testing.B 类型的指针</code>，并且不能返回任何值</li><li>最后的 <code>for 循环</code> 很重要，<em>被测试的代码要放到循环里</em></li><li><code>b.N</code> 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#  -bench 表示，接受一个表达式作为参数，以匹配基准测试的函数# "." 表示运行所有基准测试➜ go test -bench=. ./ch18goos: darwingoarch: amd64pkg: gotour/ch18BenchmarkFibonacci-8&nbsp; &nbsp; &nbsp;3461616&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;343 ns/opPASSok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;2.230s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>BenchmarkFibonacci-8 ，后面的 -8 ，表示运行基准测试时对应的 GOMAXPROCS 的值</p></li><li><p>基准测试的时间默认是 1 秒，也就是 1 秒调用 3461616 次、每次调用花费 343 纳秒</p></li><li><p>如果想让测试运行的时间更长，可以通过 -benchtime 指定，比如 3 秒</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go test -bench=. -benchtime=3s ./ch18<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="计时方法"><a href="#计时方法" class="headerlink" title="计时方法"></a>计时方法</h3><blockquote><p>避免因为准备数据耗时造成的干扰</p></blockquote><p>进行基准测试之前会做一些准备，比如构建测试数据等，这些准备也需要消耗时间，所以需要<code>把这部分时间排除在外</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">func BenchmarkFibonacci(b *testing.B) {   n := 10   b.ResetTimer() //重置计时器   for i := 0; i &lt; b.N; i++ {      Fibonacci(n)   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>除了 ResetTimer 方法外，还有 StartTimer 和 StopTimer 方法，灵活地控制什么时候开始计时、什么时候停止计时。</li></ul><h3 id="内存统计"><a href="#内存统计" class="headerlink" title="内存统计"></a>内存统计</h3><p>统计每次操作分配内存的次数，以及每次操作分配的字节数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func BenchmarkFibonacci(b *testing.B) {   n := 10   b.ReportAllocs() //开启内存统计   b.ResetTimer() //重置计时器   for i := 0; i &lt; b.N; i++ {      Fibonacci(n)   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go test -bench=.&nbsp; ./ch18goos: darwingoarch: amd64pkg: gotour/ch18BenchmarkFibonacci-8&nbsp; 2486265&nbsp; 486 ns/op&nbsp;&nbsp;0 B/op&nbsp; 0 allocs/opPASSok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;2.533s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>0 B/op</code>，表示每次操作分配了多少字节的内存</li><li><code>0 allocs/op</code>，表示每次操作分配内存的次数</li></ul><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><h4 id="逃逸实列"><a href="#逃逸实列" class="headerlink" title="逃逸实列"></a>逃逸实列</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch19/main.gofunc newString() *string{   s:=new(string)   *s = "will"   return s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过 new 函数申请了一块内存；</p></li><li><p>然后把它赋值给了指针变量 s；</p></li><li><p>最后通过 return 关键字返回。</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:16:8: new(string) escapes to heap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>-m 表示打印出逃逸分析信息</li><li>-l 表示禁止内联</li><li><strong>指针</strong>作为<em>函数返回值</em> 的时候，一定会发生逃逸</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func newString() string{   s:=new(string)   *s = "will"   return *s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次通过命令查看以上代码的逃逸分析，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:14:8: new(string) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="被已经逃逸的指针-引用-的变量-也会发生逃逸"><a href="#被已经逃逸的指针-引用-的变量-也会发生逃逸" class="headerlink" title="被已经逃逸的指针 引用 的变量 也会发生逃逸"></a>被已经逃逸的指针 引用 的变量 也会发生逃逸</h4><p>==并不是不使用指针就不会发生逃逸==</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println("will")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:13:13: ... argument does not escapech19/main.go:13:14: "will" escapes to heapch19/main.go:17:8: new(string) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>「will」<strong>逃逸</strong>到了堆上，这是因为「will」这个字符串<strong>被已经逃逸的指针变量</strong> <em>引用</em>，所以它也跟着逃逸了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (p *pp) printArg(arg interface{}, verb rune) {   p.arg = arg   //省略其他无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="被-slice、map-和-chan，这三种类型引用的指针也会发生逃逸"><a href="#被-slice、map-和-chan，这三种类型引用的指针也会发生逃逸" class="headerlink" title="被 slice、map 和 chan，这三种类型引用的指针也会发生逃逸"></a>被 slice、map 和 chan，这三种类型引用的指针也会发生逃逸</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   m:=map[int]*string{}   s:="will"   m[0] = &amp;s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp; gotour go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:16:2: moved to heap: sch19/main.go:15:20: map[int]*string literal does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>变量 m 没有逃逸，<strong>反而</strong>被变量 m 引用的变量 s 逃逸到了堆上</li><li>所以被map、slice 和 chan 这三种类型 引用 的指针一定会发生逃逸的</li></ul><blockquote><p>指针虽然可以减少内存的拷贝，但它同样会引起逃逸，所以要根据实际情况选择是否使用指针。</p></blockquote><h4 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h4><ol><li>尽可能避免逃逸，因为栈内存效率更高，还不用 GC。比如<strong>小对象的传参</strong>，array 要比 slice 效果好。</li><li>如果避免不了逃逸，还是在堆上分配了内存，那么对于频繁的内存申请操作，我们要学会<strong>重用内存</strong>，比如使用 sync.Pool</li><li>选用合适的算法，达到高性能的目的，比如<strong>空间换时间</strong> </li><li>尽可能避免使用锁、并发加锁的范围要尽可能小</li><li>使用 StringBuilder 做 string 和 [ ] byte 之间的转换</li><li>defer 嵌套不要太多</li></ol><blockquote><p>小提示：性能优化的时候，要结合基准测试，来验证自己的优化是否有提升。</p></blockquote><h3 id="并发基准测试"><a href="#并发基准测试" class="headerlink" title="并发基准测试"></a>并发基准测试</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func BenchmarkFibonacciRunParallel(b *testing.B) {   n := 10   b.RunParallel(func(pb *testing.PB) {      for pb.Next() {         Fibonacci(n)      }   })}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 RunParallel 方法运行并发基准测试</li><li>RunParallel 方法会创建多个 goroutine，并将 b.N 分配给这些 goroutine 执行</li></ul><h3 id="接口-依赖注入"><a href="#接口-依赖注入" class="headerlink" title="接口+依赖注入"></a>接口+依赖注入</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type transaction struct {    ID       string    BuyerID  int    SellerID int    Amount   float64    createdAt time.Time    Status TransactionStatus}func (t *transaction) Execute() bool {    if t.Status == Executed {        return true    }    if time.Now() - t.createdAt &gt; 24.hours { // 交易有有效期        t.Status = Expired        return false    }    client := BankClient.New(config.token) // 调用银行的 SDK 执行转账    if err := client.TransferMoney(id, t.BuyerID, t.SellerID, t.Amount); err != nil {        t.Status = Failed        return false    }    t.Status = Executed    return true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最重要的功能集中在<code>Execute()</code>函数中，但它却不好测试，因为它有两个外部依赖：</p><ol><li>行为不确定的<code>time.Now</code>函数，每一次调用都会产生不同的结果</li><li>银行提供的转账 SDK，我们不可能每次测试都去真的调用一下，那测试成本也忒高了</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 先将代码里使用到的方法抽象成一个接口type Transferer interface {    TransferMoney(id int, buyerID int, sellerID int, amount float64) error}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>放到<code>transaction</code>的成员属性中，重构后的<code>transaction</code>类及其构造函数就变成了这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type transaction struct {    ID       string    BuyerID  int    SellerID int    Amount   float64    createdAt time.Time    Status TransactionStatus    // 增加了一个存放接口的属性    transferer Transferer}func New(buyerID, sellerID int, amount float64, transferer Transferer) *transaction {    return &amp;transaction{        ID:         IdGenerator.generate(),        BuyerID:    buyerID,        SellerID:   sellerID,        Amount:     amount,        createdAt:  time.Now(),        Status:     TO_BE_EXECUTD,        transferer: transferer, // 注入进 transaction 类中    }}func (t *transaction) Execute() bool {    //...    //不直接创建，而是使用别人注入的接口实例    t.transferer.TransferMoney(id, t.BuyerID, t.SellerID, t.Amount)    //...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，可以在单元测试中就能够很方便的替换掉那个成本高昂的支付接口的调用了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 定义一个满足 Transferer 接口的 mock 类type MockedClient struct {    responseError error // 实例化的时候可以将期望的返回值保存进来}func (m *MockedClient) TransferMoney(id int, buyerID int, sellerID int, amount float64) error {    return m.responseError}func Test_transaction_Execute(t *testing.T) {    // 实例化一个可以自由控制结果的 client    transferer := &amp;MockedClient{        responseError: errors.New("insufficient balance"),    }    tnx := New(buyerID, sellerID, amount, transferer)    if succeeded := tnx.Execute(); succeeded != false {        t.Errorf("Execute() = %v, want %v", succeeded, false)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">var nowFn = time.Now //一个全局变量，用来解耦time.Now的生产者和消费者func (t *transaction) Execute() bool {    if t.Status == Executed {        return true    }    if nowFn() - t.createdAt &gt; 24.hours { // 不直接调用time.Now()        t.Status = Expired        return false    }    //...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，单元测试就能随心所欲的改变“当前时间”了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Test_expired_transaction_Execute(t *testing.T) {    // 用同样的函数签名改写业务中需要的时间函数    // 这里能改变私有的全局变量是因为测试代码跟业务代码处于同一个包中    nowFn = func() time.Time {        return time.Now().Add(-24 * time.Hour)    }    // 依旧需要实例化一个假的的 client    transferer := &amp;MockedClient{        responseError: nil,    }    tnx := New(buyerID, sellerID, amount, transferer)    //...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐式的复用了<code>time.Now</code>的<strong>函数签名</strong>，将它当做一种“接口类型”来使用</p><p>参考：<a href="https://blog.betacat.io/post/2020/03/a-pattern-for-writing-testable-go-code/#mock-timenow">编写可测试 Go 代码的一种模式</a> </p><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p><a href="https://segmentfault.com/a/1190000016412013">pprof</a>：runtime / net</p><p><a href="https://github.com/uber-archive/go-torch">go-torch</a> </p><p> <a href="https://mp.weixin.qq.com/s/yZUE8N-Qb-AB81DgA1cV_w">golang性能诊断</a>：<code>pprof</code> / <code>trace</code> / <code>linux</code></p><h2 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h2><p>一个典型的 HTTP 服务应该如图所示：</p><p><img src="/go.assets/image-20210616203918882.png" alt="image-20210616203918882"></p><p>http服务器的工作就在于: </p><ul><li>如何接受来自客户端的请求(socket / router)</li><li>并向客户端返回响应</li></ul><p> Go HTTP 标准库  <code>net/http</code> 的实现原理: </p><p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/StanderdLibOfHttp.png"></p><ol><li>注册处理器到一个 hash 表中，可以通过键值路由匹配；</li><li>注册完之后就是开启循环监听，每监听到一个连接就会创建一个 Goroutine；</li><li>在创建好的 Goroutine 里面会循环的等待接收请求数据，然后根据请求的地址去处理器路由表中匹配对应的处理器，然后将请求交给处理器处理；</li></ol><p>这样做在连接数比较少的时候是没什么问题的，但是在连接数非常多的时候，每个连接都会创建一个 Goroutine 就会给系统带来一定的压力。</p><p>这也就造成了 <code>net/http</code>在处理高并发时的瓶颈。</p><p><code>fasthttp</code> : </p><p><img src="/go.assets/image-20210616205711264.png" alt="image-20210616205711264"></p><ol><li>启动监听；</li><li>循环监听端口获取连接；</li><li>获取到连接之后首先会去 ready 队列里获取 workerChan，获取不到就会去对象池获取；</li><li>将监听的连接传入到 workerChan 的 channel 中；</li><li>workerChan 有一个 Goroutine 一直循环获取 channel 中的数据，获取到之后就会对请求进行处理然后返回。</li></ol><p>实现方法: (类似于协程池)</p><ul><li>workerChan 其实就是一个连接处理对象，这个对象里面有一个 channel 用来传递连接；</li><li>每个 workerChan 在后台都会有一个 Goroutine 循环获取 channel 中的连接，然后进行处理。</li><li>如果没有设置最大同时连接处理数的话，默认是 <code>256 * 1024</code>个。</li><li>这样可以在并发很高的时候还可以同时保证对外提供服务。</li></ul><p>参考:</p><p><a href="https://www.luozhiyun.com/archives/574">fasthttp：比net/http快十倍的Go框架(server 篇)</a></p><p><a href="https://www.luozhiyun.com/archives/561">一文说透 Go 语言 HTTP 标准库</a> </p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p><a href="https://www.flysnow.org/2021/02/28/golang-embed-for-web.html">embed</a>：1.16 新增的embed在各流行Web框架中的应用</p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1362784031968149504&amp;__biz=MzI3MjU4Njk3Ng==#wechat_redirect">Gin实战</a>：Go 语言如何玩转 RESTful API 服务？？</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484393&amp;idx=1&amp;sn=4a27e735672c820ac266484333a806b7&amp;chksm=eb310266dc468b7081405477779b75d2b565ec8255143338f6b037f1725f91a7a468b890f7b1&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">Restful API</a> ：<code>net/http</code>请求的URL需要一个个去注册，Gin提供了URL路由的<strong>模糊匹配</strong>，比如URL路径中的参数</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484397&amp;idx=1&amp;sn=05d25b404f117cca76dd2097d3befab3&amp;chksm=eb310262dc468b74724a03d345e9b3ef21b39a38682836f4b00683d7b04fc7264a41649d6a0e&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">路由参数</a>：<code>/users/id</code> 通过这个<code>id</code>参数，获取对应的用户信息</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {    r := gin.Default()    r.GET("/users/:id", func(c *gin.Context) {        id := c.Param("id")        c.String(200, "The user id is  %s", id)    })    r.Run(":8080")}// 输入 http://localhost:8080/users/123// The user id is  123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">Pattern: /users/:id/users/123          匹配/users/哈哈        匹配/users/123/go      不匹配/users/             不匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">Pattern: /users/*id/users/123         匹配/users/哈哈        匹配/users/123/go      匹配/users/            匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484116&amp;idx=1&amp;sn=8abf9049e47386d503d7b653541cce16&amp;chksm=eb31035bdc468a4d75b42d2f3ad82154b88665aeb46b083f466499942bb41f3483117edc1e24&amp;scene=21#wechat_redirect">HTTP路由httprouter</a>：自定义路由</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484405&amp;idx=1&amp;sn=39eead58bac34c9b93e37f0832537e53&amp;chksm=eb31027adc468b6c9f6a8df901fc45dca2c2ad1d528e6c93a6193e15c6e8df322c72a4cdc811&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">URL查询参数的获取和原理分析</a>：Gin获取查询参数 <code>Query</code>源码分析 </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484410&amp;idx=1&amp;sn=807f89e1d6ba0f96558a66b82b08358b&amp;chksm=eb310275dc468b63fd5f94a772413edb0c223f0bae213055f14494dc0ff76e99a66b98ffe3ac&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">接收数组和 Map</a>：<code>QueryArray</code>  / <code>QueryMap</code> </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484425&amp;idx=1&amp;sn=2a604e79d19c091410291d690d308dd5&amp;chksm=eb310586dc468c90eb0de31503ca6c2da9fa2b29ccb22eb5f3e37ed26d3b9a60fdbc7d6fba59&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">获取Form表单参数</a>：</p><table><thead><tr><th align="left">查询参数</th><th align="left">Form表单</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Query</td><td align="left">PostForm</td><td align="left">获取key对应的值，不存在为空字符串</td></tr><tr><td align="left">GetQuery</td><td align="left">GetPostForm</td><td align="left">多返回一个key是否存在的结果</td></tr><tr><td align="left">QueryArray</td><td align="left">PostFormArray</td><td align="left">获取key对应的数组，不存在返回一个空数组</td></tr><tr><td align="left">GetQueryArray</td><td align="left">GetPostFormArray</td><td align="left">多返回一个key是否存在的结果</td></tr><tr><td align="left">QueryMap</td><td align="left">PostFormMap</td><td align="left">获取key对应的map，不存在返回空map</td></tr><tr><td align="left">GetQueryMap</td><td align="left">GetPostFormMap</td><td align="left">多返回一个key是否存在的结果</td></tr><tr><td align="left">DefaultQuery</td><td align="left">DefaultPostForm</td><td align="left">key不存在的话，可以指定返回的默认值</td></tr></tbody></table><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484434&amp;idx=1&amp;sn=0bd93e3ab59e4bf5f9ed2a965395647e&amp;chksm=eb31059ddc468c8b4bd003f680aaacf9a7cf2e9d539a5e20a7e4dca97e53cf1bf3d323aac923&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">分组路由源代码分析</a>：路由中间件 / 分组路由嵌套</p><h2 id="优雅重启"><a href="#优雅重启" class="headerlink" title="优雅重启"></a>优雅重启</h2><p><a href="https://mp.weixin.qq.com/s/yryqf8SCzvt-BFj8j5bZ2w">一文讲懂服务的优雅重启和更新</a> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GracefulStopOfGo-zero.png" style="zoom:67%;"><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>编译Proto文件，并生成语句：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">protoc --go_out=plugins=grpc:. ./proto/*.proto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考：</p><p><a href="https://golang2.eddycjy.com/posts/ch3/03-simple-grpc/">gRPC 的使用和了解</a> </p><p><a href="https://juejin.cn/post/6887388610367553549">gRPC服务注册发现及负载均衡的实现方案与源码解析</a> ：<code>Resolver</code> / <code>Balancer</code> / <code>RoundRobin</code> </p><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Go scheduler 的主要功能是：针对在处理器上运行的 <code>OS线程</code> <em>分发可运行</em> 的 Goroutine</p><p>而我们一提到调度器，就离不开三个经常被提到的缩写，分别是：</p><p><a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L404">G</a>：Goroutine，实际上我们每次调用 go func 就是生成了一个 G。</p><p><a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L486">M</a>：Machine，OS线程。它由操作系统的“调度器” 调度和管理。</p><p><a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/runtime2.go#L576">P</a>：Processor，处理器。一般 P 的数量就是处理器的核数，可以通过 GOMAXPROCS 进行修改。</p><p>这三者交互实际来源于 Go 的 <a href="https://golang.design/go-questions/sched/mn-model/">M:N调度模型</a>。</p><p>也就是 M 必须与 P 进行绑定，一一对应，然后不断地在 M 上循环寻找 N (可运行的 G ) 来执行相应的任务。</p><h3 id="三足鼎力"><a href="#三足鼎力" class="headerlink" title="三足鼎力"></a>三足鼎力</h3><p>GPM 三足鼎力，共同成就 Go scheduler。G 需要在 M 上才能运行，M 依赖 P 提供的资源，P 则持有待运行的 G。</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/GMP_WorkFlow_magic.png" alt="GMP_WorkFlow_magic"></p><ol><li>当我们执行 go func() 时，实际上就是创建一个全新的 Goroutine，我们称它为 G。</li><li>新创建的 G 会被放入 P 的本地队列（Local Queue）或全局队列（Global Queue）中，准备下一步的动作。需要注意的一点，这里的 P 指的是创建 G 的 P。</li><li>唤醒或创建 M 以便执行 G。</li><li>不断地进行事件循环</li><li>寻找在可用状态下的 G 进行执行任务</li><li>清除后，重新进入事件循环</li></ol><p>在描述中有提到<code>全局</code>和<code>本地</code>这两类队列，其实在功能上来讲都是用于存放正在等待运行的 G，但是不同点在于，本地队列有数量限制，不允许超过 <strong>256</strong> 个。</p><p>并且在新建 G 时，会优先选择 P 的本地队列，如果本地队列满了，则将 P 的 <em>本地队列的一半</em> 的 G 移动到全局队列。</p><p>这可以理解为调度资源的共享和再平衡。</p><blockquote><p>调度器在调度时，会从处理器(P)的 <code>runq</code> 队列中，选择 <em>队列头</em> 的 Goroutine 放到线程 M 上执行。</p></blockquote><h3 id="窃取行为"><a href="#窃取行为" class="headerlink" title="窃取行为"></a>窃取行为</h3><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/GMP_Steal.png" alt="GMP_Steal"></p><p>在这个例子中，P2 在本地队列中找不到可以运行的 G，它会执行 work-stealing 调度算法，随机选择其它的处理器 P1，并从 P1 的本地队列中窃取了三个 G 到它自己的本地队列中去。</p><p>至此，P1、P2 都拥有了可运行的 G，P1 多余的 G 也不会被浪费，调度资源将会更加平均的在多个处理器中流转。</p><h3 id="GMP-amp-Thread"><a href="#GMP-amp-Thread" class="headerlink" title="GMP &amp; Thread"></a>GMP &amp; Thread</h3><ul><li><p>调度器通过使用与 CPU 数量相等的线程（CPU数量 == 线程数量）减少线程频繁切换的内存开销</p></li><li><p>同时，在每一个线程上，执行额外开销更低的 <code>Goroutine</code> 来，<strong>降低</strong>操作系统和硬件的负载</p></li></ul><p><a href="http://c.biancheng.net/view/94.html">Go语言GOMAXPROCS</a>:</p><ul><li>默认情况下，四核机器会创建四个活跃的操作系统线程，<em>每一个线程都对应一个运行时中</em> 的 <a href="https://draveness.me/golang/tree/runtime.m"><code>runtime.m</code></a> 结构体</li><li>传统逻辑中，开发者需要 <em>维护</em> <strong>线程池中线程</strong> 与 <strong>CPU核心数量</strong> 的对应关系。</li><li>GO中，可以在程序中使用 <a href="https://draveness.me/golang/tree/runtime.GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a> 来改变最大的活跃线程数。</li><li>GOMAXPROCS 同时也是一个 _环境变量_，在应用程序启动前设置环境变量也可以起到相同的作用。</li></ul><p> <a href="https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw">Goroutine 数量控制在多少合适，会影响 GC 和调度？</a> </p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GoWithMemoryLayout.png" style="zoom:67%;"><p>对应的数据结构 <a href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>、<a href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a>、<a href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> </p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>golang10次内存泄漏，8次goroutine泄漏，1次是真正内存泄漏，还有1次是cgo导致的内存泄漏</strong>。</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/memory_out_example.png" style="zoom:67%;"><ul><li>RES：常驻内存</li></ul><h3 id="泄漏情况"><a href="#泄漏情况" class="headerlink" title="泄漏情况"></a>泄漏情况</h3><p>1、可能服务分配的内存小了</p><p>2、资源没有关闭：http请求返回的rsp的body，还有一些打开的文件资源等（defer关掉）</p><p>3、goroutine泄漏</p><p>4、cgo导致的内存泄漏（cgo都是<strong>单独开一个线程</strong>进行处理的，这种是runtime不能管理的）</p><h3 id="分析命令"><a href="#分析命令" class="headerlink" title="分析命令"></a>分析命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go tool pprof -inuse_space http://ip:amdin_port/debug/pprof/heap# -inuse_space：当前服务使用的内存情况# -alloc_space：指服务启动以来总共分配的内存情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http://ip:admin_port/debug/pprof/heap?debug=1# 把当前内存分配的详情文件抓下来，本地会生成一个叫heap?debug=1的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http://ip:admin_port/debug/pprof/goroutine?debug=1# debug=1：获取服务当前goroutine的数目和大致信息wget http://ip:admin_port/debug/pprof/goroutine?debug=2# debug=2：获取服务当前goroutine的详细信息# 分别在本地生成了goroutine？debug=1和goroutine？debug=2文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 服务线程挂的子线程有多少# -m：显示所有的线程# -p：pid进程使用cpu的时间# -o：该参数后是用户自定义格式ps -mp 进程 -o THREAD,tid,time | wc -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://mp.weixin.qq.com/s/FyHEiaa-UfyLStMKl2VFGA">golang：快来抓住让我内存泄漏的“真凶”！</a>  </p><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>Golang中time包有两个定时器，分别为ticker 和 timer。两者都可以实现定时功能，但各自都有自己的使用场景。</p><p>区别：</p><ul><li><strong>ticker</strong>定时器表示每隔一段时间就执行一次，一般可执行多次。</li><li><strong>timer</strong>定时器表示在一段时间后执行，默认情况下只执行一次，如果想再次执行的话，每次都需要调用 time.Reset()方法，此时效果类似ticker定时器。同时也可以调用stop()方法取消定时器</li><li>timer定时器比ticker定时器多一个Reset()方法，两者都有Stop()方法，表示停止定时器,底层都调用了stopTimer()函数。</li></ul><p><a href="https://blog.csdn.net/qq_39397165/article/details/108698640">timer 泄漏代码</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (b *BrokerImpl) broadcast(msg interface{}, subscribers []chan interface{}) {count := len(subscribers)concurrency := 1switch {case count &gt; 1000:concurrency = 3case count &gt; 100:concurrency = 2default:concurrency = 1}pub := func(start int) {for j := start; j &lt; count; j += concurrency {select {case subscribers[j] &lt;- msg:         case &lt;-time.After(time.Millisecond * 5): // 泄漏case &lt;-b.exit:return}}}for i := 0; i &lt; concurrency; i++ {go pub(i)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修复</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (b *BrokerImpl) broadcast(msg interface{}, subscribers []chan interface{}) {count := len(subscribers)concurrency := 1switch {case count &gt; 1000:concurrency = 3case count &gt; 100:concurrency = 2default:concurrency = 1}//采用Timer 而不是使用time.After 原因：time.After会产生内存泄漏 在计时器触发之前，垃圾回收器不会回收Timerpub := func(start int) {idleDuration := 5 * time.MillisecondidleTimeout := time.NewTimer(idleDuration)// **defer idleTimeout.Stop()   // **for j := start; j &lt; count; j += concurrency {            // **if !idleTimeout.Stop(){select {case &lt;- idleTimeout.C:default:}}idleTimeout.Reset(idleDuration)  // **select {case subscribers[j] &lt;- msg:case &lt;-idleTimeout.C:case &lt;-b.exit:return}}}for i := 0; i &lt; concurrency; i++ {go pub(i)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://flydk.gitbooks.io/go/content/ch8/ch8-07.html">ticker 泄漏</a> </p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>参考： <a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">7.2 垃圾收集器</a> </p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p> <a href="https://www.cnblogs.com/457220157-FTD/p/14703692.html">golang面向对象分析</a>：封装 / 继承 / 多态</p><p>封装：struct</p><p>继承：</p><ul><li>​匿名组合    (Pseudo is-a)</li><li>非匿名组合    (has-a)</li></ul><p>多态：接口</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a href="https://gocn.vip/topics/Go488nfroE">字符串处理细节</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483777&amp;idx=1&amp;sn=d3d108abe68c282a4d291a432559f2cc&amp;scene=21#wechat_redirect">nil切片和空切片</a>：<code>数组指针地址都分别指向哪儿</code> </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483698&amp;idx=1&amp;sn=352a5cddf20fe95f5ec26bfc9a6de64b&amp;scene=21#wechat_redirect">json包变量不加tag会怎么样</a>：<code>Marshal</code> [Struct Tag](#Struct Tag)</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485846&amp;idx=2&amp;sn=033931d22730a24128915d8498c9e3fb&amp;source=41#wechat_redirect">这样理解 Go 闭包，就不会出错了 (qq.com)</a>：将引用环境和函数结合的使用方法 / 变量什么情况下 是指针，什么情况下为值</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483686&amp;idx=1&amp;sn=e48c51107191f02da5751a19a54f7d41&amp;chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&amp;token=2092782362&amp;lang=zh_CN&amp;scene=21#wechat_redirect">什么是内存逃逸</a>：<code>从栈逃到堆上</code> / <code>典型场景</code></p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483692&amp;idx=1&amp;sn=d5d34fad7a4553e0b9d5714385b7af48&amp;chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&amp;token=961196008&amp;lang=zh_CN&amp;scene=21#wechat_redirect">怎么避免内存逃逸</a>：<code>noescape</code></p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483669&amp;idx=1&amp;sn=88f754ddabc04eb3f66ba8ac37ee1461&amp;chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&amp;token=2092782362&amp;lang=zh_CN&amp;scene=21#wechat_redirect">字符串转成byte数组</a>： <a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D">零拷贝</a>  </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483735&amp;idx=1&amp;sn=6ab8ac319dc1857acf44c9bb9d21c7c3&amp;scene=21#wechat_redirect">对已经关闭的的chan进行读写，会怎么样</a>：<code>读：关闭前是否有值</code> / <code>写：Panic</code>  </p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483717&amp;idx=1&amp;sn=0c0385234cd70d72d424eb7097ebfe9a&amp;scene=21#wechat_redirect">对未初始化的的 chan 进行读写，会怎么样</a>：<code>都会阻塞</code></p><p><a href="https://zhuanlan.zhihu.com/p/344834329">深度解密Go语言之sync.map - 知乎 (zhihu.com)</a>：读写map，两个map，read读 / dirty写</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MDYwODc5Nw==&amp;mid=2247484826&amp;idx=1&amp;sn=cb882a297bf84f986168bc6d613a7b28&amp;scene=21#wechat_redirect">学了这么久GO，这篇文章让我读懂了汇编！ (qq.com)</a>：<strong>caller-save模式</strong>，一般在汇编中参数和返回值被放在调用方的栈中，因此Go弄了一个伪寄存器用于实现Go的汇编结构。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485773&amp;idx=1&amp;sn=0e03c22500f836512fb4016c2a111887&amp;source=41#wechat_redirect">盘点一下 Go语言的“黑暗角落” (qq.com)</a>：<a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%99%90%E5%88%B6">数组细节</a> / For循环迭代器变量被重用</p><p><a href="https://studygolang.com/articles/23242?fr=sidebar">atomic.Value 源码解析</a>：</p><p><a href="https://coolshell.cn/articles/21615.html">泛型编程</a>：</p><p><a href="https://juejin.cn/post/6965421491588431909">sync.Pool原理解析</a>：减少小块对象内存频繁申请（帮助在程序构建了对象池，提供对象可复用能力，本身是可伸缩且并发安全的。）</p><p><a href="https://www.cyhone.com/articles/think-in-sync-pool/#:~:text=sync.Pool">深度分析 Golang sync.Pool 底层原理</a> 是 Golang,内置的对象池技术，可用于缓存临时对象，避免因频繁建立临时对象所带来的消耗以及对 GC 造成的压力。</p><h2 id="Go实战"><a href="#Go实战" class="headerlink" title="Go实战"></a>Go实战</h2><p><a href="https://juejin.cn/post/7126753651455950856">err 的优雅处理</a>: 错误是值</p><p><a href="https://zhuanlan.zhihu.com/p/114340283">Go进程的HeapReleased上升，但是RSS不下降造成内存泄漏？ - 知乎 (zhihu.com)</a>：</p><p><a href="https://pengrl.com/p/20031/">Go pprof内存指标含义备忘录 | yoko blog (pengrl.com)</a>：各种概念介绍</p><p><a href="https://mp.weixin.qq.com/s/OyiF57PcMQjeoGpShEgidQ">Go 的json 解析标准库竟然存在这样的陷阱？</a>：神技、版本变更兼容</p><p><a href="https://mp.weixin.qq.com/s/FyHEiaa-UfyLStMKl2VFGA">golang：快来抓住让我内存泄漏的“真凶”！</a> ：golang10次内存泄漏，8次goroutine泄漏，1次是真正内存泄漏，<strong>还有1次是cgo导致的内存泄漏</strong>。</p><p><a href="https://www.golangprograms.com/goroutines-and-channels-example.html">Goroutines and Channels Exercises</a></p><p><a href="https://mp.weixin.qq.com/s/PjNc7YLKT5JX_Obg2815Bg">DDD 到底是银弹还是垃圾 (qq.com)</a>：防腐层 等各种名词介绍</p><p> <a href="https://zhuanlan.zhihu.com/p/26695984">今日头条Go建千亿级微服务的实践</a>：<code>并发控制</code> / <code>超时控制</code> /</p><blockquote><p>wait：</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func makeThumbnails6(filenames &lt;-chan string) int64 {    sizes := make(chan int64)    var wg sync.WaitGroup // number of working goroutines    for f := range filenames {        wg.Add(1)        // worker        go func(f string) {            defer wg.Done()            thumb, err := thumbnail.ImageFile(f)            if err != nil {                log.Println(err)                return            }            info, _ := os.Stat(thumb) // OK to ignore error            sizes &lt;- info.Size()        }(f)    }    // closer    go func() {        wg.Wait()        close(sizes)    }()    var total int64    for size := range sizes {        total += size    }    return total}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   wg := sync.WaitGroup{}wg.Add(3)go func() {defer wg.Done()// do ...}()go func() {defer wg.Done()// do ...}()go func() {defer wg.Done()// do ...}()wg.Wait()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Cancle：</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   ctx := context.Background()ctx, cancle := context.WithCancel(ctx)go Proc(ctx)go Proc(ctx)go Proc(ctx)// Cancel after 1stime.Sleep(time.Second)cancle()}func Proc(ctx context.Context) {for {select {case &lt;- ctx.Done():returndefault:// do ...}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Handle(r *http.Request)  {timeoutStr := r.FormValue("timeout")timeout, _ := strconv.Atoi(timeoutStr)ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout))defer cancel()done := make(chan struct{}, 1)go func() {RPC(ctx, ...)done &lt;- struct{}{}}()select {case &lt;- done:// nice ... case &lt;- ctx.Done():// timeout}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247485030&amp;idx=1&amp;sn=6eb805b2ecbc123e984f563bde734812&amp;chksm=f904133bce739a2df5c3c800539d6d4a15e8d900b25f8ffb4ed08685a4135212f521825e96bc&amp;cur_album_id=1515516076481101825&amp;scene=190#rd">go并发中一些有趣的现象</a>：</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() { wg := sync.WaitGroup{} wg.Add(5) for i := 0; i &lt; 5; i++ {  go func() {   defer wg.Done()   fmt.Println(i)  }() } wg.Wait()}// 主要是变量 i 没有作为形参传入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>// 第一次输出：5 5 5 5 5</p><p>// 多输出几次：5 3 5 5 5</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() { wg := sync.WaitGroup{} wg.Add(5) for i := 0; i &lt; 5; i++ {  go func(i int) {   defer wg.Done()   fmt.Println(i)  }(i) } wg.Wait()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>// 第一次输出：0 1 2 4 3</p><p>// 第二次输出：4 0 1 2 3</p><p>（输出的值都是无序且不稳定的）</p><p>其整个程序扭转实质上分为了多个阶段，也就是各自运行的时间线并不同，可以其拆分为：</p><ul><li>先创建：<code>for-loop</code> 循环创建 <code>goroutine</code>。</li><li>再调度：协程<code>goroutine</code> 开始调度执行。</li><li>才执行：开始执行 <code>goroutine</code> 内的输出。</li></ul><blockquote><p><a href="https://hackernoon.com/building-a-media-streaming-server-using-go-and-hls-protocol-j85h3wem">Golang HLS 构建流服务</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/2022/05/22/shell/"/>
      <url>/2022/05/22/shell/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><a href="https://labuladong.gitee.io/algo/%E6%8A%80%E6%9C%AF/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html?q=">Linux文件系统</a>：<code>目录结构</code> </p><p><a href="https://labuladong.gitee.io/algo/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.html">进程、线程 和文件描述符</a>: <code>task_struct</code> </p><p><a href="https://labuladong.gitee.io/algo/%E6%8A%80%E6%9C%AF/linuxshell.html">关于Linux必须知道的知识</a>：<code>标准输入和参数</code> / <code>shell和子程序</code> / <code>单引号和双引号的区别</code> / <code>sudo找不到命令</code> </p><h2 id="shell定义"><a href="#shell定义" class="headerlink" title="shell定义"></a>shell定义</h2><blockquote><p>作用：可以<strong>更方便的</strong> 使用 <strong>操作系统</strong> 的 <code>接口</code> </p></blockquote><blockquote><p>工作原理： 负责把用户输入的字符串转换到需要执行的程序，并把结果以某个形式画出来的 </p><p>列如： 在命令行里输入 “ls -Rl” 这种字符串。</p><ul><li>这个字符串被翻译成“ls”，“-R”，“-l”</li><li>“ls”帮我们找到那个之前写好的程序，并启动它；“-R”和“-l”被作为参数传给这个程序，告诉程序走“递归所有子目录”+“输出长格式”这部分代码</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ShellOfLinux.png" style="zoom:67%;"><blockquote><p> 【bash】 + 【terminal】大概可以理解为一个以<code>字符</code>为<strong>交互</strong>方式的 <strong>Shell</strong> </p></blockquote><p>bash 负责按照某种格式把用户的输出的字符串翻译：</p><ul><li>比如对于普通非空字符翻译为程序和参数，并尝试去PATH里找对应的程序；</li><li>对“空格”翻译成分隔符；对“$XXX”尝试进行环境变量的替换；</li><li>对“｜”翻译为管道；</li><li>对 “&gt;”翻译为输出重定向；</li><li>对一个指令末尾的“&amp;”翻译为将程序转到后台执行</li></ul><p>参考： <a href="https://www.zhihu.com/question/35382632">Shell 是用来解决什么问题的</a> </p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置环境变量vim /etc/profile# 最后行添加路径export PATH=$PATH:/home/mysql/bin# 生效source /etc/profile# 显示当前系统定义的所有环境变量export# 输出当前的PATH环境变量的值echo $PATH <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看当前的进程的网络# 可以使用 "ss" (socket statistics) 来替代 netstatnetstat -an | grep 进程号# 查看当前进程号对应的 PIDlsof -i :进程号kill -9 PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 打印出CPU占用过高进程的线程栈jstack PID# 查看某个进程中的 "线程状态"top -H -p pid# 或者也可以采用ps命令，来查看繁忙的线程信息ps -mp pid -o THREAD,tid,time ps -Lfp pid # 后台运行程序，关掉当前shell仍然可以执行./hello.sh &amp; disown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件校验及查找"><a href="#文件校验及查找" class="headerlink" title="文件校验及查找"></a>文件校验及查找</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sha1 文件校验sha1sum 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在 “文件夹范围内” 两天内修改的文件/文件夹find 范围 -mtime -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://jingyan.baidu.com/article/636f38bb6e0bdad6b846103e.html">Linux-文件搜索命令find的使用</a></p><h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开机自启 /sbin/chkconfig --add server_name# 自定义开机文件cd /etc/systemd/system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 停止firewallsystemctl stop firewalld.service# 禁止firewall开机启动systemctl disable firewalld.service # 关闭 selinuxvim /etc/selinux/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#修改防火墙： /etc/sysconfig/iptables文件# 查看自己目前的防火墙端口情况：iptables -L -n1、停止并屏蔽firewalld服务systemctl stop firewalldsystemctl mask firewalld2、安装iptables-services软件包yum install iptables-services3、在引导时启用iptables服务systemctl enable iptables4、启动iptables服务systemctl start iptables5、保存防火墙规则service iptables save# or/usr/libexec/iptables/iptables.init save6、附加：停止、启动，重启防火墙systemctl [stop|start|restart] iptables# 不出意外执行完这些操作之后，你应该就能轻松的发现这个文件了# 现在接着修改/etc/sysconfig/iptables文件vim /etc/sysconfig/iptables<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改网络vim /etc/sysconfig/network-scripts/ifcfg-enp0s3# centos6的网卡重启方法：service network restart# centos7的网卡重启方法：systemctl restart network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内存-x2F-磁盘相关"><a href="#内存-x2F-磁盘相关" class="headerlink" title="内存/磁盘相关"></a>内存/磁盘相关</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看 "内存" 包括物理内存和虚拟内存swapfree -h# 查看 "磁盘" 的使用量df -h# fdisk创建和维护分区表的程序fdisk -l # 设置分区fdisk /dev/sdb# 查看sdb的分区情况lsblk /dev/sdb# make file system, 在特定的分区上建立 linux 文件系统,mkfs -t ext4 /dev/sdb1# 挂载新磁盘mount /dev/sdb1  /mnt/newdisk# 永久挂载vim /etc/fstab/dev/sda1/dragonballext4defaults0 0hdparm -i /dev/sda1hdparm -i /dev/sdb1 |grep -i serialno# SerialNo=Z1Z0MKWS 硬盘序列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.linuxprobe.com/mount-detail-parameters.html">mount命令</a></p><p><a href="https://snapshooter.io/blog/how-to-grow-an-ext234-file-system-with-resize2fs-">How to grow file system</a>: 除了主分区外</p><p><a href="https://linuxconfig.org/how-to-resize-ext4-root-partition-live-without-umount">Resize Root Partition in Linux</a></p><p><a href="https://www.cnblogs.com/chenmh/p/5096592.html">使用fdisk扩容分区</a></p><h4 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># "xargs" 读取输入源，然后逐行处理# 删除目录中的所有class文件: find . | grep .class$ | xargs rm -rvf#把所有的rmvb文件拷贝到目录ls *.rmvb | xargs -n1 -i cp {} /mount/xiaodianying<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ssh连接设置"><a href="#ssh连接设置" class="headerlink" title="ssh连接设置"></a>ssh连接设置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 修改sshdvim /etc/ssh/sshd_config# 打开权限：# PermitRootLogin yes# PubkeyAuthentication yes# PasswordAuthentication yessystemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><h4 id="整机"><a href="#整机" class="headerlink" title="整机"></a>整机</h4><ul><li>top </li><li>uptime，系统性能命令的精简版</li></ul><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul><li><p>vmstat -n 2 3    每两秒采样一次，共计采样三次</p><ul><li><p>procs：</p><ul><li>r：<code>运行/等待CPU时间片的进程数</code>，原则上1核的CPU运行队列不要超过2，整个系统的运行队列不能超过 2*总核数</li></ul></li><li><p>b：<code>等待资源的进程数</code>，比如正在等待磁盘I/O 、网络I/O等</p></li></ul></li></ul><h3 id="第三方命令"><a href="#第三方命令" class="headerlink" title="第三方命令"></a>第三方命令</h3><p><a href="https://zhuanlan.zhihu.com/p/102176365?utm_oi=1129729846456283136">shell基本语法</a> </p><h3 id="vim常用"><a href="#vim常用" class="headerlink" title="vim常用"></a>vim常用</h3><ul><li><p><code>u</code> 撤销当前操作</p></li><li><p><code>.</code> 重复上一次的命令</p></li><li><p><code>N+命令</code>重复某个命令 N 次</p></li></ul><p>参考：<a href="https://juejin.cn/post/6934580280627822599#heading-2">vim高级使用</a> </p><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>请求输入， <code>read</code> 命令读取到的文本会立即被存储在一个变量里。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash# filename: read.shread nameecho "hello $name !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>./read.sh</code> 时，会发现光标处于接收输入的状态，此时输入一个字符串 <code>will</code> 按下回车键后，控制台会打印出 <code>hello will</code> </p><h4 id="同时给几个变量赋值"><a href="#同时给几个变量赋值" class="headerlink" title="同时给几个变量赋值"></a>同时给几个变量赋值</h4><p>可以用 <code>read</code> 命令一次性给多个变量赋值， <code>read</code> 命令一个单词一个单词（空格分开）地读取你输入的参数，并且把每个参数赋值给对应的变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashread oneName towNameecho "hello $oneName $towName !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显示提示信息"><a href="#显示提示信息" class="headerlink" title="显示提示信息"></a>显示提示信息</h4><p><code>read</code> 命令的 <code>-p</code> 参数， <code>p</code> 是 <code>prompt</code> 的首字母，表示“提示”。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashread -p "请输入您的姓名：" nameecho "hello $name !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 换行read -p $'please input file.csv (need format is CSV UTF-8) \x0a' file_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="限制字符数目"><a href="#限制字符数目" class="headerlink" title="限制字符数目"></a>限制字符数目</h4><p>用 <code>-n</code> 参数可以限制用户输入的字符串的最大长度（字符数）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p "请输入您的姓名：" -n 5 name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="限制输入时间"><a href="#限制输入时间" class="headerlink" title="限制输入时间"></a>限制输入时间</h4><p>用 <code>-t</code> 参数可以限定用户的输入时间（单位：秒）超过这个时间，就不读取输入了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p "请输入您的姓名：" -n 5 -t 10 name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="隐藏输入内容"><a href="#隐藏输入内容" class="headerlink" title="隐藏输入内容"></a>隐藏输入内容</h4><p>用 <code>-s</code> 参数可以隐藏输入内容，在用户输入密码时使用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p "请输入密码：" -s password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p> Shell 变量 分为<strong>系统变量</strong>和<strong>自定义变量</strong> </p><ul><li>系统变量有$HOME、$PWD、$USER等</li></ul></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set # 显示当前shell所有变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="设置普通变量"><a href="#设置普通变量" class="headerlink" title="设置普通变量"></a>设置普通变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 等号两侧不能有空格，变量名一般习惯用大写# 变量名=变量值WILL=14# 删除变量unset WILL# 声明静态变量，静态变量不能unsetreadonly WILL# 使用变量echo $WILL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.runoob.com/linux/linux-comm-declare.html">还有declare命令</a> </p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/profile# export 变量名=变量值，将 Shell 变量输出为环境变量export JAVA_HOME=/usr/jdk1.8# source 配置文件路径，让修改后的配置信息立即生效source /etc/profile# echo $变量名，检查环境变量是否生效echo $JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><ul><li>$n ：$0 代表命令本身、$1-$9 代表第1到9个参数，10以上参数用花括号，如 ${10}。</li><li>$* ：命令行中所有参数，且把所有参数<strong>看成一个整体</strong>。</li><li>$@ ：命令行中所有参数，且把每个参数<strong>区分</strong>对待，for循环中常用。</li><li>$# ：所有参数个数。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim positionPara.sh#!/bin/bash     # 输出各个参数 echo $0 $1 $2 echo $* echo $@ echo 参数个数=$#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh positionPara.sh left right# 执行后的结果：positionPara.sh left rightleft rightleft right2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="错误号"><a href="#错误号" class="headerlink" title="错误号"></a>错误号</h3><p><code>$?</code> ： 在 Linux 下，所有的程序在结束时，都会有一个返回值，或者称为错误号 ( Error Number )</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls *.sh# ......echo $?# 0: 只要返回值是 0，就代表程序执行成功了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>应用：</strong> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo "database backup result: $? (0:successfully ;1:unsuccessfully)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>给其中所有 markdown 文件最下方添加上一篇、下一篇、目录三个页脚链接，有的文章已经有了页脚，大部分都没有</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfilename=$1# 查看文件尾部是否包含关键词tail | grep '下一篇' $filename# grep 查找到匹配会返回 0，找不到则返回非 0 值[ $? -ne 0 ] &amp;&amp; { 添加页脚; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将上次命令执行是否成功的返回值放到提示符里面去will@localhost ~ $ export PS1="[\$?]${PS1}"[0]will@localhost ~ $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>用perror查看错误提示</strong> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">perror 2 OS error code   2:  No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><blockquote><p> 在赋值定义之前，事先在 Shell 脚本中直接引用的变量 </p></blockquote><p>基本语法：</p><ul><li>$$ ：当前进程的 PID 进程号。</li><li>$! ：后台运行的最后一个进程的 PID 进程号。 <code>!$</code>, 替换成上一次命令最后的路径</li><li>$? ：最后一次执行的命令的返回状态，0为执行正确，非0执行失败。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashecho 当前的进程号=$$# &amp;：后台的方式运行进程./hello.sh &amp;echo 最后一个进程的进程号=$!echo 最后执行的命令结果=$?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@izbp17osf716ivk4ilma92z test]# sh prePara.sh 当前的进程号=4781最后一个进程的进程号=4782最后执行的命令结果=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 没有加可执行权限$ /usr/bin/script.shzsh: permission denied: /usr/bin/script.sh$ chmod +x !$chmod +x /usr/bin/script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CDPATH"><a href="#CDPATH" class="headerlink" title="CDPATH"></a>CDPATH</h3><p><strong>在环境变量 <code>CDPATH</code> 中加入你常用的工作目录</strong>，当 <code>cd</code> 命令在当前目录中找不到你指定的文件/目录时，会自动到 <code>CDPATH</code> 中的目录中寻找。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ export CDPATH='~:/var/log'# cd 命令将会在 ～ 目录和 /var/log 目录扩展搜索$ pwd/home/will/musics$ cd mysqlcd /var/log/mysql$ pwd/var/log/mysql$ cd my_picturescd /home/will/my_pictures<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>使用”$”来获取变量的时候最好加上双引号，举一个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/sh#已知当前文件夹有一个a.sh的文件var="*.sh"echo $varecho "$var"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行结果如下：a.sh*.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 为啥会这样呢？其实可以解释为他执行了下面的命令： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo *.shecho "*.sh"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号{}"></a>大括号{}</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cp /very/long/path/file{,.bak}# 给 file 复制一个叫做 file.bak 的副本$ rm file{1,3,5}.txt# 删除 file1.txt file3.txt file5.txt$ mv *.{c,cpp} src/# 将所有 .c 和 .cpp 为后缀的文件移入 src 文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​花括号中的每个字符都可以和之后（或之前）的字符串进行组合拼接，<strong>注意花括号和其中的逗号不可以用空格分隔，否则会被认为是普通的字符串对待</strong>。</p><h2 id="参数规范"><a href="#参数规范" class="headerlink" title="参数规范"></a>参数规范</h2><blockquote><p>当脚本需要接受参数的时候，一定要先判断参数是否合乎规范，并给出合适的回显，方便使用者了解参数的使用 </p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 判断参数的个数#!/bin/bashif [ $# != 2 ]then    echo "Parameter incorrect."    exit 1fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>获取某一段命令的执行结果，它的方式有两种：</p><ul><li><code>command</code></li><li><code>$(command)</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">all_files=`ls` # 获取ls命令的执行结果all_files=$(ls) # 效果同上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种命令替换的方式都是等价的，可以任选其一使用。</p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><p>获取系统的所有用户并输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashindex=1for user in `cat /etc/passwd | cut -d ":" -f 1`do# cat /etc/passwd 获取系统中的所有用户和密码# cut -d ":" -f 1 根据冒号切每一行的字符串，获取切好后的第一部分# 使用for循环进行遍历，并输出用户echo "This is $index user: $user"index=$(($index + 1))done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取今年已经过了多少天和周：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo "This year have passed $(date +%j) days"echo "This year have passed $(($(date +%j)/7)) weeks"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意： <code>$(())</code> 用于数学运算， <code>$()</code> 用于命令替换，这两个是平时使用中特别容易混淆的语法。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><code>bash</code> 中的运算方式有以下几种：</p><ul><li><code>$((...))</code> 或 <code>$[...]</code> </li><li><code>expr</code> </li><li><code>let</code> </li><li><code>bc</code> </li><li><code>declare -i</code></li></ul><h3 id="…"><a href="#…" class="headerlink" title="$((…))"></a>$((…))</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo $((2 + 2)) # 加法echo $((5 / 2)) # 除法i=0echo $((i++)) # 先返回值后运算echo $((++i)) # 先运算后返回值echo $(( (2 + 3) * 4 )) # 圆括号改变运算顺序echo $((0xff)) # 16进制转成10进制的运算echo $((16&gt;&gt;2)) # 位运算echo $((3 &gt; 2)) # 逻辑运算，如果逻辑表达式为真，返回1，否则返回0a=0echo $((a&lt;1 ? 1 : 0)) # 三元运算符echo $((a=1)) # 变量赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:  这个语法只能计算整数。</p><h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><p>语法格式： <code>expr $num1 operator $num2</code></p><p>操作符概览：</p><ul><li><code>num1 | num2</code> – <code>num1</code> 不为空且非0，返回 <code>num1</code> ; 否则返回 <code>num2</code> </li><li><code>num1 &amp; num2</code> – <code>num1</code> 不为空且非0，返回 <code>num1</code> ；否则返回0</li><li><code>num1 &lt; num2</code> – <code>num1</code> 小于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 &lt;= num2</code> – <code>num1</code> 小于等于 num2 ，返回1；否则返回0</li><li><code>num1 = num2</code> – <code>num1</code> 等于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 != num2</code> – <code>num1</code> 不等于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 &gt; num2</code> – <code>num1</code> 大于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 &gt;= num2</code> – <code>num1</code>  大于等于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 + num2</code> – 求和</li><li><code>num1 - num2</code> – 求差</li><li><code>num1 * num2</code> – 求积</li><li><code>num1 / num2</code> – 求商</li><li><code>num1 % num2</code> – 求余</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$num1=30; $num2=50expr $num1 \&gt; $num2 # 大于不成立，返回0expr $num1 \&lt; $num2 # 小于成立，返回1expr $num1 \| $num2 # 返回 num1expr $num1 \&amp; $num2 # 返回 num1expr $num1 + $num2 # 计算加法num3=`expr $num1 + $num2` # 计算结果赋值给num3expr $num1 - $num2 # 计算减法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[注意] <code>&gt;</code>、<code>&lt;</code> 等操作符是 <code>Shell</code> 中的保留关键字，因此需要进行转义。否则就变成输出和输入重定向了。</p><h4 id="练习案例"><a href="#练习案例" class="headerlink" title="练习案例"></a>练习案例</h4><p>提示用户输入一个正整数 <code>num</code> ，然后计算从 <code>1+2+3</code> 加到给定正整数。 必须对给定的 <code>num</code> 值进行是否为正整数判断，如果不是正整数则重新输入。</p><p>代码实现：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashwhile true # 无限循环接收用户输入doread -p "pls input a positive number: " num # 接收到用户的输入，存为num值expr $num + 1 2&gt;&amp;1 /dev/null # 对num进行加1的运算，运算结果重定向到/dev/null      # 由于 expr 只能运算整数，如果运算浮点数的话会报错，$?获取的是表达式执行结果，并非运算结果      # 执行结果如果是正常的返回0if [ $? -eq 0 ];then # $? 获取到上一次运算结果if [ `expr $num \&gt; 0` -eq 1 ];then # 上面判断了是否为整数，这里判断是否为正整数    # 类似JavaScript循环的写法遍历一个数值for((i=1;i&lt;=$num;i++))dosum=`expr $sum + $i` # 获取运算结果总和doneecho "1+2+3+....+$num = $sum" # 输出运算结果exit # 退出循环fifiecho "error,input enlegal" # 表示输入的值有误continue # 如果输入有误继续循环让用户输入done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><p><code>let</code> 命令声明变量时，可以直接执行算术表达式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">let "foo = 1 + 2"echo $foo # 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>支持浮点数运算</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo "scale=2;23/5" | bc # scale表示浮点位数num1=`echo "scale=2;23/5" | bc` # 运算结果保存为变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="declare-i-命令"><a href="#declare-i-命令" class="headerlink" title="declare -i 命令"></a>declare -i 命令</h3><p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -i val1=12 val2=5declare -i resultresult=val1*val2echo $result # 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h2><p><code>declare</code> 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare OPTION VARIABLE=value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-r</code> 将变量设为只读；</li><li><code>-i</code> 将变量设为整数；</li><li><code>-a</code> 将变量定义为数组；</li><li><code>-f</code> 显示此脚本前定义过的所有函数及内容；</li><li><code>-F</code> 仅显示此脚本前定义过的函数名；</li><li><code>-x</code> 将变量声明为环境变量。</li></ul><p><code>declare</code>命令如果用在函数中，声明的变量只在函数内部有效，等同于<code>local</code>命令。</p><p>不带任何参数时，<code>declare</code>命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的<code>set</code>命令。</p><h5 id="i"><a href="#i" class="headerlink" title="-i"></a><code>-i</code></h5><p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -i val1=12 val2=5declare -i resultresult=val1*val2echo $result # 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="x"><a href="#x" class="headerlink" title="-x"></a><code>-x</code></h5><p><code>-x</code> 参数等同于 <code>export</code> 命令，可以输出一个变量为子 <code>Shell</code> 的环境变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -x foo=3 # 等同于export foo=3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="r"><a href="#r" class="headerlink" title="-r"></a><code>-r</code></h5><p><code>-r</code> 参数可以声明只读变量，无法改变变量值，也不能 <code>unset</code> 变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -r bar=1# 如果此时更改barbar=2 # -bash: bar：只读变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="u"><a href="#u" class="headerlink" title="-u"></a><code>-u</code></h5><p><code>-u</code> 参数声明变量为大写字母，可以自动把变量值转成大写字母。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -u foofoo=upperecho $foo # UPPER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="l"><a href="#l" class="headerlink" title="-l"></a><code>-l</code></h5><p><code>-l</code> 参数声明变量为小写字母，可以自动把变量值转成小写字母。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -l barbar=LOWERecho $bar # lower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="p"><a href="#p" class="headerlink" title="-p"></a><code>-p</code></h5><p><code>-p</code> 参数输出变量信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">foo=hellodeclare -p foo #控制台输出：declare -x foo="hello"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array=('v1' 'v2' 'v3') <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="输出数组内容"><a href="#输出数组内容" class="headerlink" title="输出数组内容"></a>输出数组内容</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">${array[@]} # 输出全部内容${array[*]} # 也是输出全部内容${array[1]} # 输出下标索引为1的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">${#array} # 数组内元素个数${#array[2]} # 数组内下标为2的元素长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array[0]="frank" # 给数组下标为1的元素赋值为frankarray[20]="lion" # 在数组尾部添加一个新元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unset array[2] # 清除元素unset array # 清空整个数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for v in ${array[@]}dodone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim guessGame.sh#!/bin/bashecho '你猜的数字为：'$1if [ $1 -gt 7 ]then        echo '大于7'elif [ $1 -lt 4 ]then        echo '小于4'fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ condition ] : 前后都要有空格，非空返回0，0为true，否则为falseif [ : `if`距离条件方括号之间，需要有空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 是否存在文件/root/shell/isExist.txt if [ -e /root/shell/isExist.txt ] then     echo '存在' fi  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ $1 = 7 ] &amp;&amp; echo 'hello' || echo 'world' then     echo '条件满足，执行后面的语句' fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case $变量名 in"值1")如果变量值等于值1，则执行此处程序1;;"值2")如果变量值等于值2，则执行此处程序2;;...省略其它分支...*)如果变量值不等于以上列出的值，则执行此处程序;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case $1 in"1")echo 周一;;"2")echo 周二;;*)echo 其它;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 语法1for 变量名 in 值1 值2 值3...do    程序done# 语法2for ((初始值; 循环控制条件; 变量变化))do    程序done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="语法一"><a href="#语法一" class="headerlink" title="语法一"></a>语法一</h3><p>==$*== ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash  # 使用$* for i in "$*" do         echo "the arg is $i" done # 输出：thearg is 1 2 3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> ==$@== ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash  # 使用$@ for j in "$@" do         echo "the arg is $j" done# 输出：the arg is 1 the arg is 2 the arg is 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash SUM=0  for ((i=1;i&lt;=100;i++)) do         SUM=$[$SUM+$i] done echo $SUM# 输出从1加到100的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">while [ 条件判断式 ]do    程序done <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashSUM=0i=0while [ $i -le $1 ]do    SUM=$[$SUM+$i]    i=$[$i+1]done       echo $SUM# 输出从1加到100的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read(选项)(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选项<ul><li>-p：指定读取值时的提示符 </li><li>-t：指定读取值时等待的时间（秒），如果没有在指定时间内输入，就不再等待</li></ul></li><li>参数<ul><li>变量名：读取值的变量名</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim guessGame.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ function ] funname[()]{    Action;    [return int;]}# 调用funname 参数1 参数2...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>函数名后面的圆括号中<code>不加任何参数</code>，这点与主流编程语言不相同</li><li>函数的完整定义必须<code>置于函数的调用之前</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunction getSum(){    SUM=$[$n1+$n2]}   # 函数中的变量 均为全局变量，没有局部变量echo "sum=$SUM"read -p "请输入第一个参数n1：" n1read -p "请输入第二个参数n2：" n2# 调用 getSum 函数getSum $n1 $n2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashprint_something(){    echo "hello $1" # $1 获取第一个参数}print_something Lion # Lion 为参数print_something Frank # Frank 为参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p> shell中函数的返回值<code>只能是整数</code>  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashprint_something(){    echo "Hello $1"    return 1}print_something willecho "函数的返回值是 $?" # $? 获取到的是上一个函数的返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 也可以通过下面变通的方法:   通过echo或者print之类的就可以做到<code>传一些额外参数</code>的目的 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunc(){    echo "2333"}res=$(func)echo "This is from function: $res."<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的局部变量"><a href="#函数的局部变量" class="headerlink" title="函数的局部变量"></a>函数的局部变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashlocal_global(){# 通过 local 关键字定义局部变量  local var1='local 1'   echo "var1 is $var1"}local_global<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="巧用main函数"><a href="#巧用main函数" class="headerlink" title="巧用main函数"></a>巧用main函数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunc1(){    #do sth}func2(){    #do sth}main(){    func1    func2}main "$@"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>func1 / func2 必须定义在<strong>调用</strong>main函数之前，可以定义在main函数之后</p></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashvar=1func(){   var=2}funcecho $var# 2 : 输出结果就是2而不是1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><ul><li>basename，删掉路径最后一个 / 前的所有部分（包括/），常用于获取文件名 <ul><li>basename [pathname] [suffx]</li><li>basename [string] [suffx]</li><li>如果指定 suffx，也会删掉pathname或string的后缀部分</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">basename /usr/bin/sort  # sort  basename include/stdio.h  # stdio.h  basename include/stdio.h .h # stdio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><ul><li>dirname，删掉路径最后一个 / 后的所有部分（包括/），常用于获取文件路径 <ul><li>dirname pathname</li><li>如果路径中不含 / ，则返回 ‘.’ （当前路径）</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dirname /usr/bin/  # /usr  dirname dir1/str dir2/str # dir1 # dir2  dirname stdio.h # .# 表示当前路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>替换规则：</p><ul><li><code>${变量名#匹配规则}</code> 从变量开头进行规则匹配，将符合最短的数据删除。</li><li><code>${变量名##匹配规则}</code> 从变量开头进行规则匹配，将符合最长的数据删除。</li><li><code>${变量名%匹配规则}</code> 从变量尾部进行规则匹配，将符合最短的数据删除。</li><li><code>${变量名%%匹配规则}</code> 从变量尾部进行规则匹配，将符合最长的数据删除。</li><li><code>${变量名/旧字符串/新字符串}</code> 变量内容符合旧字符串，则第一个旧字符串会被新字符串取代。</li><li><code>${变量名//旧字符串/新字符串}</code> 变量内容符合旧字符串，则全部旧字符串会被新字符串取代。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="I love you, Do you love me"var=${var_1#*ov} # e you, Do you love mevar=${var_1##*ov} # e mevar=${var_1%ov*} # I love you, Do you lvar=${var_1%%ov*} # I lvar_2="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"# 第一个小写bin被替换为大写的BINvar=${var_2/bin/BIN} # /usr/local/BIN:/usr/bin:/bin:/usr/sbin:/sbin # 所有小写bin会被替换为大写的BINvar=${var_2//bin/BIN} # /usr/local/BIN:/usr/BIN:/BIN:/usr/sBIN:/sBIN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算字符串的长度"><a href="#计算字符串的长度" class="headerlink" title="计算字符串的长度"></a>计算字符串的长度</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">`${#string}` `expr length "$string"` 如果 `string` 有空格则必须加双引号。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="Hello world"len=${#var_1} # 11len=`expr length "$var_1"` # 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取子串在字符串中的索引位置"><a href="#获取子串在字符串中的索引位置" class="headerlink" title="获取子串在字符串中的索引位置"></a>获取子串在字符串中的索引位置</h3><ul><li><code>expr index $string $substring</code> 从1开始计算索引位置。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="quickstart is an app"ind=`expr index "$var_1" start` # 6ind=`expr index "$var_1" uniq` # 1ind=`expr index "$var_1" f` # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它其实是按照子串的每个字符每个字符去进行匹配</p><ul><li>第一个例子匹配到的是 <code>s</code> 位置6。</li><li>第二个匹配到的是 <code>q</code> 位置1。</li><li>第三个例子什么都没有匹配到所以位置是0。</li></ul><h3 id="计算子串长度"><a href="#计算子串长度" class="headerlink" title="计算子串长度"></a>计算子串长度</h3><p><code>expr match $string substr</code>从头开始匹配子串长度，如果没有匹配到则返回0，匹配到了则返回配的子串长度。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="quickstart is an app"sub_len=`expr match "$var_1" app` # 0sub_len=`expr match "$var_1" quic` # 4sub_len=`expr match "$var_1" quic.*` # 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽取子串"><a href="#抽取子串" class="headerlink" title="抽取子串"></a>抽取子串</h3><ul><li><code>${string:position}</code> 从 <code>string</code> 的 <code>position</code> 开始。</li><li><code>${string:position:length}</code> 从 <code>position</code> 开始，匹配长度为 <code>length</code> 。</li><li><code>${string: -position}</code> 从右边开始匹配。</li><li><code>${string:(position)}</code> 从左边开始匹配。</li><li><code>expr substr $string $postion $length</code> 从 <code>position</code> 开始，匹配长度为 <code>length</code> 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="quickstartisanapp"# 从索引10到最后提取子串，这种方式的索引是从0开始计算的substr=${var_1:10} # isanappsubstr=${var_1:10:2} # is# -5 前面需要添加空格，如果不添加空格也可以使用括号substr=${var_1: -5} # anappsubstr=${var_1:(-5)} # anapp# expr 这种方式的索引是从1开始substr=`expr substr "$var_1" 10 5` # tisan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h3><p>变量 <code>string="Bigdata process framework is Hadoop,Hadoop is an open source project"</code> 执行脚本后，打印输出 <code>string</code> 字符串变量，并给用户以下选项：</p><ul><li>(1)、打印 <code>string</code> 长度</li><li>(2)、删除字符串中所有的 <code>Hadoop</code> </li><li>(3)、替换第一个 <code>Hadoop</code> 为 <code>Mapreduce</code> </li><li>(4)、替换全部 <code>Hadoop</code> 为 <code>Mapreduce</code></li></ul><p>用户输入数字 <code>1|2|3|4</code> ，可以执行对应项的功能；输入 <code>q|Q</code> 则退出交互模式。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol><li>打印字符串很简单，直接 <code>echo</code> 打印即可。</li><li>删除字符串也不难，使用 <code>${变量名//旧字符串/新字符串}</code> ，把 <code>Hadoop</code> 替换为空就从原字符串中删除了。</li><li>至于替换也是使用 <code>${变量名/旧字符串//新字符串}</code></li><li>用户输入，则使用的是上一篇文章讲到的 <code>read</code> 命令。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashstring="Bigdata process framework is Hadoop,Hadoop is an open source project"# 打印提示函数print_tips(){  echo "(1)、打印string长度"  echo "(2)、删除字符串中所有的Hadoop"  echo "(3)、替换第一个Hadoop为Mapreduce"  echo "(4)、替换全部Hadoop为Mapreduce"}# 输出字符串长度函数len_of_string(){  echo "${#string}"}# 替换Hadoop子串为空，相当于删除delete_Hadoop(){  echo "${string//Hadoop/}"}# 替换一个Hadoop为Mapreducerep_hadoop_mapreduce_first(){  echo "${string/Hadoop/Mapreduce}"}# 替换全部Hadoop为Mapreducerep_hadoop_mapreduce_all(){  echo "${string//Hadoop/Mapreduce}"}# 无限循环的接收用户输入，直到用户输入了q|Q则退出进程while truedo  echo "$string" # 打印字符串  echo # 打印一个空  print_tips # 输出提示信息  read -p "请输入你的选择(1|2|3|4|q|Q)：" choice # 接收用户输入  # 根据用户的输入，进入不同的分支，调用不同的函数  case $choice in    1)    len_of_string      ;;    2)    delete_Hadoop      ;;    3)    rep_hadoop_mapreduce_first      ;;    4)    rep_hadoop_mapreduce_all      ;;    q|Q)    exit      ;;    *)    echo "错误的输入"      ;;    esac  done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本三剑客"><a href="#文本三剑客" class="headerlink" title="文本三剑客"></a>文本三剑客</h2><p><a href="https://juejin.cn/post/6935365727205457928#heading-56">参考：文本处理</a> </p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep text file # text代表要搜索的文本，file代表供搜索的文件# 实例grep path /etc/profile# pathmunge () {#     pathmunge /usr/sbin#     pathmunge /usr/local/sbin#     pathmunge /usr/local/sbin after#     pathmunge /usr/sbin after# unset -f pathmunge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-i</code> 忽略大小写， <code>grep -i path /etc/profile</code></li><li><code>-n</code> 显示行号，<code>grep -n path /etc/profile</code></li><li><code>-v</code> 只显示搜索文本不在的那些行，<code>grep -v path /etc/profile</code></li><li><code>-r</code> 递归查找， <code>grep -r hello /etc</code> ， <code>Linux</code> 中还有一个 <code>rgrep</code> 命令，作用相当于 <code>grep -r</code></li></ul><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p><code>grep</code> 可以配合正则表达式使用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep -E path /etc/profile --&gt; 完全匹配pathgrep -E ^path /etc/profile --&gt; 匹配path开头的字符串grep -E [Pp]ath /etc/profile --&gt; 匹配path或Path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p><code>stream Editor</code> 的缩写，**<u>流编辑器</u><strong>，对</strong><em>标准输出或文件</em>** <code>逐行</code> 进行处理。</p><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed [option] "pattern/command" file# 例如：sed '/python/p' name.txt # 省略了option# /python/ 为pattern正则# p 为command命令打印的意思<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：匹配模式中存在<u>变量要使用双引号</u>。</p><h4 id="选项-option"><a href="#选项-option" class="headerlink" title="选项 option"></a>选项 option</h4><h5 id="n-只打印模式匹配行"><a href="#n-只打印模式匹配行" class="headerlink" title="-n 只打印模式匹配行"></a><code>-n</code> 只打印模式匹配行</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed 'p' name.txt # 会对每一行字符串输出两遍，第一遍是原文本，第二遍是模式匹配到的文本sed -n 'p' name.txt # 加了-n参数后就只打印模式匹配到的行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="e-默认选项"><a href="#e-默认选项" class="headerlink" title="-e 默认选项"></a>-e 默认选项</h5><p>支持多个 <code>pattern command</code> 的形式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -e "pattern command" -e "pattern command" file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="f-指定动作文件"><a href="#f-指定动作文件" class="headerlink" title="-f 指定动作文件"></a>-f 指定动作文件</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 简单命令sed -n '/python/p' name.txt # 但是一旦正则比较复杂，我们就可以把它保存在一个单独文件中，使用-f进行指定sed -n -f edit.sed name.txt # '/python/p'这个命令保存在edit.sed文件中，使用-f指定# edit.sed 内容为 /python/p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="E-扩展表达式"><a href="#E-扩展表达式" class="headerlink" title="-E 扩展表达式"></a>-E 扩展表达式</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -n -E '/python|PYTHON/p' name.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="i-直接修改文件内容"><a href="#i-直接修改文件内容" class="headerlink" title="-i 直接修改文件内容"></a>-i 直接修改文件内容</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i 's/love/like/g' name.txt# -i修改原文件# 全部love替换为like<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="模式匹配-pattern"><a href="#模式匹配-pattern" class="headerlink" title="模式匹配 pattern"></a>模式匹配 pattern</h4><p><code>pattern</code> 用法表</p><table><thead><tr><th>匹配模式</th><th>含义</th><th>用法</th></tr></thead><tbody><tr><td><code>10command</code></td><td>匹配第10行</td><td><code>sed -n "17p" name.txt</code> 打印 name 文件的第17行</td></tr><tr><td><code>10,20command</code></td><td>匹配从第10行开始，到第20行结束</td><td><code>sed -n "10,20p" name.txt</code> 打印 <code>name</code> 文件的10到20行</td></tr><tr><td><code>10,+5command</code></td><td>匹配从第10行开始，到第15行结束</td><td><code>sed -n "10,+5p" name.txt</code></td></tr><tr><td><code>/pattern1/command</code></td><td>匹配到 <code>pattern1</code> 的行</td><td><code>sed -n "/^root/p" name.txt</code> 打印 <code>root</code> 开头的行</td></tr><tr><td><code>/pattern1/,/pattern2/command</code></td><td>匹配到 <code>pattern1</code> 的行开始，至匹配到 <code>pattern2</code> 的行结束</td><td><code>sed -n "/^ftp/,/^mail/p" name.txt</code></td></tr><tr><td><code>10,/pattern1/command</code></td><td>匹配从第10行开始，到匹配到 <code>pattern1</code> 的行结束</td><td><code>sed -n "4,/^ok/p" name.txt</code> 打印 <code>name</code> 文件从第4行开始匹配，直到以 <code>ok</code> 开头的行结束</td></tr><tr><td><code>/pattern1/,10command</code></td><td>匹配到 <code>pattern1</code> 的行开始，到第10行匹配结束</td><td><code>sed -n "/root/,10p" name.txt</code></td></tr></tbody></table><h4 id="命令-command"><a href="#命令-command" class="headerlink" title="命令 command"></a>命令 command</h4><ul><li>查询<ul><li><code>p</code> – 打印</li></ul></li><li>增加<ul><li><code>a</code> – 行后追加</li><li><code>i</code> – 行前追加</li><li><code>r</code> – 外部文件读入，行后追加</li><li><code>w</code> – 匹配行写入外部文件</li></ul></li><li>删除<ul><li><code>d</code> – 删除</li></ul></li><li>修改<ul><li><code>s/old/new</code> – 将行内第一个 <code>old</code> 替换为 <code>new</code></li><li><code>s/old/new/g</code> – 将行内全部的 <code>old</code> 替换为 <code>new</code></li><li><code>s/old/new/2g</code> –同一行，只替换从第二个开始到剩下所有的</li><li><code>s/old/new/ig</code> – 将行内 <code>old</code> 全部替换为 <code>new</code> ，忽略大小写</li></ul></li></ul><p>实例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed '/python/p' name.txt # 打印sed '1d' name.txt # 删除第一行sed -i '/frank/a hello' name.txt # 匹配到字符串frank就在这一行后面插入“hello”sed -i '/frank/r list' name.txt # 把list文件内容追加到匹配frank字符串后面的行sed -n '/frank/w tmp.txt' name.txt # 将匹配到frank的行全部写入tmp.txt文件中sed -i 's/love/like/g' name.txt # 全局替换love为like，并修改源文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="反向应用"><a href="#反向应用" class="headerlink" title="反向应用"></a>反向应用</h4><p>引用前面的匹配到的字符。</p><p>假设有一个文件 <code>test.txt</code> 内容为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a heAAo vbvc heBBo sdsadk heCCo mnh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在需要匹配到 <code>heAAo heBBo heCCo</code> 并在他们后面添加 <code>s</code> 。</p><p>使用反向引用可以这样做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i 's/he..o/&amp;s/g' test.txt # 其中&amp;就是引用前面匹配到的字符sed -i 's/\(he..o\)/\1s/g' test.txt # 与上面的写法等价# 输出结果a heAAos vbvc heBBos sdsadk heCCos mnh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p><code>awk</code> 是一个文本处理工具，通常用于处理数据并生成结果报告。</p><h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{}pattern{commands}END{}' file_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>BEGIN{}</code> 正式处理数据之前执行；</li><li><code>pattern</code> 匹配模式；</li><li><code>{commands}</code> 处理命令，可能多行；</li><li><code>END{}</code> 处理完所有匹配数据后执行。</li></ul><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><ul><li><code>$0</code> – 整行内容。</li><li><code>$1-$n</code> – 当前行的第 <code>1-n</code> 个字段。</li><li><code>NF</code> – <code>Number Field</code> 的缩写，表示当前行的字段个数，也就是有多少列。</li><li><code>NR</code> – <code>Number Row</code> 的缩写，表示当前行的行号，从1开始计数。</li><li><code>FNR</code> – <code>File Number Row</code> 的缩写，表示多文本处理时，每个文件行号单独计数，都是从1开始。</li><li><code>FS</code> – <code>Field Separator</code> 的缩写，表示输入字段分隔符，不指定默认以空格或 <code>tab</code> 键分割。</li><li><code>RS</code> – <code>Row Separator</code> 的缩写，表示输入行分隔符，默认回车换行 <code>\n</code> 。</li><li><code>OFS</code> – <code>Output Field Separator</code> ，表示输出字段分隔符，默认为空格。</li><li><code>ORS</code> – <code>Output Row Separator</code> 的缩写，表示输出行分隔符，默认为回车换行。</li><li><code>FILENAME</code> – 当前输入的文件名字。</li><li><code>ARGC</code> – 命令行参数个数。</li><li><code>ARGV</code> – 命令行参数数组。</li></ul><p>注意：字段个数，非字符个数，例如 <code>"frank lion alan"</code> 这一行有3个字段。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk '{print $0}' /etc/passwd # 只有处理命令，输出每一行的内容awk 'BEGIN{FS=":"}{print $1}' /etc/passwd # 处理文本之前先定义好分隔符为冒号，然后打印每一行被冒号分割后的文本的第一个字段awk 'BEGIN{FS=":"}{print $NF}' /etc/passwd # 输出每一行的最后一列，NF中存的总列数，因此$NF表示最后一列的字段awk '{print $NF}' /etc/passwd # 输出每一行的字段个数（默认以空格分割后的字段个数）awk '{print NR}' /etc/passwd # 输出文件的行号awk '{print FNR}' /etc/passwd name.txt # 输出两个文件的行号，每个文件单独计数awk 'BEGIN{RS="---"}{print $0}' /etc/passwd # 行分隔符设置为---awk 'BEGIN{ORS="---"}{print $0}' /etc/passwd # 定义输出的每一行的分隔符为 --- awk 'BEGIN{ORS="---";RS="---"}{print $0}' /etc/passwd # BEGIN 中定义多个变量需要;分割awk '{print FILENAME}' name.txt # 输出name.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：<code>/etc/passwd</code> 就是 <code>Linux</code> 系统中的密码文本，后续会一直使用，大概是如下格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 切割字符串，并生成数组cat excel-utf8.csv | while read linedo        #echo ${line} | awk 'BEGIN {FS=",";OFS=" "} {print $1, $2}'                # 读取每行，以","号分割，生成数组        arr=(`echo ${line} | awk '{len=split($0,a,","); for(i=1; i&lt;=len; i++) print a[i]}'`)                # 输出数组元素        echo "coustomer: ${arr[0]}, path: ${arr[1]}"done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.runoob.com/linux/linux-comm-cut.html">cut 可以从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出</a> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk -F : 'BEGIN {print "start1, start7"} {print $1 "," $7} END {print "end1, end7"}' /etc/passwd# NF,浏览记录的字段个数（Field) ; NR,已读的记录数, 每行依次递增; awk -F : '{ print NR  " "  NF  " "  $NF}' /etc/passwd  1 7 /bin/bash2 7 /sbin/nologin3 7 /sbin/nologin4 7 /sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><p><code>awk</code> 格式化输出。</p><p>格式符：</p><ul><li><code>%s</code> – 打印字符串；</li><li><code>%d</code> – 打印10进制数；</li><li><code>%f</code> – 打印浮点数；</li><li><code>%x</code> – 打印16进制数；</li><li><code>%o</code> – 打印8进制数；</li><li><code>%e</code> – 打印数字的科学计数法格式；</li><li><code>%c</code> – 打印单个字符的 <code>ASCII</code> 码。</li></ul><p>修饰符：</p><ul><li><code>-</code> – 左对齐；</li><li><code>+</code> – 右对齐；</li><li><code>#</code> – 显示8进制在前面加0，显示16进制在前面加 <code>0x</code> 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf $1}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入上面 <code>awk</code> 命令打印后得到这样的结果： <img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AWKPrintf.png"> 不再像使用 <code>print</code> 命令会默认以换行符作为默认的输出了，而是全部集中在一行，因此使用 <code>printf</code> 需要自定义输出格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf "%s\n",$1}' /etc/passwd # %s表示打印字符串 \n表示换行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <code>printf</code> 在处理多个字段的分隔符上是非常方便的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf "%20s %20s\n",$1,$7}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>%20s</code> 表示 <code>20</code> 个字符，如果实际字符不够会默认使用空格补全</li><li><code>$1</code> 表示第一部分， <code>$7</code> 表示第 <code>7</code> 部分</li></ul><p>默认是右对齐，也可以添加修饰符，使其左对齐：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf "%-20s %-20s\n",$1,$7}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d88954a4d18c4b62bff3bcbdbb8f71f0~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>其它示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"} {printf "%d\n", $3}' /etc/passwd # 打印十进制数字，默认是左对齐的awk 'BEGIN{FS=":"} {printf "%20d\n", $3}' /etc/passwd # %20d 不够的位数默认补全空格，因此它是右对齐awk 'BEGIN{FS=":"} {printf "%f\n", $3}' /etc/passwd # 打印浮点数，默认保留小数点后6位置awk 'BEGIN{FS=":"} {printf "%0.2f\n", $3}' /etc/passwd # 打印浮点数，保留小数点后2位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模式匹配-pattern-1"><a href="#模式匹配-pattern-1" class="headerlink" title="模式匹配 pattern"></a>模式匹配 pattern</h4><p>它与 <code>sed</code> 的 <code>pattern</code> 非常类似，都是<code>按行</code>进行匹配。</p><p>模式匹配的两种用法：</p><ol><li>按正则表达式匹配</li><li>运算符匹配</li></ol><p>正则匹配：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 匹配/etc/passwd文件行中包含root字符串的所有行awk '/root/{print $0}' /etc/passwd# 匹配/etc/passwd文件行中以lion开头的所有行awk '/^lion/{print $0}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运算符匹配：</p><ul><li><code>&lt;</code> 小于</li><li><code>&gt;</code> 大于</li><li><code>&lt;=</code> 小于等于</li><li><code>&gt;=</code> 大于等于</li><li><code>==</code> 等于</li><li><code>!=</code> 不等于</li><li><code>~</code> 匹配正则表达式</li><li><code>!~</code> 不匹配正则表达式</li><li><code>||</code> 或</li><li><code>&amp;&amp;</code> 与</li><li><code>!</code> 非</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以:为分隔符，匹配/etc/passwd文件中第三个字段小于50的所有信息awk 'BEGIN{FS=":"}$3&lt;50{print $0}' /etc/passwd# 输出第三个字段值等于1的行awk 'BEGIN{FS=":"}$3==1{print $0}' /etc/passwd# 输出第七个字段值等于 /bin/bash 的行awk 'BEGIN{FS=":"}$7=="/bin/bash"{print $0}' /etc/passwd# 输出第三个字段值的位数大于3的行awk 'BEGIN{FS=":"}$3~/[0-9]{3,}/{print $0}' /etc/passwd# 以:为分隔符，匹配/etc/passwd文件中第一个字段包含hdfs或yarn的所有行信息awk 'BEGIN{FS=":"}$1=="lion" || $1=="frank" {print $0}' /etc/passwd# 以:为分隔符，匹配/etc/passwd文件中第三个字段小于50并且第四个字段大于50的所有行信息awk 'BEGIN{FS=":"}$3&lt;50 &amp;&amp; $4&gt;50{print $0}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="awk-中的表达式"><a href="#awk-中的表达式" class="headerlink" title="awk 中的表达式"></a>awk 中的表达式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{var=20;var1="aaa";print var,var1}' # 输出 20 aaaawk 'BEGIN{n1=20;n2+=n1;print n1,n2}' # 20 20awk 'BEGIN{n1=20;n2=30;printf "%0.2f\n",n1/n2}' # 输出浮点数，精确到小数点后两位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在 <code>BEGIN</code> 和 <code>END</code> 中都可以正常执行表达式。</p><h5 id="练习：使用-awk-计算-etc-services-中的空白行数量"><a href="#练习：使用-awk-计算-etc-services-中的空白行数量" class="headerlink" title="练习：使用 awk 计算 /etc/services 中的空白行数量"></a>练习：使用 awk 计算 <code>/etc/services</code> 中的空白行数量</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># BEGIN 定义变量，通过正则/^$/匹配到空行后，执行sum++，全面匹配结束后在打印sum的值awk 'BEGIN{sum=0}/^$/{sum++}END{print sum}' /etc/services <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="awk-中的条件语句"><a href="#awk-中的条件语句" class="headerlink" title="awk 中的条件语句"></a>awk 中的条件语句</h4><p>语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if(条件表达式){动作1} else if(条件表达式){动作2}else{动作3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>练习：以冒号为分隔符，只打印 <code>/etc/passwd</code> 中第3个字段的数值在 <code>50-100</code> 范围内的行信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{ if($3&gt;50 &amp;&amp; $3&lt;100){print $0} }' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="awk-中的循环语句"><a href="#awk-中的循环语句" class="headerlink" title="awk 中的循环语句"></a>awk 中的循环语句</h4><p>语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># while 循环while(条件表达式)  动作    # do while 循环do  动作while(条件表达式)  # for循环for(初始化计数器;计数器测试;计数器变更)  动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="计算-1-2-3-…-100-的和"><a href="#计算-1-2-3-…-100-的和" class="headerlink" title="计算 1+2+3+…+100 的和"></a>计算 1+2+3+…+100 的和</h5><p><code>while</code> 循环：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建文件：while.awkBEGIN{  while(i&lt;=100){    sum+=i    i++  }  print sum}执行命令：awk -f while.awk # 以脚本的方式执行awk动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>for</code> 循环：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建文件：for.awkBEGIN{  for(i=0;i&lt;=100;i++)  {  sum+=i  }  print sum}执行命令：awk -f for.awk # 以脚本的方式执行awk动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do...while</code> 循环：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建文件：do-while.awkBEGIN{  do  {    sum+=i    i++  }while(i&lt;=100)  print sum}执行命令：awk -f do-while.awk # 以脚本的方式执行awk动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="awk-字符串函数"><a href="#awk-字符串函数" class="headerlink" title="awk 字符串函数"></a>awk 字符串函数</h4><ul><li><code>length(str)</code> 计算长度；</li><li><code>index(str1,str2)</code> 返回在 <code>str1</code> 中查询到的 <code>str2</code> 的位置；</li><li><code>tolower(str)</code> 小写转换；</li><li><code>toupper(str)</code> 大写转换；</li><li><code>split(str,arr,fs)</code> 分隔符字符串，并保存到数组中；</li><li><code>match(str,RE)</code> 返回正则表达式匹配到的子串位置；</li><li><code>substr(str,m,n)</code> 截取子串，从 <code>m</code> 个字符开始，截取 <code>n</code> 位。若 <code>n</code> 不指定，则默认截取到字符串末尾；</li><li><code>sub(RE,ReqStr,str)</code> 替换查找到的第一个子串；</li><li><code>gsub(RE,ReqStr,str)</code> 替换查找到的所有子串。</li></ul><h5 id="length-str"><a href="#length-str" class="headerlink" title="length(str)"></a>length(str)</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{print length($3)}' /etc/passwd # 计算第三个字段的长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="index-str1-str2"><a href="#index-str1-str2" class="headerlink" title="index(str1,str2)"></a>index(str1,str2)</h5><p>返回在 <code>str1</code> 中查询到的 <code>str2</code> 的位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{print index("I have a dream","ea")}' # 查找ea在字符串中的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="tolower-str"><a href="#tolower-str" class="headerlink" title="tolower(str)"></a>tolower(str)</h5><p>转换为小写字符</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{print tolower("I have a dream")}' # i have a dream<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="toupper-str"><a href="#toupper-str" class="headerlink" title="toupper(str)"></a>toupper(str)</h5><p>转换为大写字符</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{print toupper("I have a dream")}' # I HAVE A DREAM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="split-str-arr-fs"><a href="#split-str-arr-fs" class="headerlink" title="split(str,arr,fs)"></a>split(str,arr,fs)</h5><p>分隔符字符串，并保存到数组中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将字符串"I have a dream"按照空格进行分割awk 'BEGIN{str="I have a dream";split(str,arr," ");for(a in arr) print arr[a]}'# 输出# dream# I# have# a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>for…in</code> 得到是无序的数组。如果需要得到有序数组，需要通过下标获得：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{str="I have a dream";len = split(str,arr," ");for(i=1;i&lt;=len;i++) print arr[i]}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="match-str-RE"><a href="#match-str-RE" class="headerlink" title="match(str,RE)"></a>match(str,RE)</h5><p>返回正则表达式匹配到的子串位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 输出字符串第一个数字出现所在的位置awk 'BEGIN{str="I have 1 dream";print match(str,/[0-9]/)}' # 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="substr-str-m-n"><a href="#substr-str-m-n" class="headerlink" title="substr(str,m,n)"></a>substr(str,m,n)</h5><p>截取子串，从 <code>m</code> 个字符开始，截取 <code>n</code> 位。若 <code>n</code> 不指定，则默认截取到字符串末尾。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 截取字符串"I have a dream"的子串，从第四个位置开始，一直到最后awk 'BEGIN{str="I have a dream";print substr(str,4)}' # ave a dream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="sub-RE-ReqStr-str"><a href="#sub-RE-ReqStr-str" class="headerlink" title="sub(RE,ReqStr,str)"></a>sub(RE,ReqStr,str)</h5><p>替换查找到的第一个子串。</p><ul><li><code>RE</code> 为正则表达式</li><li><code>ReqStr</code> 为要替换的字符串</li><li><code>str</code> 为源字符串</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 替换字符串"I have 123 dream"中第一个数字为$符号awk 'BEGIN{str="I have 123 dream";sub(/[0-9]+/,"$",str);print str}' # I have $ dream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="gsub-RE-ReqStr-str"><a href="#gsub-RE-ReqStr-str" class="headerlink" title="gsub(RE,ReqStr,str)"></a>gsub(RE,ReqStr,str)</h5><p>替换查找到的所有子串</p><ul><li><code>RE</code> 为正则表达式</li><li><code>ReqStr</code> 为要替换的字符串</li><li><code>str</code> 为源字符串</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 替换字符串"I have 123 dream 456"中第一个数字为$符号awk 'BEGIN{str="I have 123 dream 456";gsub(/[0-9]+/,"$",str);print str}' # I have $ dream $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="选项-option-1"><a href="#选项-option-1" class="headerlink" title="选项 option"></a>选项 option</h4><ul><li><code>-v</code> 参数传递</li><li><code>-f</code> 指定脚本文件</li><li><code>-F</code> 指定分隔符</li><li><code>-V</code> 查看 <code>awk</code> 的版本号</li></ul><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p><code>awk</code> 的 <code>BEGIN</code> 中不能直接使用 <code>shell</code> 中定义的变量，需要通过 <code>-v</code> 参数进行传递</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lion ~]# var=20[root@lion ~]# num=30[root@lion ~]# awk -v var1="$var" -v var2="$num" 'BEGIN{print var1,var2}'20 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="指定脚本文件"><a href="#指定脚本文件" class="headerlink" title="指定脚本文件"></a>指定脚本文件</h5><p><code>'BEGIN{}pattern{commands}END{}'</code> 这里的内容可以写在一个独立的文件中，通过 <code>-f</code> 参数来引入。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># test.awkBEGIN{  var=30  print var}awk -f test.awk # 输出30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法更易于编写和维护，适合复杂 <code>awk</code> 语句。</p><h5 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{print length($3)}' /etc/passwd等同于：awk -F : '{print length($3)}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查看-awk-的版本号"><a href="#查看-awk-的版本号" class="headerlink" title="查看 awk 的版本号"></a>查看 awk 的版本号</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lion ~]# awk -VGNU Awk 4.0.2Copyright (C) 1989, 1991-2012 Free Software Foundation....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># data.txt# 要求取反"糗大了": "qd","左哼哼": "zhh","右哼哼": "yhh","快哭了": "kk","左太极": "zuotj","右太极": "youtj","棒棒糖": "bbtang",<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{print (substr($2,0,length($2)-1) ":" $1 ",") }' data.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="awk-处理生产数据实例"><a href="#awk-处理生产数据实例" class="headerlink" title="awk 处理生产数据实例"></a>awk 处理生产数据实例</h4><p>假设有一堆以下格式数据保存在文件 <code>data.txt</code> 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2020-01-01 00:01:01 1000 Batches: user frank insert 2010 records databases:product table:detail, insert 1000 records successfully,failed 1010 records2020-01-01 00:01:02 1001 Batches: user lion insert 1030 records databases:product table:detail, insert 989 records successfully,failed 41 records2020-01-01 00:01:03 1002 Batches: user mike insert 1290 records databases:product table:detail, insert 235 records successfully,failed 1055 records2020-01-01 00:01:04 1003 Batches: user alan insert 3452 records databases:product table:detail, insert 1257 records successfully,failed 2195 records2020-01-01 00:01:05 1004 Batches: user ben insert 4353 records databases:product table:detail, insert 2245 records successfully,failed 2108 records2020-01-01 00:01:06 1005 Batches: user bily insert 5633 records databases:product table:detail, insert 3456 records successfully,failed 2177 records2020-01-01 00:01:07 1006 Batches: user frank insert 2010 records databases:product table:detail, insert 1000 records successfully,failed 1010 records<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计每个人员分别插入了多少条 record 进数据库，预期结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">USERTotal Recordsfrank4020lion  1030...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码演示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># data.awkBEGIN{printf "%-10s %-10s\n", "User", "Total Records"}{USER[$6]+=$8 # USER为数组，空格分割后$6这个变量是用户名，$8是records，每次都去数组中取出$6的值进行相加以获取重复用户的总Records}END{    for(u in USER) # 遍历USER数组，打印数组每一项    {    printf "%-10s %-10d\n", u , USER[u]    }}# awk 语句awk -f data.awk data.txt# 输出结果User       Total Recordsfrank      4020      mike       1290      bily       5633      alan       3452      lion       1030      ben        4353 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="heredocs"><a href="#heredocs" class="headerlink" title="heredocs"></a><strong>heredocs</strong></h2><p> 使用heredocs，可以非常方便的生成一些模板文件： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat&gt;&gt;/etc/rsyncd.conf &lt;&lt; EOFlog file = /usr/local/logs/rsyncd.logtransfer logging = yeslog format = %t %a %m %f %bsyslog facility = local3EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="脚本执行路径"><a href="#脚本执行路径" class="headerlink" title="脚本执行路径"></a>脚本执行路径</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pwd# pwd获得的是当前shell的执行路径，而不是当前脚本的执行路径# /home/will/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 正确的做法应该是下面这两种：script_dir=$(cd $(dirname $0) &amp;&amp; pwd)script_dir=$(dirname $(readlink -f $0 ))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p> 先cd进 当前脚本的目录然后再pwd，或者直接读取当前脚本的所在路径。 </p></blockquote><h2 id="并行化-执行"><a href="#并行化-执行" class="headerlink" title="并行化 执行"></a><strong>并行化 执行</strong></h2><p> shell中最简单的并行化是通过”&amp;”以及”wait”命令来做 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunc(){    #do sth｝for((i=0;i&lt;10;i++))do    func &amp;donewait<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里并行的次数不能太多，否则机器会卡死。</p><p>如果图省事可以使用<strong>parallel</strong>命令来做，或者是用 <strong>xargs</strong> 来处理。</p><h2 id="a到-z的意思"><a href="#a到-z的意思" class="headerlink" title="-a到-z的意思"></a>-a到-z的意思</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ -a FILE ] 如果 FILE 存在则为真。[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。[ -d FILE ] 如果 FILE 存在且是一个目录则为真。[ -e FILE ] 如果 FILE 存在则为真。[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。[ -r FILE ] 如果 FILE 存在且是可读的则为真。[ -s FILE ] 如果 FILE 存在且大小不为o则为真。[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。[ -x FILE ] 如果 FILE 存在且是可执行的则为真。[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。[ -z STRING ] “STRING” 的长度为零则为真。[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。[ STRING1 != STRING2 ] 如果字符串不相等则为真。[ STRING1 &lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。[ STRING1 &gt; STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。[ -z “echo 111s|sed 's/[0-9]//g'” ] &amp;&amp; echo 1 || echo 0 #把字符串中的数字都替换掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[[ $test =~ ^[0-9]+ ]] &amp;&amp; echo 1 || echo 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <code> ~</code> 其实是对后面的正则表达式表示匹配的意思，如果匹配就输出1， 不匹配就输出0 </p><h2 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h2><p>​    <em><strong>*-eq(equal)*</strong></em>   : 测试两个整数是否相等；比如 $A -eq $B</p><p>​    <em><strong>*-ne**(**inequality*</strong></em><em><strong>*)*</strong></em> : 测试两个整数是否不等；不等，为真；相等，为假；</p><p>​    <em><strong>*-gt(greter than)*</strong></em> : 测试一个数是否大于另一个数；大于，为真；否则，为假；</p><p>​    <em><strong>*-lt*</strong></em><em><strong>*(less than)*</strong></em> : 测试一个数是否小于另一个数；小于，为真；否则，为假；</p><p>​    <strong><em>*-ge**(greter equal)**</em>*</strong>: 大于或等于</p><p>​     <em><strong>*-le*</strong></em><em><strong>*(less equal)*</strong></em> ：小于或等于</p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p><a href="http://www.zsythink.net/archives/1199">iptables详解</a></p><h2 id="进程结构体"><a href="#进程结构体" class="headerlink" title="进程结构体"></a>进程结构体</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct task_struct {    // 进程状态    long              state;    // 虚拟内存结构体    struct mm_struct  *mm;    // 进程号    pid_t              pid;    // 指向父进程的指针    struct task_struct __rcu  *parent;    // 子进程列表    struct list_head        children;    // 存放文件系统信息的指针    struct fs_struct        *fs;    // 一个数组，包含该进程打开的文件指针    struct files_struct        *files;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://zhuanlan.zhihu.com/p/389045898">如何让Linux命令在后台运行 - 知乎 (zhihu.com)</a>  </p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
