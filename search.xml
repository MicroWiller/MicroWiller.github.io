<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kernel</title>
      <link href="/2022/07/16/kernel/"/>
      <url>/2022/07/16/kernel/</url>
      
        <content type="html"><![CDATA[<h2 id="从开机加电到执行main函数之前的过程"><a href="#从开机加电到执行main函数之前的过程" class="headerlink" title="从开机加电到执行main函数之前的过程"></a>从开机加电到执行main函数之前的过程</h2><p>第一步，启动BIOS，准备实模式下的中断向量表和中断服务程序；<br>第二步，从启动盘加载操作系统程序到内存，加载操作系统程序的工作就是利用第一步中准备的中断服务程序实现的；<br>第三步，为执行32位的main函数做过渡工作。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p><a href="https://baike.sogou.com/v45346.htm?ch=op.wx.read">BIOS</a>: 是在通电引导阶段 运行硬件初始化，以及为操作系统和程序提供运行时服务的固件。</p><p>启动时BIOS在内存的状态及初始执行位置:</p><p><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/BIOS_inMemory.png" alt="BIOS_inMemory"></p><p>CS（Code Segment Register）：<strong>代码段</strong>寄存器，存在于CPU中，指向CPU <strong>当前执行代码</strong> 在<u>内存中</u>的<strong>区域</strong>（定义了存放代码的存储器的起始地址）。</p><p>IP/EIP（Instruction Pointer）：<strong>指令指针</strong>寄存器，存在于CPU中，记录将要执行的指令在代码段内的偏移地址，和CS组合即为将要执行的指令的内存地址。实模式为绝对地址，指令指针为16位，即IP；保护模式下为线性地址，指令指针为32位，即EIP。</p><p>BIOS程序的入口地址恰恰就是0xFFFF0 ！ 也就是说，BIOS程序的第一条指令就设计在这个位置。</p><p>BIOS在内存中加载中断向量表和中断服务程序：<br><img src="../images/BIOS_loadTable.png"><br><img src="https://gcore.jsdelivr.net/gh/MicroWiller/photobed/BIOS_loadTable.png" alt="BIOS_loadTable"></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2022/05/22/redis/"/>
      <url>/2022/05/22/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="部署运维"><a href="#部署运维" class="headerlink" title="部署运维"></a>部署运维</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -p 6379:6379 -v /will/myredis/data:/data -v /will/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis redis-server /usr/local/etc/redis/redis.conf--appendonly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 连接进入Redisdocker exec -it redis_name /bin/bash./redis-cli# 查询所有的键keys * # 获取键对应的value的类型type key # 删除指定的key valuedel key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ul><li>Redis其实也是多线程？？，只不过是用单线程？？来接收请求，在客户端看起来？？是串行接收执行，所以效果上就是单线程？？。但是<code>IO多路复用</code>？？才是Redis能<strong>高并发</strong>的底层保证。？？</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>Redis 属于单线程还是多线程？</p></blockquote><ul><li><p>Redis 是单线程的，主要是指 Redis 的<strong>网络 I/O</strong> 线程，以及键值的 SET 和 GET 等<strong>读写操作</strong>都是由一个线程来完成</p></li><li><p>但Redis 的持久化、集群同步等操作，则是由另外的线程来执行的</p></li><li><p>可以在无锁的情况下完成所有操作，不存在死锁和线程切换带来的性能和时间上的开销</p></li><li><p>但同时单线程也不能发挥多核 CPU 的性能</p></li></ul><p><a href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8">文件事件处理器</a> </p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=592#/detail/pc?id=6063">需要掌握的Redis原理</a> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisOfHigh.png" style="zoom:50%;"><blockquote><p>单线程的redis为什么这么快</p></blockquote><ul><li>纯内存操作，采用了高效的数据结构，比如哈希表和跳表</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞I/O多路复用机制，因为基于非阻塞的 I/O 模型，就意味着 I/O 的读写流程不再阻塞</li><li>Redis 4.0 版本之后，Redis 添加了多线程的支持，但这时的多线程主要体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等</li><li>Redis 6.0 版本之后，为了更好地提高 Redis 的性能，新增了多线程 I/O 的读写并发能力，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上，所以为了提高网络请求处理的并行度，Redis 6.0 对于网络请求采用多线程来处理。</li><li>但是对于读写命令，Redis 仍然使用单线程来处理。</li></ul><blockquote><p>Reids 为什么先执行命令，再把数据写入日志呢？（写后日志，正好和Mysql的“写前日志”相反）</p></blockquote><ul><li><p>因为 ，Redis 在写入日志之前，不对命令进行<strong>语法检查</strong>；</p></li><li><p>所以，只记录执行成功的命令，避免了出现记录错误命令的情况； </p></li><li><p>并且，在命令执行完之后再记录，<strong>不会阻塞</strong>当前的写操作</p></li></ul><p>这样做也会带来风险：</p><ul><li>数据可能会丢失 </li><li>可能阻塞其他操作： 虽然 AOF 是写后日志，避免阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是<strong>会阻塞后续</strong>的操作无法执行。</li></ul><blockquote><p>RDB 做快照时会阻塞线程吗？</p></blockquote><ul><li>因为 Redis 的单线程模型决定了它所有操作都要尽量避免阻塞主线程，所以对于 RDB 快照也不例外，这关系到是否会降低 Redis 的性能。</li><li>为了解决这个问题，Redis 提供了两个命令来生成 RDB 快照文件，分别是 <strong>save</strong> 和 <strong>bgsave</strong>。save 命令在主线程中执行，会导致阻塞。而 bgsave 命令则会<em>创建一个子进程</em> ，用于写入 RDB 文件的操作，避免了对主线程的阻塞，这也是 Redis RDB 的默认配置。</li></ul><blockquote><p>RDB 做快照的时候数据能修改吗？</p></blockquote><p><strong>这个问题非常重要</strong>，考察候选人对 RDB 的技术掌握得够不够深。你可以思考一下，如果在执行快照的过程中，数据如果能被修改或者不能被修改都会带来什么影响？</p><ol><li>如果此时可以执行写操作：意味着 Redis 还能正常处理写操作，就可能出现正在执行快照的数据是已经被修改了的情况；</li><li>如果此时不可以执行写操作：意味着 Redis 的所有写操作都得等到快照执行完成之后才能执行，那么就又出现了阻塞主线程的问题。</li></ol><p>那Redis 是如何解决这个问题的呢？ 它利用了 bgsave 的子进程，具体操作如下：</p><ul><li>如果主线程执行<em>读操作</em>，则主线程和 bgsave 子进程互相不影响；</li><li>如果主线程执行<em>写操作</em>，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RDB_ProcessOfRedis.png" style="zoom:67%;"><blockquote><p>redis的常用数据结构</p></blockquote><ul><li>string/hash/list/set/sortedsort</li></ul><blockquote><p>zset的数据结构</p></blockquote><ul><li>set 关联一个double类型的分数 ==&gt;有序集合</li></ul><blockquote><p>zset的中插入一个元素的时间复杂度</p></blockquote><ul><li>向有序集合添加 score和element 的时间复杂度为 O(logN)   ||  删除或获取element的时间复杂度都为O(1)</li></ul><blockquote><p>redis如何保证高可用？</p></blockquote><ul><li>redis持久化机制【dump.rdb/appendonly.aof】、主从复制、哨兵机制</li></ul><blockquote><p>什么是redis的哨兵模式？</p></blockquote><ul><li>通过后台监测主机是否宕机，如果宕机了按投票选举，票数多的从机成为新的主机，整个过程是自动的</li></ul><blockquote><p>缓存穿透、缓存击穿、缓存雪崩区别和解决方案</p></blockquote><ul><li><a href="https://blog.csdn.net/kongtiao5/article/details/82771694">详细内容</a></li></ul><p></p><h2 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h2><p> <strong>通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升</strong> </p><p>•缓存（数据查询、短连接、新闻内容、商品内容等等）<br>•聊天室的在线好友列表<br>•任务队列（秒杀、抢购、12306等等）<br>•应用排行榜  (zsort)<br>•网站访问统计<br>•数据过期处理（可以精确到毫秒)<br>•分布式集群架构中的session分离</p><h2 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 类似Map&lt;string, value&gt;;    // key 都是字符串类型// 而且其他几种数据结构都是在字符串类型基础上构建的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="value的数据结构"><a href="#value的数据结构" class="headerlink" title="value的数据结构"></a>value的数据结构</h3><table><thead><tr><th align="left">类型</th><th align="center">类似</th><th align="center">备注</th></tr></thead><tbody><tr><td align="left">字符串</td><td align="center">string</td><td align="center">可以存放数字，并加减；但需进行转换成int64</td></tr><tr><td align="left">哈希</td><td align="center">hash</td><td align="center">map&lt;key, value&gt;</td></tr><tr><td align="left">列表</td><td align="center">linkedlist</td><td align="center">双端节点, 支持重复元素</td></tr><tr><td align="left">集合</td><td align="center">hashSet</td><td align="center">不允许重复元素</td></tr><tr><td align="left">有序集合</td><td align="center">sortedset</td><td align="center">不允许重复元素，且元素有顺序</td></tr></tbody></table><p>Redis的数据结构：<br>        <img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/DataStructureOfRedis.png"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisStringCommand.png" style="zoom:47%;"><h4 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h4><p>字符串类型的内部编码有3种：</p><ul><li>int：8个字节的长整型</li><li>embstr：小于等于39个字节的字符串</li><li>raw：大于39个字节的字符串</li></ul><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisHashCommand.png" style="zoom:67%;"><h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认<strong>512</strong>个）、同时所有值都小于hash-max-ziplist-value配置（默认<strong>64字节</strong>）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</li><li>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O(1)。</li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/InterStructOfRedisHash.png" style="zoom:67%;"><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表中的每个字符串称为元素（element），一个列表最多可以存储2^32-1个元素</p><p>列表两端插入和弹出操作：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisLIstOfPushAndPop.png" style="zoom:67%;"><p>子列表获取、删除等操作：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisLIstOfGetAndDel.png" style="zoom:67%;"><p>列表类型有两个特点：</p><p>第一、列表中的元素是有序的</p><ul><li>可以通过索引下标获取某个元素或者某个范围内的元素列表</li></ul><p>第二、列表中的元素可以是重复的</p><blockquote><p>这两个特点和集合/有序集合比较后，会显得更加突出，因此在考虑是否使用该数据结构前，首先需要弄清楚列表数据结构的特点。</p></blockquote><h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisCommandOfList.png" style="zoom:67%;"><ul><li>索引下标有两个特点：</li><li>第一，索引下标<strong>从左到右分别是0到N-1</strong>，但是<strong>从右到左分别是-1到-N</strong>。</li><li>第二，lrange中的<strong>end选项包含了自身</strong>，这个和很多编程语言不包含end不太相同，lrange操作会获取列表指定索引范围所有的元素。</li></ul><h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisOfSet.png" style="zoom:67%;"><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><ul><li><p>intset（整数集合）</p><p>当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）将会使用intset来作为集合的内部实现，从而减少内存的使用。</p></li><li><p>hashtable（哈希表）</p><p>当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisDifferentOfLIstAndSet.png" style="zoom:67%;"><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisOfZsetOfCommand.png" style="zoom:67%;"><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><table><thead><tr><th align="center">基础数据类型</th><th align="center">可能的编码方式</th></tr></thead><tbody><tr><td align="center">字符串</td><td align="center">int, embstr, raw</td></tr><tr><td align="center">列表</td><td align="center">之前是 ziplist, linkedlist。3.2开始都是quicklist</td></tr><tr><td align="center">集合</td><td align="center">intset, hashtable</td></tr><tr><td align="center">有序集合</td><td align="center">ziplist, skiplist, ??hash??</td></tr><tr><td align="center">散列</td><td align="center">ziplist, hashtable</td></tr></tbody></table><p>参考：<a href="https://mp.weixin.qq.com/s/DZexS3gy_xdxxp2tsuHE3w">一文理解Redis底层数据结构</a> </p><h2 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h2><p> <a href="https://www.cnblogs.com/javastack/p/12848446.html">Redis 到底是单线程还是多线程？</a> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/SingleThreadOfRedis.png" style="zoom:57%;"><ul><li>文件事件处理器：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。</li><li>因为文件事件分派器队列的<strong>消费</strong>是单线程的，所以Redis才叫单线程模型。</li></ul><h2 id="穿透-x2F-击穿-x2F-雪崩"><a href="#穿透-x2F-击穿-x2F-雪崩" class="headerlink" title="穿透/击穿/雪崩"></a>穿透/击穿/雪崩</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247486528&amp;idx=1&amp;sn=3f7b09eb21969fdb16f5b0805ff69fed&amp;scene=21#wechat_redirect">小故事</a></p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/BUfferDesign.png" style="zoom:67%;"><ul><li><p><strong>缓存击穿</strong>：缓存中没有，但数据库中有的数据</p></li><li><p><strong>缓存穿透</strong>：缓存和数据库中都没有的数据，并发查同一条数据</p><ul><li>解决：</li><li>最常见的则是采用<em>布隆过滤器</em>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li><li>还有一个更为<strong>简单粗暴的方法</strong>，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟</li></ul></li><li><p><strong>缓存雪崩</strong>：缓存中数据大批量到过期时间</p><ul><li>解决：</li><li>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上</li><li>还有一个简单方案就是<u><em>分散开</em></u> 缓存失效时间</li></ul></li></ul><h2 id="缓存过期-x2F-内存淘汰"><a href="#缓存过期-x2F-内存淘汰" class="headerlink" title="缓存过期/内存淘汰"></a>缓存过期/内存淘汰</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1779">过期淘汰策略和内存淘汰策略有什么区别</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247486528&amp;idx=1&amp;sn=3f7b09eb21969fdb16f5b0805ff69fed&amp;scene=21#wechat_redirect">个中原由</a></p><h3 id="过期淘汰策略"><a href="#过期淘汰策略" class="headerlink" title="过期淘汰策略"></a>过期淘汰策略</h3><p><strong>新增</strong> Redis 缓存时可以<strong>设置缓存的过期时间</strong>，该时间保证了数据在规定的时间内失效，可以借助这个特性来实现很多功能</p><ul><li>超时时间有了，该在什么时候去干这个清理的活呢？ ？</li><li>不能一口气把所有过期的都给删除掉，redis里面存了大量的数据，要全面扫一遍的话那不知道要花多久时间，会严重影响接待新的客户请求！！</li></ul><p>时间紧任务重，只好随机选择一部分来清理，能缓解内存压力就行！！！</p><p><strong>缓存过期策略：</strong></p><ul><li>惰性删除： 原来逃脱了redis 随机选择算法的键值，*<u>一旦遇到查询请求，被发现已经超期了，立即删除</u>*； 是被动式触发的，不查询就不会发生；导致缓存中出现<code>大量的过期key无法被删除</code></li><li>定时删除：为每个设置了过期时间的key，都需要*<u>创建一个定时器，到过期时间就会立即清除</u>*；但需要消耗大量的CPU资源去清除过期的数据，<code>可能会影响缓存服务的性能</code> </li><li>定期过期：添加一个<code>即将过期的缓存字典</code>，*<u>每隔一定的时间，会扫描一定数量的key</u>*，并清除其中已过期的key</li></ul><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看当前 Redis 的内存淘汰策略config get maxmemory-policy# 修改内存淘汰策略的方式，无需重启 Redis 服务器，次重启 Redis 服务器之后设置的内存淘汰策略就会丢失config set maxmemory-policy noeviction# 也可以通过配置文件来修改，redis.conf 对应的配置项是“maxmemory-policy noeviction”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>noeviction：不淘汰任何数据，当内存不足时，执行缓存新增操作会报错，它是 Redis 默认内存淘汰策略</li><li>allkeys-lru：淘汰整个键值中最久未使用的键值</li><li>allkeys-random：随机淘汰任意键值</li><li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值</li><li>volatile-random：随机淘汰设置了过期时间的任意键值</li><li>volatile-ttl：优先淘汰更早过期的键值</li><li>volatile-lfu，淘汰所有设置了过期时间的键值中最少使用的键值</li><li>allkeys-lfu，淘汰整个键值中最少使用的键值</li></ul><blockquote><p>小贴士：从以上内存淘汰策略中可以看出，allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p></blockquote><p><strong>内存淘汰算法：</strong> </p><p>LRU（ Least Recently Used，最近最少使用）淘汰算法：是一种常用的页面置换算法，也就是说<code>最久没有使用</code>的缓存将会被淘汰</p><p>LFU（Least Frequently Used，最不常用的）淘汰算法：最不常用的算法是根据<code>总访问次数</code>来淘汰数据的，它的核心思想是***<u>“如果数据过去被访问多次，那么将来被访问的频率也更高”</u>***。</p><p>LFU 相对来说比 LRU 更“智能”，因为它解决了使用频率很低的缓存，只是最近被访问了一次就不会被删除的问题。</p><p>LRU？？可以继承 LinkedHashMap来实现</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1782">高可用</a></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247486926&amp;idx=1&amp;sn=58e99f81d6d6ee31c9a5c8f93122e108&amp;scene=21#wechat_redirect">RDB / AOF</a></p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis DataBase（<strong>快照</strong>方式）：按照一定的 <u><em>时间周期策略</em></u> 把内存的数据以快照的形式保存到硬盘的二进制文件。</p><p>实现：</p><ol><li>单独fork()创建一个子进程</li><li>将当前父进程的全部数据复制到子进程的内存中，然后由子进程写入到临时文件中(需上一个持久化的过程结束了)</li><li>再用这个<strong>临时文件</strong> <u><em>覆盖</em></u> 上次的快照文件</li><li>然后子进程退出，内存释放</li></ol><p>在一定的间隔时间中，<strong>检测key的变化情况</strong>，然后持久化数据</p><ol><li><p>编辑redis.windwos.conf文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重新启动redis服务器，并指定配置文件名称<br>…\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf</p></li></ol><p></p><ul><li>RDB 默认的保存文件为 dump.rdb</li><li>优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑</li><li>与 AOF 相比，RDB 具备更快的重启恢复能力</li><li>RDB对Redis对外提供的读写服务，影响非常小，可以让Redis保持高性能，因为Redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>Append Only File（文件追加方式）：将每一个<strong>收到的写命令</strong>都通过Write函数追加到文件最后，类似于MySQL的binlog</p><ul><li>当Redis重启，会通过重新执行文件中，保存的写命令来在内存中重建整个数据内容</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly no（关闭aof） --&gt; appendonly yes （开启aof）appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化appendfsync no ： 不进行持久化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>AOF 默认的保存文件为 appendonly.aof</li><li>优点是存储频率更高，因此丢失数据的风险就越低，并且 AOF 并不是以二进制存储，存储信息更易懂</li><li>缺点是占用空间大，重启之后的数据恢复速度比较慢 （大到一定程度，redis会进行 rewrite操作）</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>AOF可以更好的保护数据不丢失，一般每隔1S，通过一个后台线程执行一次<strong>fsync</strong>操作，保证 os cache中的数据写入磁盘，最多丢失1秒数据</li><li>AOF日志文件以append-only模式写入，所以没有任何<strong>磁盘寻址</strong>开销，写入性能高，而且文件不容易破损；即使文件破损，也有工具可以恢复</li><li>AOF文件过大时候，会出现<strong>rewrite</strong>操作，但并不影响客户端的读写；因为在rewrite log的时候，会对其中的数据进行压缩，创建出一份需要恢复数据的最小日志出来；在创建新日志文件的时候，老的日志文件还是照常写入，当新的merge后的日志文件ready的时候，再交换新老日志文件即可；基于redis当前内存中最新的数据进行<strong>指令的重新构建</strong> </li><li>AOF日志文件的命令通过，可读的方式进行记录，这个特性非常适合做灾难新的误删除的紧急恢复</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>占用磁盘空间更多</li><li>做数据恢复比较慢，冷备不太方便</li></ol><h5 id="Rewrite过程"><a href="#Rewrite过程" class="headerlink" title="Rewrite过程"></a>Rewrite过程</h5><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AOF Rewrite.png" alt="AOF Rewrite" style="zoom:67%;"><h5 id="AOF文件修复"><a href="#AOF文件修复" class="headerlink" title="AOF文件修复"></a>AOF文件修复</h5><p>如果redis <strong>在append数据到AOF文件时</strong>，<em>机器宕机了</em>，可能会导致AOF文件破损(只保存到完整命令的一部分)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修复方法./redis-check-aof [--fix] &lt;file.aof&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>Redis 4.0 推出了<strong>混合</strong>持久化</p><p>混合持久化的功能指的是 Redis 可以使用 RDB + AOF 两种格式来进行数据持久化 </p><p>AOF 和 RDB 混合的数据持久化机制： 把数据以 RDB 的方式写入文件，再将后续的操作命令以 AOF 的格式存入文件，既保证了 Redis 重启速度，又降低数据丢失风险。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; config get aof-use-rdb-preamble1) "aof-use-rdb-preamble"2) "yes"# 打开config set aof-use-rdb-preamble yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Redis 混合持久化的存储模式是，开始的数据以 RDB 的格式进行存储，因此只会占用少量的空间</li><li>之后的命令会以 AOF 的方式进行数据追加，这样就可以减低数据丢失的风险，同时可以提高数据恢复的速度</li><li>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AOF%E5%92%8CRDB%E5%90%8C%E6%97%B6%E5%B7%A5%E4%BD%9C.png"></p><p>Redis企业级备份：</p><p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisBackup.png" alt=""></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><blockquote><p>Redis主从架构 -&gt; 读写分离架构 -&gt; 可支持水平扩展的读高并发架构</p></blockquote><ul><li>写多读少的业务，得考虑MQ，做异步分离</li></ul><h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ReplicationTheroyOfRedis.png" style="zoom:80%;"><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyNjMxOTY0NA==&amp;mid=2247487533&amp;idx=1&amp;sn=49b600ef7eac342dad1f5a8048361099&amp;scene=21#wechat_redirect">Redis主从复制/哨兵模式的原理解析</a>  </p><p>全量复制使用<code>snyc</code>命令来实现，其流程是：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisSnyc.png" style="zoom:67%;"><p>旧版本全量复制功能，其最大的问题是从服务器断线重连时，<strong>即便</strong>在从服务器上已经有一部分数据了，也需要进行全量复制，这样做的<code>效率很低</code>，于是新版本的redis在这部分做了改进？？<strong>序列号</strong></p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisNumber.png" style="zoom:67%;"><p>新版本redis使用==psync==命令来代替sync命令，该命令既可以实现完整全同步也可以实现部分同步。</p><ol><li><strong>复制偏移量</strong>：<ul><li>执行复制的双方，主从服务器，分别会维护一个复制偏移量：</li><li>主服务器每次向从服务器同步了N字节数据之后，将修改自己的复制偏移量+N。</li><li>从服务器每次从主服务器同步了N字节数据之后，将修改自己的复制偏移量+N。</li></ul></li><li><strong>复制积压缓冲区</strong>：<ul><li>主服务器内部维护了一个固定长度的先进先出队列做为复制积压缓冲区，其默认大小为1MB。</li><li>在主服务器进行命令传播时，不仅会将写命令同步到从服务器，还会将写命令写入复制积压缓冲区。</li></ul></li></ol><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p> Redis 哨兵模块存储在 Redis 的 src/redis-sentinel 目录下 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动哨兵功能./src/redis-sentinel sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>三个监控任务：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisSentinel;.png" style="zoom:67%;"><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisBetweenSentinel.png" style="zoom:50%;"><blockquote><p>每隔2秒，每个哨兵节点将会向redis数据节点的__sentinel__:hello频道同步自身得到的主节点信息以及当前哨兵节点的信息</p><p>由于其他哨兵节点也订阅了这个频道，因此实际上这个操作可以<strong>交换</strong>哨兵节点之间关于主节点以及哨兵节点的信息。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/RedisSentinelTheory.png" style="zoom:57%;"><blockquote><p>哨兵的工作原理是每个哨兵会以每秒钟 1 次的频率，向已知的主服务器和从服务器，发送一个 PING 命令。</p><p>如果最后一次有效回复 PING 命令的时间，超过了配置的最大下线时间（Down-After-Milliseconds）时，默认是 30s，那么这个实例会被哨兵标记为主观下线。 </p><p>如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有哨兵节点，要以每秒 1 次的频率确认主服务器是否进入了主观下线的状态。</p><p>如果有足够数量（quorum 配置值）的哨兵证实该主服务器为主观下线，那么这个主服务器被标记为客观下线。</p><p>此时所有的哨兵会按照规则（协商）自动选出新的主节点服务器，并自动完成主服务器的自动切换功能，而整个过程都是无须人工干预的。 </p></blockquote><p>发现新的哨兵节点：</p><p>如果有新的哨兵节点加入，此时保存下来这个新哨兵节点的信息，后续与该哨兵节点建立连接。<br>交换主节点的状态信息，作为后续客观判断主节点下线的依据。</p><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>Redis Cluster 是一种分布式去中心化的运行模式，是在 Redis 3.0 版本中推出的 Redis 集群方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><img src="Redis.assets/image-20210424232749103.png" alt="image-20210424232749103" style="zoom:67%;"><p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。</p><ul><li><p>根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。</p></li><li><p>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽</p></li></ul><p>剩下的一个问题就是，这些哈希槽怎么被映射到具体的 Redis 实例上的呢？有两种方案。</p><ul><li><p>平均分配： 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群实例上。比如集群中有 9 个实例，则每个实例上槽的个数为 16384/9 个。</p></li><li><p>手动分配： 可以使用 cluster meet 命令手动建立实例间的连接，组成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数，</p></li></ul><p>数据、哈希槽，以及实例三者的映射分布关系：</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1780">来龙去脉</a></p><p>分布式锁是<em>控制</em>  <strong>分布式系统之间</strong> <u>同步访问</u> <strong>共享资源</strong> 的一种方式。</p><p>是为了解决分布式系统中，不同的系统或是同一个系统的不同主机<strong>共享同一个资源</strong>的问题，它通常会采用<strong>互斥</strong>来保证程序的一致性，这就是分布式锁的用途以及执行原理。</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/DistributeOfRedis.png" style="zoom:57%;"><p>分布式锁的常见实现方式有四种：</p><ul><li>基于 MySQL 的悲观锁来实现分布式锁，这种方式使用的最少，因为这种实现方式的性能不好，且容易造成死锁</li><li>基于 Memcached 实现分布式锁，可使用 add 方法来实现，如果添加成功了则表示分布式锁创建成功</li><li>基于 Redis 实现分布式锁，这也是要介绍的重点，使用 <code>setnx</code> 方法来实现，set if not exists（不存在则创建）</li><li>基于 ZooKeeper 实现分布式锁，利用 ZooKeeper <strong>顺序临时节点</strong>来实现</li></ul><p><strong>分布式锁得以实现的基本前提：</strong> </p><p>之所以可以使用以上四种方式来实现分布式锁，是因为以上四种方式都属于程序调用的“<code>外部系统</code>”，而分布式的程序是需要<strong>共享</strong>“外部系统”的</p><h2 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h2><p>一、</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setnx lock true(integer) 1 #创建锁成功#逻辑业务处理...127.0.0.1:6379&gt; del lock(integer) 1 #释放锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码有一个问题，就是<strong>没有设置锁的超时时间</strong> </p><p>如果出现异常情况，会导致锁未被释放，而其他线程又在排队等待此锁就会导致程序不可用</p><p>二、</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setnx lock true(integer) 1 #创建锁成功127.0.0.1:6379&gt; expire lock 30 #设置锁的(过期)超时时间为 30s(integer) 1 #逻辑业务处理...127.0.0.1:6379&gt; del lock(integer) 1 #释放锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这样执行仍然会有问题，因为 setnx lock true 和 expire lock 30 命令是<strong>非原子的</strong>  </p><p> 如果在 setnx 命令执行完之后，发生了异常情况，那么就会导致 expire 命令不会执行，因此依然没有解决死锁的问题</p><p>三、</p><p> Redis 2.6.12 中我们可以使用一条 set 命令来执行键值存储，并且可以判断键是否存在以及设置超时时间了，如下代码所示： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set lock true ex 30 nxOK #创建锁成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>ex 是用来设置超时时间的，expire</li><li>nx 是 not exists 的意思，用来判断键是否存在 </li><li>“OK”则表示创建锁成功，否则表示此锁有人在使用</li></ul><p>四、</p><p> 锁误删：</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/20210220182119.png" style="zoom:67%;"> <p>锁被误删的解决方案是在使用 set 命令创建锁时，给 value 值设置一个归属标识。</p><p>例如，在 value 中插入一个 UUID，每次在删除之前先要判断 UUID 是不是属于当前的线程，如果属于再删除，这样就避免了锁被误删的问题。 </p><p>五、</p><p> 注意：在锁的归属判断和删除的过程中，<em>不能</em> 先判断锁再删除锁，如下代码所示： </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(uuid.equals(uuid)){ // 判断是否是自己的锁del(luck); // 删除锁}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 把判断和删除放到一个<strong>原子单元</strong>中去执行，因此需要借助 Lua 脚本来执行 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 释放分布式锁 * @param jedis Redis客户端 * @param lockKey 锁的 key * @param flagId 锁归属标识 * @return 是否释放成功 */public static boolean unLock(Jedis jedis, String lockKey, String flagId) {    String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(flagId));    if ("1L".equals(result)) { // 判断执行结果        return true;    }    return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>六、</p><p>锁超时可以通过两种方案来解决：</p><ul><li>把执行耗时的方法从锁中剔除，减少锁中代码的执行时间，保证锁在超时之前，代码一定可以执行完；</li><li>把锁的超时时间设置的长一些，正常情况下我们在使用完锁之后，会调用删除的方法手动删除锁，因此可以把超时时间设置的稍微长一些。</li></ul><h2 id="Redis-实现消息队列"><a href="#Redis-实现消息队列" class="headerlink" title="Redis 实现消息队列"></a>Redis 实现消息队列</h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=59#/detail/pc?id=1781">Redis如何实现消息队列？？实现的方式有几种？？</a></p><table><thead><tr><th>实现方式</th><th align="center">持久化</th><th align="center">重复消费</th><th align="center">主题订阅</th><th align="center">消费消息确认</th><th align="center">延迟消息队列</th></tr></thead><tbody><tr><td>List (2.0 之前)</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr><tr><td>Zset (2.0 之前)</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">Y</td></tr><tr><td>Publisher/Subscriber (2.0 之后)</td><td align="center">N</td><td align="center">N</td><td align="center">Y</td><td align="center">N</td><td align="center"></td></tr><tr><td>Stream (5.0 之后)</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center"></td></tr></tbody></table><ul><li>List和Zset 可以借助 Redis 本身的持久化功能，AOF 或者是 RDB 或混合持久化的方式，用于把数据保存至磁盘</li></ul><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>下载jedis的jar包</li><li>使用</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">      //1. 获取连接Jedis jedis = new Jedis("localhost",6379);//2. 操作jedis.set("username","zhangsan");//3. 关闭连接jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">   //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口//2. 操作//存储jedis.set("username","zhangsan");//获取String username = jedis.get("username");System.out.println(username);//可以使用setex()方法存储可以 "指定过期时间的 key value"jedis.setex("activecode",20,"hehe");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对//3. 关闭连接jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p> map格式  </p><pre><code>        hset        hget        hgetAll</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">   //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口//2. 操作// 存储hashjedis.hset("user","name","lisi");jedis.hset("user","age","23");jedis.hset("user","gender","female");// 获取hashString name = jedis.hget("user", "name");System.out.println(name);// 获取hash的所有map中的数据// Map结构中存储的全是 stringMap&lt;String, String&gt; user = jedis.hgetAll("user");// 得到所有keyset（field）Set&lt;String&gt; keySet = user.keySet();for (String key : keySet) {    //获取value    String value = user.get(key);    System.out.println(key + ":" + value);}//3. 关闭连接jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>linkedlist格式。支持重复元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1. 获取连接     Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口     //2. 操作     // list 存储     jedis.lpush("mylist","a","b","c");//从左边存     jedis.rpush("mylist","a","b","c");//从右边存     // list 范围获取     List&lt;String&gt; mylist = jedis.lrange("mylist", 0, -1);     System.out.println(mylist);          // list 弹出     String element1 = jedis.lpop("mylist");//c     System.out.println(element1);     String element2 = jedis.rpop("mylist");//c     System.out.println(element2);     // list 范围获取     List&lt;String&gt; mylist2 = jedis.lrange("mylist", 0, -1);     System.out.println(mylist2);     //3. 关闭连接     jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p> 不允许重复元素</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1. 获取连接      Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口      //2. 操作      // set 存储      jedis.sadd("myset","java","php","c++");      // set 获取      Set&lt;String&gt; myset = jedis.smembers("myset");      System.out.println(myset);      //3. 关闭连接      jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sortedset"><a href="#sortedset" class="headerlink" title="sortedset"></a>sortedset</h4><p>不允许重复元素，且元素有顺序, 分数可以覆盖（排行榜，热搜）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1. 获取连接      Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口      //2. 操作      // sortedset 存储      jedis.zadd("mysortedset",3,"亚瑟");      jedis.zadd("mysortedset",30,"后裔");      jedis.zadd("mysortedset",55,"孙悟空");      // sortedset 获取      Set&lt;String&gt; mysortedset = jedis.zrange("mysortedset", 0, -1);      System.out.println(mysortedset);      //3. 关闭连接      jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><h4 id="JedisPool"><a href="#JedisPool" class="headerlink" title="JedisPool"></a>JedisPool</h4><ol><li>创建JedisPool连接池对象</li><li>调用方法 getResource()方法获取Jedis连接</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//0.创建一个配置对象      JedisPoolConfig config = new JedisPoolConfig();      config.setMaxTotal(50);      config.setMaxIdle(10);      //1.创建Jedis连接池对象      JedisPool jedisPool = new JedisPool(config,"localhost",6379);      //2.获取连接      Jedis jedis = jedisPool.getResource();      //3. 使用      jedis.set("hehe","heihei");      //4. 关闭 归还到连接池中      jedis.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JedisPoolUtils {    private static JedisPool jedisPool;    static{        //读取配置文件        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");        //创建Properties对象        Properties pro = new Properties();        //关联文件        try {            pro.load(is);        } catch (IOException e) {            e.printStackTrace();        }        //获取数据，设置到JedisPoolConfig中        JedisPoolConfig config = new JedisPoolConfig();        config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal")));        config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle")));        //初始化JedisPool        jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port")));    }    /**     * 获取连接方法     */    public static Jedis getJedis(){        return jedisPool.getResource();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go</title>
      <link href="/2022/05/22/go/"/>
      <url>/2022/05/22/go/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a href="https://gocn.vip/topics/Go488nfroE">字符串处理细节</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483777&amp;idx=1&amp;sn=d3d108abe68c282a4d291a432559f2cc&amp;scene=21#wechat_redirect">nil切片和空切片</a>：<code>数组指针地址都分别指向哪儿</code> </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483698&amp;idx=1&amp;sn=352a5cddf20fe95f5ec26bfc9a6de64b&amp;scene=21#wechat_redirect">json包变量不加tag会怎么样</a>：<code>Marshal</code> [Struct Tag](#Struct Tag)</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485846&amp;idx=2&amp;sn=033931d22730a24128915d8498c9e3fb&amp;source=41#wechat_redirect">这样理解 Go 闭包，就不会出错了 (qq.com)</a>：将引用环境和函数结合的使用方法 / 变量什么情况下 是指针，什么情况下为值</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483686&amp;idx=1&amp;sn=e48c51107191f02da5751a19a54f7d41&amp;chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&amp;token=2092782362&amp;lang=zh_CN&amp;scene=21#wechat_redirect">什么是内存逃逸</a>：<code>从栈逃到堆上</code> / <code>典型场景</code></p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483692&amp;idx=1&amp;sn=d5d34fad7a4553e0b9d5714385b7af48&amp;chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&amp;token=961196008&amp;lang=zh_CN&amp;scene=21#wechat_redirect">怎么避免内存逃逸</a>：<code>noescape</code></p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483669&amp;idx=1&amp;sn=88f754ddabc04eb3f66ba8ac37ee1461&amp;chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&amp;token=2092782362&amp;lang=zh_CN&amp;scene=21#wechat_redirect">字符串转成byte数组</a>： <a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D">零拷贝</a>  </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483735&amp;idx=1&amp;sn=6ab8ac319dc1857acf44c9bb9d21c7c3&amp;scene=21#wechat_redirect">对已经关闭的的chan进行读写，会怎么样</a>：<code>读：关闭前是否有值</code> / <code>写：Panic</code>  </p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&amp;mid=2247483717&amp;idx=1&amp;sn=0c0385234cd70d72d424eb7097ebfe9a&amp;scene=21#wechat_redirect">对未初始化的的 chan 进行读写，会怎么样</a>：<code>都会阻塞</code></p><p><a href="https://zhuanlan.zhihu.com/p/344834329">深度解密Go语言之sync.map - 知乎 (zhihu.com)</a>：读写map，两个map，read读 / dirty写</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MDYwODc5Nw==&amp;mid=2247484826&amp;idx=1&amp;sn=cb882a297bf84f986168bc6d613a7b28&amp;scene=21#wechat_redirect">学了这么久GO，这篇文章让我读懂了汇编！ (qq.com)</a>：<strong>caller-save模式</strong>，一般在汇编中参数和返回值被放在调用方的栈中，因此Go弄了一个伪寄存器用于实现Go的汇编结构。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjczMjkzMQ==&amp;mid=2247485773&amp;idx=1&amp;sn=0e03c22500f836512fb4016c2a111887&amp;source=41#wechat_redirect">盘点一下 Go语言的“黑暗角落” (qq.com)</a>：<a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%99%90%E5%88%B6">数组细节</a> / For循环迭代器变量被重用</p><p><a href="https://studygolang.com/articles/23242?fr=sidebar">atomic.Value 源码解析</a>：</p><p><a href="https://coolshell.cn/articles/21615.html">泛型编程</a>：</p><p><a href="https://juejin.cn/post/6965421491588431909">sync.Pool原理解析</a>：减少小块对象内存频繁申请（帮助在程序构建了对象池，提供对象可复用能力，本身是可伸缩且并发安全的。）</p><p>[深度分析 Golang sync.Pool 底层原理](<a href="https://www.cyhone.com/articles/think-in-sync-pool/#:~:text=sync.Pool">https://www.cyhone.com/articles/think-in-sync-pool/#:~:text=sync.Pool</a> 是 Golang,内置的对象池技术，可用于缓存临时对象，避免因频繁建立临时对象所带来的消耗以及对 GC 造成的压力。?msclkid=0e13220fd0fa11ec8c4b5655473f1d3d)：pool的内部数据结构 / CPU cache</p><h2 id="Go实战"><a href="#Go实战" class="headerlink" title="Go实战"></a>Go实战</h2><p><a href="https://juejin.cn/post/7126753651455950856">err 的优雅处理</a>: 错误是值</p><p><a href="https://zhuanlan.zhihu.com/p/114340283">Go进程的HeapReleased上升，但是RSS不下降造成内存泄漏？ - 知乎 (zhihu.com)</a>：</p><p><a href="https://pengrl.com/p/20031/">Go pprof内存指标含义备忘录 | yoko blog (pengrl.com)</a>：各种概念介绍</p><p><a href="https://mp.weixin.qq.com/s/OyiF57PcMQjeoGpShEgidQ">Go 的json 解析标准库竟然存在这样的陷阱？</a>：神技、版本变更兼容</p><p><a href="https://mp.weixin.qq.com/s/FyHEiaa-UfyLStMKl2VFGA">golang：快来抓住让我内存泄漏的“真凶”！</a> ：golang10次内存泄漏，8次goroutine泄漏，1次是真正内存泄漏，<strong>还有1次是cgo导致的内存泄漏</strong>。</p><p><a href="https://www.golangprograms.com/goroutines-and-channels-example.html">Goroutines and Channels Exercises</a></p><p><a href="https://mp.weixin.qq.com/s/PjNc7YLKT5JX_Obg2815Bg">DDD 到底是银弹还是垃圾 (qq.com)</a>：防腐层 等各种名词介绍</p><p> <a href="https://zhuanlan.zhihu.com/p/26695984">今日头条Go建千亿级微服务的实践</a>：<code>并发控制</code> / <code>超时控制</code> /</p><p><strong>wait：</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func makeThumbnails6(filenames &lt;-chan string) int64 {    sizes := make(chan int64)    var wg sync.WaitGroup // number of working goroutines    for f := range filenames {        wg.Add(1)        // worker        go func(f string) {            defer wg.Done()            thumb, err := thumbnail.ImageFile(f)            if err != nil {                log.Println(err)                return            }            info, _ := os.Stat(thumb) // OK to ignore error            sizes &lt;- info.Size()        }(f)    }    // closer    go func() {        wg.Wait()        close(sizes)    }()    var total int64    for size := range sizes {        total += size    }    return total}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   wg := sync.WaitGroup{}wg.Add(3)go func() {defer wg.Done()// do ...}()go func() {defer wg.Done()// do ...}()go func() {defer wg.Done()// do ...}()wg.Wait()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Cancle：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   ctx := context.Background()ctx, cancle := context.WithCancel(ctx)go Proc(ctx)go Proc(ctx)go Proc(ctx)// Cancel after 1stime.Sleep(time.Second)cancle()}func Proc(ctx context.Context) {for {select {case &lt;- ctx.Done():returndefault:// do ...}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Handle(r *http.Request)  {timeoutStr := r.FormValue("timeout")timeout, _ := strconv.Atoi(timeoutStr)ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout))defer cancel()done := make(chan struct{}, 1)go func() {RPC(ctx, ...)        // ？？万一是其他协程传递的呢？？ done &lt;- struct{}{}}()select {case &lt;- done:// nice ... case &lt;- ctx.Done():// timeout}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247485030&amp;idx=1&amp;sn=6eb805b2ecbc123e984f563bde734812&amp;chksm=f904133bce739a2df5c3c800539d6d4a15e8d900b25f8ffb4ed08685a4135212f521825e96bc&amp;cur_album_id=1515516076481101825&amp;scene=190#rd">go并发中一些有趣的现象</a>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() { wg := sync.WaitGroup{} wg.Add(5) for i := 0; i &lt; 5; i++ {  go func() {   defer wg.Done()   fmt.Println(i)  }() } wg.Wait()}// 主要是变量 i 没有作为形参传入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>// 第一次输出：5 5 5 5 5</p><p>// 多输出几次：5 3 5 5 5</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() { wg := sync.WaitGroup{} wg.Add(5) for i := 0; i &lt; 5; i++ {  go func(i int) {   defer wg.Done()   fmt.Println(i)  }(i) } wg.Wait()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>// 第一次输出：0 1 2 4 3</p><p>// 第二次输出：4 0 1 2 3</p><p>（输出的值都是无序且不稳定的）</p><p>其整个程序扭转实质上分为了多个阶段，也就是各自运行的时间线并不同，可以其拆分为：</p><ul><li>先创建：<code>for-loop</code> 循环创建 <code>goroutine</code>。</li><li>再调度：协程<code>goroutine</code> 开始调度执行。</li><li>才执行：开始执行 <code>goroutine</code> 内的输出。</li></ul><p><a href="https://hackernoon.com/building-a-media-streaming-server-using-go-and-hls-protocol-j85h3wem">Golang HLS 构建流服务</a></p><h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开启module模式go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.io,direct# 设置不走 proxy 的私有仓库，多个用逗号相隔（可选）go env -w GOPRIVATE=*.corp.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p><code>fmt.Print</code>有几个变种：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Print:  输出到控制台,不接受任何格式化操作Println: 输出到控制台并换行Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量（不可以输出别的类型）Sprintf：格式化并返回一个字符串而不带任何输出Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通用的占位符</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">%v     值的默认格式。%+v   类似%v，但输出结构体时会添加字段名%#v　 相应值的Go语法表示 %T    相应值的类型的Go语法表示 %%    百分号,字面上的%,非占位符含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://www.cnblogs.com/rickiyang/p/11074171.html">Go中的fmt几种输出的区别和格式化方式</a> </p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><a href="https://zhuanlan.zhihu.com/p/68792989">深度解析context</a>: 不完美，但很高效解决了问题</p><p>==任何调用的默认超时时间的设置是非常有必要的== </p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针结构图"><a href="#指针结构图" class="headerlink" title="指针结构图"></a>指针结构图</h3><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/PointerValue.png" style="zoom:67%;"><ul><li>指针是一种数据类型，用来存储一个内存地址，该地址指向存储在该内存中的对象</li><li>这个对象可以是字符串、整数、函数或者你自定义的结构体</li><li>指针变量的值就是 <strong>它(内存地址)</strong> 所指向数据的内存地址，普通变量的值就是我们具体存放的数据</li><li>指针类型非常廉价，只占用 4 个或者 8 个字节的内存大小</li></ul><h3 id="指针变量-x2F-普通变量"><a href="#指针变量-x2F-普通变量" class="headerlink" title="指针变量/普通变量"></a>指针变量/普通变量</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   name:="will"   nameP:=&amp;name// &amp;, 表示取地址；指针的类型是 *string   fmt.Println("name变量的值为:",name)// name变量的值为: will   fmt.Println("name变量的内存地址为:",nameP)// name变量的内存地址为: 0xc000010200}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Go 语言中使用类型名称前加 * 的方式，即可表示一个对应的指针类型</li><li>比如 int 类型的指针类型是 *int，float64 类型的指针类型是 *float64，自定义结构体 A 的指针类型是 *A</li></ul><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 也可以通过 var 关键字定义var intP *int//指针类型不同，无法赋值 :intP = &amp;name //  Cannot use '&amp;name' (type *string) as type *int in assignment// 指针类型的变量如果没有分配内存，默认零值 nil，它没有指向的内存；所以无法使用，强行使用就会得到 nil 指针错误*intP =10// ipanic: runtime error: invalid memory address or nil pointer dereference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过 var 声明的指针变量不能直接赋值和取值的，因为它<code>仅仅是个变量</code>，<em>还没有对应的内存地址</em>，它的值是 <code>nil</code></p></li><li><p>而对于==值类型==来说，<code>即使只声明一个变量</code>，没有对其初始化，**<u><em>该变量也会有分配好的内存</em></u>**</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   var s string   fmt.Printf("%p\n",&amp;s)}// 声明了一个变量 s，并没有对其初始化，但是可以通过 &amp;s 获取它的内存地址// 这其实是 Go 语言帮我们做的，可以直接使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 只需要通过 new 函数给它分配一块内存就可以了var intP *int = new(int)// 更推荐简短声明法: intP := new(int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>和普通类型不一样的是</strong>，指针类型还可以通过内置的 new 函数来声明: </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">intP1 := new(int)// 内置的 new 函数有一个参数，可以传递类型给它,它会返回对应的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="获取指针指向的值"><a href="#获取指针指向的值" class="headerlink" title="获取指针指向的值"></a>获取指针指向的值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">nameV := *namePfmt.Println("nameP指针指向的值为:",nameV)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>要获取指针指向的值，只需要在指针变量前加 <code>*</code> 号即可</li><li><code>*</code> 直接，映射到 指针中存储的内存地址 指向的指</li></ul><h3 id="修改指针指向的值"><a href="#修改指针指向的值" class="headerlink" title="修改指针指向的值"></a>修改指针指向的值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">//修改指针指向的值*nameP = "will micro" fmt.Println("nameP指针指向的值为:",*nameP)fmt.Println("name变量的值为:",name)// 运行结果:// nameP指针指向的值为: will micro// name变量的值为: will micro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==对 *nameP 赋值等于修改了指针 nameP 指向的值== </p><p>不光 nameP 指针指向的值被改变了，变量 name 的值也被改变了，这就是指针的作用</p><h3 id="指针参数"><a href="#指针参数" class="headerlink" title="指针参数"></a>指针参数</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">age:=18modifyAge(age)fmt.Println("age的值为:",age)func modifyAge(age int)  {   age = 20}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>modifyAge 中的 age 只是实参 age 的一份拷贝，所以修改它不会改变实参 age 的值</p><p><strong>要达到修改年龄，需要使用指针:</strong>  </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">age:=18modifyAge(&amp;age)fmt.Println("age的值为:",age)func modifyAge(age *int)  {   *age = 20}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要在函数中通过形参改变实参的值时，需要使用指针类型的参数</p></blockquote><h3 id="指针的优点"><a href="#指针的优点" class="headerlink" title="指针的优点"></a>指针的优点</h3><ol><li>可以<strong>修改</strong>指向数据的值</li><li>在<code>变量赋值</code>，<code>参数传值</code>的时候可以<strong>节省内存</strong></li></ol><p>Go 语言作为一种高级语言，在指针的使用上还是比较<strong>克制</strong>的。</p><p>它在设计的时候就对指针进行了诸多限制，比如<code>指针不能进行运算</code>，也<code>不能获取常量的指针</code>。</p><h3 id="指针的建议"><a href="#指针的建议" class="headerlink" title="指针的建议"></a>指针的建议</h3><ol><li>不要对 map、slice、channel 这类引用类型使用指针</li><li>如果需要修改<code>方法接收者</code><em><strong><u>内部的</u></strong></em> 数据或者状态时，需要使用指针</li><li>如果需要修改<code>参数的值</code>或者<code>内部数据</code>时，也需要使用指针类型的参数</li><li>如果是<code>比较大的结构体</code>，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针</li><li>像 int、bool 这样的小数据类型没必要使用指针</li><li>如果需要<code>并发安全</code>，则尽可能地不要使用指针，使用指针一定要保证并发安全</li><li>指针最好<code>不要嵌套</code>，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂</li></ol><h2 id="值类型-x2F-指针类型"><a href="#值类型-x2F-指针类型" class="headerlink" title="值类型/指针类型"></a>值类型/指针类型</h2><h3 id="指针的指向"><a href="#指针的指向" class="headerlink" title="指针的指向"></a>指针的指向</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 定义一个地址结构体type address struct {   province string   city string}// 值类型 address 作为接收者实现了接口 fmt.Stringerfunc (addr address) String()  string{   return fmt.Sprintf("the addr is %s%s",addr.province,addr.city)}// 那么指针类型 *address 也实现了接口 fmt.Stringer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   add := address{province: "北京", city: "北京"}   printString(add)   printString(&amp;add)}func printString(s fmt.Stringer) {   fmt.Println(s.String())}// 正常运行：// 证明了当值类型作为接收者实现了某接口时，它的指针类型也同样实现了该接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {    var si fmt.Stringer = address{province: "上海",city: "上海"}    printString(si)    sip := &amp;si    printString(sip)}// 错误信息：// ./main.go:42:13: cannot use sip (type *fmt.Stringer) as type fmt.Stringer in argument to printString://*fmt.Stringer is pointer to interface, not interface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：<strong>指向<code>具体类型</code>的指针可以实现一个接口，但是指向<code>接口</code>的指针永远不可能实现该接口</strong> </p><h3 id="内存与不同类型"><a href="#内存与不同类型" class="headerlink" title="内存与不同类型"></a>内存与不同类型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个变量必须要经过<code>声明</code>、<code>内存分配</code>才能赋值，<em>才可以在声明的时候进行初始化</em> ：</p><ul><li><p>如果要对一个变量赋值，这个变量<code>必须有对应的分配好的内存</code>，这样才可以对这块内存操作，完成赋值的目的</p></li><li><p><strong>不止赋值操作</strong>，<code>对于指针变量</code>，如果没有分配内存，<em>取值操作一样会报 nil 异常</em>，<code>因为没有可以操作的内存</code></p></li></ul><p><code>指针类型</code>在声明的时候，<code>Go 语言并没有自动分配内存</code>，所以不能对其进行赋值操作，这和<code>值类型</code>不一样</p><p><code>slice</code>、<code>chan</code>和 <code>map</code> 也一样，因为它们*<u><strong>本质上也是指针类型</strong></u>*</p><h4 id="new-函数"><a href="#new-函数" class="headerlink" title="new 函数"></a>new 函数</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   var sp *string  // 没有分配到内存，不能对其进行赋值操作       sp = new(string)// 关键点，这可以分配到一块内存   *sp = "will"   fmt.Println(*sp)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内置函数 new 的源代码:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// The new built-in function allocates memory. The first argument is a type,// not a value, and the value returned is a pointer to a newly// allocated zero value of that type.func new(Type) *Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>翻译：根据传入的类型申请一块内存，然后返回指向这块内存的指针，指针指向的数据就是该类型的零值。</p></blockquote><p>指针变量初始化：（工厂函数）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">pp := NewPerson("will",20)func NewPerson(name string,age int) *person{   p:=new(person)   p.name = name   p.age = age   return p}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="make-函数"><a href="#make-函数" class="headerlink" title="make 函数"></a>make 函数</h4><p>使用 make 函数创建 map 的时候，其实调用的是 makemap 函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// makemap implements Go map creation for make(map[k]v, hint).func makemap(t *maptype, hint int, h *hmap) *hmap{  //省略无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>makemap 函数返回的是 *hmap 类型，而 hmap 是一个结构体，它的定义如下面的代码所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// src/runtime/map.go// A header for a Go map.type hmap struct {   // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.   // Make sure this stays in sync with the compiler's definition.   count     int // # live cells == size of map.  Must be first (used by len() builtin)   flags     uint8   B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)   noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details   hash0     uint32 // hash seed   buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.   oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing   nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)   extra *mapextra // optional fields}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>map 关键字其实非常复杂，它包含 map 的大小 count、存储桶 buckets 等</p></li><li><p>要想使用这样的 hmap，不是简单地通过 new 函数返回一个 *hmap 就可以，<code>还需要对其进行初始化</code>，这就是 make 函数要做的事情</p></li></ul><p>其实 make 函数就是 map 类型的工厂函数，它可以根据传递它的 K-V 键值对类型，创建不同类型的 map，同时可以初始化 map 的大小。</p><blockquote><p>提示：make 函数不只是 map 类型的工厂函数，还是 chan、slice 的工厂函数。它同时可以用于 slice、chan 和 map 这三种类型的初始化。</p></blockquote><ul><li><a href="#Map">map</a> </li><li><a href="#chan">chan</a> </li><li><a href="#SliceHeader">slice</a></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p><code>new 函数只用于分配内存，并且把内存清零</code>，也就是返回一个指向对应类型零值的指针。</p><ul><li>new 函数一般用于需要显式地返回指针的情况，不是太常用。</li></ul></li><li><p><code>make 函数只用于 slice、chan 和 map 这三种内置类型的创建和初始化</code>，因为这三种类型的结构比较复杂。</p><ul><li>比如 slice 要提前初始化好内部元素的类型，slice 的长度和容量等，这样才可以更好地使用它们。</li></ul></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p><strong>引用类型的零值都是 nil：</strong> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AllOfTypeInGo.png" style="zoom:50%;"><p>在 Go 语言中，函数的参数传递<code>只有值传递</code>，而且传递的 <em>实参</em> <code>都是原始数据的一份拷贝</code></p><ul><li><p>如果拷贝的内容是值类型的，那么在函数中就<code>无法修改</code>原始数据</p></li><li><p>如果拷贝的内容是指针（或者可以理解为引用类型 map、chan 等），那么在函数中就<code>可以修改</code>原始数据</p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://blog.csdn.net/wade3015/article/details/100149338">map的出生到扩展</a></p><h3 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   m:=make(map[string]int)   m["will"] = 18   fmt.Println("will的年龄为",m["will"])   modifyMap(m)   fmt.Println("will的年龄为",m["will"])}func modifyMap(p map[string]int)  {   p["will"] =20}// 成功修改：// will的年龄为 18// will的年龄为 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 判断key是否存在if value, ok := map[key]; ok {    // 存在}if value, ok := map[key]; !ok {    // 不存在}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 不关心索引和数据的情况for range m {}// 只关心索引的情况,只遍历键, 无须将值改为匿名变量形式，忽略值即可for kwy := range m {}// 关心索引和数据的情况for kwy, value := range m {}// 如果需要特定顺序的遍历结果，正确的做法是先排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h3><p>用<code>字面量</code>或者<code>make函数</code>的方式创建 map，都转换成 makemap 函数的调用，这个转换是 <strong>Go 语言编译器自动做的</strong> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// src/runtime/map.go// makemap implements Go map creation for make(map[k]v, hint).func makemap(t *maptype, hint int, h *hmap) *hmap{  //省略无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> Go 语言的 map 类型本质上就是 <code>*hmap</code>, <strong>本质上就是个指针</strong> </p><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><p>Go 语言并发模块中的 <code>channel</code>, <strong>本质上也是个指针</strong> : </p><p>创建的 chan 其实是个 *hchan，所以它在参数传递中也和 map 一样</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func makechan(t *chantype, size int64) *hchan {    //省略无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>严格来说，Go 语言没有引用类型，但是我们可以把 map、chan 称为<strong>引用类型</strong>，<strong>为了便于理解</strong>。</p><p>除了 map、chan 之外，Go 语言中的<code>函数</code>、<code>接口</code>、<code>slice 切片</code>都可以称为<strong>引用类型</strong> </p><h2 id="切片-amp-数组"><a href="#切片-amp-数组" class="headerlink" title="切片&amp;数组"></a>切片&amp;数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">a1:=[1]string{"张三"}a2:=[2]string{"李四"}array:=[5]string{"a","b","c","d","e"}array:=[...]string{"a","b","c","d","e"}// slice := []string{"a","b","c","d","e"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>变量 a1 的大小是 <code>1</code>，内部元素的类型是 string，也就是说 a1 <code>最多只能存储 1 个类型为 string 的元素</code></li><li>变量 a2 的大小是 <code>2</code>，内部元素的类型也是 string，所以 a2 <code>最多可以存储 2 个类型为 string 的元素</code></li></ul><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ArrayOfGo.png" style="zoom:40%;"><p>数组由两部分构成：<code>数组的大小</code>和<code>数组内的元素类型</code> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">//数组结构伪代码表示array{  len  item type}// 数组循环for i,v:=range array{    fmt.Printf("数组索引:%d,对应值:%s\n", i, v)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组的限制"><a href="#数组的限制" class="headerlink" title="数组的限制"></a>数组的限制</h3><ul><li>一旦一个数组被声明，它的<code>大小</code>和<code>内部元素的类型</code>就<strong>不能改变</strong>，<strong>不能随意</strong>地向数组添加任意多个元素.</li><li>与C语言不同，创建数组时，Go会将数组元素初始化为零值，因此我们无需再显式地执行此初始化操作.</li><li>与C不同的是，Go数组是值类型，它不是指向内存块第一个元素的指针；如果将数组传递给函数，则将复制整个数组；但仍然可以<em>传递</em> <strong>指向数组</strong>的<strong>指针</strong>以使其不被复制.</li></ul><h3 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice 切片"></a>slice 切片</h3><p>​<code>为了解决数组以上的限制</code>，Go 语言创造了 slice，也就是切片。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">slice := array[2:5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/SliceOfGo.png" style="zoom:40%;"><ul><li>array[2:5] 获取到的是 c、d、e 这三个元素；左闭右开区间</li></ul><blockquote><p>切片是 对数组的 <strong>抽象</strong> 和 <strong>封装</strong> </p><p>底层是一个数组存储所有的元素，但是它<code>可以动态地添加元素</code>，容量不足时还可以<code>自动扩容</code></p><p>但，其并<strong>不是指针</strong>，而是一种数据类型</p></blockquote><p><strong>切片，就是<code>动态数组</code></strong>  </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := []string{"张三", "李四"}// 区别于数组，没有容量个数// a := [2]string{"张三", "李四"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 还可以使用make 函数传入一个容量参数：slice:=make([]string,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 可以指定新创建的切片 []string 容量为 8：slice := make([]string,4,8)// Go 语言在内存上划分了一块容量为 8 的内容空间（容量为 8）// 但是只有 4 个内存空间才有元素（长度为 4），其他的内存空间处于空闲状态// 当通过 append 函数往切片中追加元素的时候，会追加到空闲的内存上，当切片的长度要超过容量的时候，会进行扩容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 通过字面量的方式声明和初始化：      (和数组的区别只是，没有容量个数)slice := []string{"a","b","c","d","e"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过内置的 append 函数对一个切片追加元素，返回新切片，如下面的代码所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">//追加一个元素slice2:=append(slice1,"f")//多加多个元素slice2:=append(slice1,"f","g")//追加另一个切片slice2:=append(slice1,slice...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小技巧：</p><p>​在创建新切片的时候，最好要让新切片的<strong>长度==容量</strong>，这样在追加操作的时候就会<strong>生成新的</strong>底层数组，从而和原有数组分离，就不会因为共用底层数组导致修改内容的时候影响多个切片。</p><h3 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   // 定义slice并初始化   ss := []string{"will","张三"}   fmt.Println("切片ss长度为",len(ss),",容量为",cap(ss))       // 动态扩容   ss=append(ss,"李四","王五")   fmt.Println("切片ss长度为",len(ss),",容量为",cap(ss))       fmt.Println(ss)       // 插入   slice = append([]string{}, slice...)}// 切片ss长度为 2 ,容量为 2// 切片ss长度为 4 ,容量为 4// [will 张三 李四 王五]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>append 自动扩容的原理</strong>：</p><ol><li><code>新建</code>一个底层数组</li><li>把原来切片内的元素<code>拷贝</code>到新数组中</li><li>最后返回一个<code>指向新数组</code>的切片</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type SliceHeader struct {   Data uintptr   Len  int   Cap  int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SliceHeader 是切片<code>在运行时</code>的表现形式：</p><ul><li>Data 用来<code>指向</code>存储切片元素的数组</li><li>Len 代表切片的<code>长度</code> </li><li>Cap 代表切片的<code>容量 </code></li></ul><p><code>不同切片</code>对应的<u>底层 Data</u> <code>指向</code>的可能是<code>同一个数组</code>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   // 定义并初始化数组   a1:=[2]string{"will","张三"}      // 根据数组定义slice   s1:=a1[0:1]   s2:=a1[:]       //打印出s1和s2的Data值，是一样的   fmt.Println((*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)).Data)   fmt.Println((*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)).Data)}// 824634150744// 824634150744<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>多个切片共用一个底层数组虽然可以减少内存占用，但是如果有一个切片修改内部的元素，其他切片也会受影响。</p><p>所以在切片作为参数在函数间传递的时候要小心，**<u><em>尽可能不要修改原切片内的元素</em></u>**。</p></blockquote><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><p>对于数组和切片来说，Go 语言有三种不同的遍历方式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 不关心索引和数据的情况for range a {}// 只关心索引的情况for i := range a {}// 关心索引和数据的情况for i, elem := range a {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高效的原因"><a href="#高效的原因" class="headerlink" title="高效的原因"></a>高效的原因</h3><ul><li><p>从<code>集合类型</code>的角度考虑</p><ul><li>数组、切片和 map 都是集合类型，它们都可以存放元素，但是数组和切片的取值和赋值操作要更高效，因为它们是<code>连续的内存</code>操作，<em><strong>通过索引就可以快速地找到元素存储的地址</strong></em> </li><li>当然 map 的价值也非常大，因为它的 Key 可以是很多类型，比如 int、int64、string 等</li><li>数组和切片的<code>索引</code>只能是<em><strong>整数</strong></em></li></ul></li><li><p>从<code>内存大小</code>的角度考虑</p><ul><li>在数组和切片中，切片又是高效的，因为它在赋值、函数传参的时候，并不会把所有的元素都复制一遍，而只是复制 SliceHeader 的三个字段就可以了，共用的还是同一个底层数组</li><li>切片的高效还体现在 for range 循环中，因为<code>循环得到的临时变量也是个值拷贝</code>，所以在遍历大的数组时，切片的效率更高</li></ul></li></ul><p>总结：切片<code>基于指针的封装</code>是它效率高的根本原因，因为可以减少内存的占用，以及减少内存复制时的时间消耗</p><h3 id="string-lt-x3D-gt-byte"><a href="#string-lt-x3D-gt-byte" class="headerlink" title="string <=> byte"></a>string &lt;=&gt; byte</h3><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p> []byte(s) 和 string(b) 这种<code>强制转换</code><strong>会重新拷贝一份字符串</strong> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s := "will"fmt.Printf("s的内存地址：%d\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Data)b := []byte(s)fmt.Printf("b的内存地址：%d\n",(*reflect.SliceHeader)(unsafe.Pointer(&amp;b)).Data)s3 := string(b)fmt.Printf("s3的内存地址：%d\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s3)).Data)fmt.Println(s,string(b),s3)// 都是 "will"// 打印出的内存地址都不一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：</p><p>可以通过查看 runtime.stringtoslicebyte 和 runtime.slicebytetostring 这两个函数的源代码，了解关于 string 和 []byte 类型互转的具体实现。</p></blockquote><pre class="line-numbers language-go" data-language="go"><code class="language-go">// StringHeader is the runtime representation of a string.type StringHeader struct {   Data uintptr// 用于存放指向真实内容的指针   Len  int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在程序运行的时候，字符串和切片本质上就是 StringHeader 和 SliceHeader</li></ul><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">s:="will"b:=[]byte(s)// s3:=string(b)// s4 没有申请新内存（零拷贝）,和变量 b 使用的是同一块内存，因为它们的底层 Data 字段值相同s4 := *(*string)(unsafe.Pointer(&amp;b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 字符串转成byte数组：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a := "aaa"ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a))b := *(*[]byte)(unsafe.Pointer(&amp;ssh))  fmt.Printf("%v",b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址</li><li><code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串a转成底层结构的形式</li><li><code>(*[]byte)(unsafe.Pointer(&amp;ssh))</code> 可以把ssh底层结构体转成byte的切片的指针</li><li>再通过 <code>*</code>转为指针指向的实际内容</li></ul><p>参考：<a href="https://mp.weixin.qq.com/s/rGqM1wMlqQEoJSgyrgZNLg">2 个 Header</a> </p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() { s := "脑子进煎鱼了" v := string2bytes1(s) fmt.Println(v)}func string2bytes1(s string) []byte {  // 在程序必须保留一个单独的、正确类型的指向底层数据的指针 stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) var b []byte pbytes := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b)) pbytes.Data = stringHeader.Data pbytes.Len = stringHeader.Len pbytes.Cap = stringHeader.Len return b}// 在性能方面，若只是期望单纯的转换，对容量（cap）等字段值不敏感，也可以使用以下方式：func string2bytes2(s string) []byte { return *(*[]byte)(unsafe.Pointer(&amp;s))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SliceHeader-x2F-StringHeader"><a href="#SliceHeader-x2F-StringHeader" class="headerlink" title="SliceHeader/StringHeader"></a>SliceHeader/StringHeader</h4><ul><li><p>SliceHeader 有 Data、Len、Cap 三个字段</p></li><li><p>StringHeader 有 Data、Len 两个字段</p></li><li><p>所以 *SliceHeader 通过 unsafe.Pointer 转为 *StringHeader 的时候没有问题，因为 *SliceHeader 可以提供 *StringHeader 所需的 Data 和 Len 字段的值</p></li><li><p>但是反过来却不行了，因为 *StringHeader 缺少 *SliceHeader 所需的 Cap 字段，需要我们自己补上一个默认值</p></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">s:="will"//b:=[]byte(s)sh:=(*reflect.SliceHeader)(unsafe.Pointer(&amp;s))sh.Cap = sh.Lenb1:=*(*[]byte)(unsafe.Pointer(sh))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><p>通过 unsafe.Pointer 把 string 转为 []byte 后，不能对 []byte 修改</p><p>比如不可以进行 b1[0]=12 这种操作，会报异常，导致程序崩溃。</p><p>这是因为在 Go 语言中 string 内存是只读的。</p></blockquote><p>扩展：<a href="https://developer.51cto.com/art/202106/665738.htm">Go 语言中的零拷贝优化</a> </p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p> <a href="https://mp.weixin.qq.com/s/4jvhRQvKlMiYweSOG6xCrA">小技巧分享：在 Go 如何实现枚举？</a> </p><h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i := 3       // reflect.Value 是一个结构体   iv := reflect.ValueOf(i)       // reflect.Type 是一个接口   it := reflect.TypeOf(i)       fmt.Println(iv,it)   // 3 int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p> reflect.Value 和 int 类型互转：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i := 3   // int to reflect.Value   iv := reflect.ValueOf(i)       // reflect.Value to int   i1 := iv.Interface().(int)       fmt.Println(i1)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>interface{} 是空接口，可以表示任何类型，也就是说你可以把任何类型转换为空接口，它通常用于反射、类型断言，以减少重复代码，简化编程。</p></blockquote><p>修改对应的值：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i := 3       // 因为 reflect.ValueOf 函数返回的是一份值的拷贝，所以要传入变量的指针才可以   ipv := reflect.ValueOf(&amp;i)       //  因为传递的是一个指针，所以需要调用 Elem 方法找到这个指针指向的值，最后就可以使用 SetInt 方法修改值   ipv.Elem().SetInt(4)       fmt.Println(i)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么如何修改 <code>struct 结构体字段</code> 的值呢？</p><ol><li><p>传递一个 struct 结构体的指针，获取对应的 reflect.Value；</p></li><li><p>通过 Elem 方法获取指针指向的值；</p></li><li><p>通过 Field 方法获取要修改的字段；</p></li><li><p>通过 Set 系列方法修改成对应的值。</p></li></ol><p>如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   ppv := reflect.ValueOf(&amp;p)   ppv.Elem().Field(0).SetString("张三")   fmt.Println(p)}type person struct {   Name string   Age int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射修改一个值的规则：</p><ol><li><p>可被寻址，通俗地讲就是要向 reflect.ValueOf 函数<code>传递一个指针作为参数</code> </p></li><li><p>如果要修改 struct 结构体字段值的话，该字段需要是可导出的，而不是私有的，也就是<code>该字段的首字母为大写</code></p></li><li><p>记得使用 <code>Elem</code> 方法<code>获得指针指向的值</code>，这样才能调用<code> Set 系列</code>方法进行修改</p></li></ol><p>获取对应的底层类型：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}       pv := reflect.ValueOf(p)   fmt.Println(pv.Kind())   // struct      ppv := reflect.ValueOf(&amp;p)   fmt.Println(ppv.Kind())   // ptr    }// 变量 p 的实际类型是 person，但是 person 对应的底层类型是 struct 这个结构体类型，而 &amp;p 对应的则是指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>和 reflect.Value 不同，reflect.Type <code>是一个接口</code>，而不是一个结构体，所以只能使用它的方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Type interface {   Implements(u Type) bool// 是否实现了接口 u   AssignableTo(u Type) bool// 是否可以使用 =   ConvertibleTo(u Type) bool// 是否可以进行类型转换   Comparable() bool// 是否可以使用关系运算符进行比较      // 以下这些方法和Value结构体的功能相同   Kind() Kind   Method(int) Method   MethodByName(string) (Method, bool)   NumMethod() int   Elem() Type   Field(i int) StructField   FieldByIndex(index []int) StructField   FieldByName(name string) (StructField, bool)   FieldByNameFunc(match func(string) bool) (StructField, bool)   NumField() int}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {   Name string   Age int}func (p person) String() string{   return fmt.Sprintf("Name is %s,Age is %d", p.Name, p.Age)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历结构体的字段和方法</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   pt := reflect.TypeOf(p)       //遍历person的字段   for i:=0; i&lt;pt.NumField(); i++{      fmt.Println("字段：",pt.Field(i).Name)   }       //遍历person的方法   for i:=0; i&lt;pt.NumMethod(); i++{      fmt.Println("方法：",pt.Method(i).Name)   }}// 输出：// 字段： Name// 字段： Age// 方法： String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以通过 FieldByName 方法获取指定的字段，也可以通过 MethodByName 方法获取指定的方法，获取某个特定的字段或者方法时非常高效，而不是使用遍历。</p></blockquote><p><strong>是否实现某接口</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   pt := reflect.TypeOf(p)       // 判断是否实现了接口 fmt.Stringer 和 io.Writer   // elem 获得指针指向的值   stringerType := reflect.TypeOf((*fmt.Stringer)(nil)).Elem()   writerType := reflect.TypeOf((*io.Writer)(nil)).Elem()       fmt.Println("是否实现了fmt.Stringer：",pt.Implements(stringerType))   fmt.Println("是否实现了io.Writer：",pt.Implements(writerType))}// 是否实现了fmt.Stringer： true// 是否实现了io.Writer： false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>尽可能通过类型断言的方式判断是否实现了某接口，而不是通过反射</p></blockquote><h3 id="JSON-lt-x3D-gt-Struct"><a href="#JSON-lt-x3D-gt-Struct" class="headerlink" title="JSON <=> Struct"></a>JSON &lt;=&gt; Struct</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}       //struct to json   jsonB,err := json.Marshal(p)   if err == nil {      fmt.Println(string(jsonB))   }       //json to struct   respJSON:="{\"Name\":\"李四\",\"Age\":40}"   json.Unmarshal([]byte(respJSON), &amp;p)   fmt.Println(p)}// {"Name":"飞雪无情","Age":20}// Name is 李四,Age is 40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>JSON 字符串的 Key 和 struct 结构体的字段名称一样，比如示例中的 Name 和 Age</li><li>想把输出的 json 字符串的 Key 改为小写的 name 和 age，可以通过为 struct 字段添加 tag 的方式</li></ul><h3 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h3><p>struct tag 是一个<code>添加在 struct 字段上的标记</code> ，使用它进行辅助，可以完成一些额外的操作</p><p>比如 json 和 struct 互转：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {   Name string `json:"name"`   Age int `json:"age"`}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>重点：</p><p>json 作为 Key，是 Go 语言自带的 json 包解析 JSON 的一种==约定==</p><p>它会通过 json 这个 Key 找到对应的值，<em>用于</em>  <u>JSON 的 Key 值</u></p></blockquote><p> tag 就像是我们为 struct 字段起的别名，那么 json 包是如何获得这个 tag 的呢？</p><ul><li>反射</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">//遍历person字段中key为json的tagfor i:=0; i&lt;pt.NumField(); i++{       //  Field 方法返回一个 StructField 结构体，有一个字段是 Tag，存有字段的所有 tag   sf:=pt.Field(i)      fmt.Printf("字段%s上,json tag为%s\n",sf.Name, sf.Tag.Get("json"))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体的字段可以有多个 tag，用于不同的场景</p><ul><li>比如 json 转换、bson 转换、orm 解析等</li><li>如果有多个 tag，要使用<code>空格分隔</code></li><li>采用不同的 Key 可以获得不同的 tag</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">type person struct {   Name string `json:"name" bson:"b_name"`   Age int `json:"age" bson:"b_age"`}// 遍历person字段中key为json、bson的tagfor i:=0; i&lt;pt.NumField(); i++{   sf := pt.Field(i)   fmt.Printf("字段%s上,json tag为%s\n",sf.Name, sf.Tag.Get("json"))   fmt.Printf("字段%s上,bson tag为%s\n",sf.Name, sf.Tag.Get("bson"))}// 字段Name上,key为json的tag为name// 字段Name上,key为bson的tag为b_name// 字段Age上,key为json的tag为age// 字段Age上,key为bson的tag为b_age<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现 Struct 转 JSON</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := person{Name: "will",Age: 20}   pv := reflect.ValueOf(p)   pt := reflect.TypeOf(p)       // 自己实现的struct to json   jsonBuilder := strings.Builder{}   jsonBuilder.WriteString("{")      num := pt.NumField()       for i := 0; i&lt;num; i++{      jsonTag := pt.Field(i).Tag.Get("json") //获取json tag      jsonBuilder.WriteString("\""+jsonTag+"\"")      jsonBuilder.WriteString(":")      //获取字段的值      jsonBuilder.WriteString(fmt.Sprintf("\"%v\"",pv.Field(i)))      if i&lt;num-1{         jsonBuilder.WriteString(",")      }   }   jsonBuilder.WriteString("}")   fmt.Println(jsonBuilder.String())//打印json字符串}// {"name":"飞雪无情","age":"20"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>json 字符串的转换只是 struct tag 的一个应用场景</p><ul><li><p>完全可以把 struct tag 当成结构体中字段的元数据配置，使用它来做想做的任何事情</p></li><li><p>比如 orm 映射、xml 转换、生成 swagger 文档等</p></li></ul><h3 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h3><p><a href="https://blog.golang.org/laws-of-reflection">反射的三大定律</a>：</p><ol><li><p>任何接口值，interface{} 都可以反射出反射对象，也就是 reflect.Value 和 reflect.Type，通过函数 reflect.ValueOf 和 reflect.TypeOf 获得。</p></li><li><p>反射对象也可以还原为 interface{} 变量，也就是第 1 条定律的<code>可逆性</code>，通过 reflect.Value 结构体的 Interface 方法获得。</p></li><li><p>要修改反射的对象，该值必须可设置，也就是<code>可寻址</code>。</p></li></ol><blockquote><p>提示：</p><p>任何类型的变量都可以转换为空接口 intferface{}，所以第 1 条定律中函数 reflect.ValueOf 和 reflect.TypeOf 的参数就是 interface{}，表示可以把任何类型的变量转换为反射对象。</p><p>在第 2 条定律中，reflect.Value 结构体的 Interface 方法返回的值也是 interface{}，表示可以把反射对象还原为对应的类型变量。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在反射中：</p><ul><li>reflect.Value 对应的是<code>变量的值</code>，如果你需要进行和变量的<em><strong>值有关</strong></em> 的操作，应该优先使用 reflect.Value比如获取变量的值、修改变量的值等。</li><li>reflect.Type 对应的是<code>变量的类型</code>，如果你需要进行和变量的<em><strong>类型本身有关</strong></em> 的操作，应该优先使用 reflect.Type，比如获取结构体内的字段、类型拥有的方法集等。</li></ul><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>原因：</p><ul><li>Go 的设计者为了编写方便、提高效率且降低复杂度，将其设计成一门<code>强类型</code>的<code>静态</code>语言</li><li>强类型意味着，一旦定义了，类型就不能改变</li><li>静态意味着，在运行前，做了类型检查</li><li>同时出于安全考虑，Go 语言是<code>不允许两个指针类型进行转换</code></li></ul><h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p>**如 <em>int 不能转为 <em>float64</em></em> ：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i:= 10   ip:=&amp;i   var fp *float64 = (*float64)(ip)   fmt.Println(fp)}// cannot convert ip (type * int) to type * float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>但如果还是需要转换呢？？？</strong> </p><p><code>unsafe.Pointer</code> 是一种特殊意义的指针，==可以表示任意类型的地址==，类似 C 语言里的 void* 指针，**<u><em>是全能型的</em></u>**</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   i:= 10   ip:=&amp;i       var fp *float64 = (*float64)(unsafe.Pointer(ip))       *fp = *fp * 3   fmt.Println(i)}// 30// 原来变量 i 的值也被改变了，变为 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// uintptr is an integer type that is large enough // to hold the bit pattern of any pointer.// 足够大，可以表示任何指针type uintptr uintptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>uintptr 可以对<code>指针偏移</code><em>进行计算</em>，这样就<strong>可以访问特定的内存</strong>，<em>达到对特定内存读写的目的</em>，真正内存级别的操作</p></blockquote><p><strong>通过指针偏移修改 struct 结构体内的字段</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   p := new(person)       // Name是person的第一个字段不用偏移，即可通过指针修改   pName := (*string)(unsafe.Pointer(p))   *pName = "will"       // Age并不是person的第一个字段，所以需要进行偏移，这样才能正确定位到Age字段这块内存，才可以正确的修改   pAge := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+unsafe.Offsetof(p.Age)))   *pAge = 20   fmt.Println(*p)}type person struct {   Name string   Age int}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>因为 Age 字段不是 person 的第一个字段，要修改它必须要进行指针偏移运算</li><li>所以需要先把指针变量 p 通过 unsafe.Pointer 转换为 uintptr，这样才能进行地址运算</li><li>偏移量可以通过函数 unsafe.Offsetof 计算出来，该函数返回的是一个 uintptr 类型的偏移量</li></ul><h3 id="unsafe-Sizeof"><a href="#unsafe-Sizeof" class="headerlink" title="unsafe.Sizeof"></a>unsafe.Sizeof</h3><p>Sizeof 函数可以返回<code>一个类型所占用的内存大小</code> ，这个大小<strong>只与类型有关</strong>，<em>和类型对应的变量存储的内容大小无关</em></p><ul><li>比如 bool 型占用一个字节、int8 也占用一个字节</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println(unsafe.Sizeof(true))fmt.Println(unsafe.Sizeof(int8(0)))fmt.Println(unsafe.Sizeof(int16(10)))fmt.Println(unsafe.Sizeof(int32(10000000)))fmt.Println(unsafe.Sizeof(int64(10000000000000)))fmt.Println(unsafe.Sizeof(int(10000000000000000)))fmt.Println(unsafe.Sizeof(string("will")))fmt.Println(unsafe.Sizeof([]string{"李四","张三"}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一个 struct 结构体的内存占用大小，等于它包含的字段类型内存占用大小之和。</p></blockquote><h3 id="指针转换规则"><a href="#指针转换规则" class="headerlink" title="指针转换规则"></a>指针转换规则</h3><p><img src="https://raw.githubusercontent.com/MicroWiller/photobed/master/PointerExchange.png"></p><ol><li>任何类型的 *T 都可以转换为 unsafe.Pointer</li><li>unsafe.Pointer 也可以转换为任何类型的 *T</li><li>unsafe.Pointer 可以转换为 uintptr</li><li>uintptr 也可以转换为 unsafe.Pointer</li></ol><ul><li>unsafe.Pointer 主要用于指针类型的转换，是各个<code>指针类型转换</code>的桥梁</li><li>uintptr 主要用于<code>指针运算</code>，尤其是通过偏移量定位不同的内存</li></ul><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p> <a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">atomic.Value 的前世今生</a>：“原子的”存储（Store）和加载（Load）<strong>任意类型</strong>的值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// A Value provides an atomic load and store of a consistently typed value.// The zero value for a Value returns nil from Load.// Once Store has been called, a Value must not be copied.//// A Value must not be copied after first use.type Value struct {v interface{}}// Load returns the value set by the most recent Store.// It returns nil if there has been no call to Store for this Value.func (v *Value) Load() (x interface{}) {......}// Store sets the value of the Value to x.// All calls to Store for a given Value must use values of the same concrete type.// Store of an inconsistent type panics, as does Store(nil).func (v *Value) Store(x interface{}) {    .....}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="实列"><a href="#实列" class="headerlink" title="实列"></a>实列</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main.gofunc Fibonacci(n int) int {   if n &lt; 0 {      return 0   }   if n == 0 {      return 0   }   if n == 1 {      return 1   }   return Fibonacci(n-1) + Fibonacci(n-2)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main_test.gofunc TestFibonacci(t *testing.T) {   //预先定义的一组斐波那契数列作为测试用例   fsMap := map[int]int{}   fsMap[0] = 0   fsMap[1] = 1   fsMap[2] = 1   fsMap[3] = 2   fsMap[4] = 3   fsMap[5] = 5   fsMap[6] = 8   fsMap[7] = 13   fsMap[8] = 21   fsMap[9] = 34   for k, v := range fsMap {      fib := Fibonacci(k)      if v == fib {         t.Logf("结果正确:n为%d,值为%d", k, fib)      } else {         t.Errorf("结果错误：期望%d,但是计算的值是%d", v, fib)      }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行如下命令，进行单元测试：go test -v ./ch18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go test -v ./ch18&nbsp;=== RUN&nbsp; &nbsp;TestFibonacci&nbsp; &nbsp; main_test.go:21: 结果正确:n为0,值为0&nbsp; &nbsp; main_test.go:21: 结果正确:n为1,值为1&nbsp; &nbsp; main_test.go:21: 结果正确:n为6,值为8&nbsp; &nbsp; main_test.go:21: 结果正确:n为8,值为21&nbsp; &nbsp; main_test.go:21: 结果正确:n为9,值为34&nbsp; &nbsp; main_test.go:21: 结果正确:n为2,值为1&nbsp; &nbsp; main_test.go:21: 结果正确:n为3,值为2&nbsp; &nbsp; main_test.go:21: 结果正确:n为4,值为3&nbsp; &nbsp; main_test.go:21: 结果正确:n为5,值为5&nbsp; &nbsp; main_test.go:21: 结果正确:n为7,值为13--- PASS: TestFibonacci (0.00s)PASSok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;(cached)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五点规则"><a href="#五点规则" class="headerlink" title="五点规则"></a>五点规则</h3><ol><li><p>含有单元测试代码的 go 文件必须<code>以 _test.go 结尾</code>，Go 语言测试工具只认符合这个规则的文件</p></li><li><p>单元测试文件名 _test.go <code>前面的部分</code>，最好是被测试的函数所在的 go 文件的文件名</p><ul><li>比如以上示例中单元测试文件叫 main_test.go，因为测试的 Fibonacci 函数在 main.go 文件里</li></ul></li><li><p>单元测试的函数名必须<code>以 Test 开头</code>，是可导出的、公开的函数</p></li><li><p>测试函数的签名必须<code>接收一个指向 testing.T 类型的指针</code>，并且<code>不能返回任何值</code></p></li><li><p>函数名最好是 <code>Test + 要测试的函数名</code></p><ul><li>比如例子中是 TestFibonacci，表示测试的是 Fibonacci 这个函数。</li></ul></li></ol><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go test -v --coverprofile=ch18.cover ./ch18//1. go test -v -coverpkg=./... -coverprofile=profile.cov ./...//2. go tool cover -func profile.cov<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以得到一个单元测试覆盖率文件，运行这行命令还可以同时看到测试覆盖率</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PASScoverage: 85.7% of statementsok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;0.367s&nbsp; coverage: 85.7% of statements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>查看详细的单元测试覆盖率报告</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go tool cover -html=ch18.cover -o=ch18.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令运行后，会在当前目录下生成一个 ch18.html 文件，使用浏览器打开它，查看内容</p><h3 id="race-检测"><a href="#race-检测" class="headerlink" title="race 检测"></a>race 检测</h3> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go run -race main.go <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编译器会通过探测所有的内存访问，监听其内存地址的访问（读或写）</li><li>在应用运行时就能够发现对共享变量的访问和操作，进而发现问题并打印出相关的警告信息</li></ul><p>需要注意的一点是，<code>go run -race</code> 是运行时检测，并不是编译时。且 race 存在明确的性能开销，通常是正常程序的<strong>十倍</strong>，因此不要想不开在生产环境打开这个配置，很容易翻车。</p><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch18/main_test.gofunc BenchmarkFibonacci(b *testing.B){   for i:=0;i&lt;b.N;i++{      Fibonacci(10)   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>基准测试函数必须<code>以 Benchmark 开头</code>，必须是可导出的</li><li>函数的签名必须接收一个<code>指向 testing.B 类型的指针</code>，并且不能返回任何值</li><li>最后的 <code>for 循环</code> 很重要，<em>被测试的代码要放到循环里</em></li><li><code>b.N</code> 是基准测试框架提供的，表示循环的次数，因为需要反复调用测试的代码，才可以评估性能</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#  -bench 表示，接受一个表达式作为参数，以匹配基准测试的函数# "." 表示运行所有基准测试➜ go test -bench=. ./ch18goos: darwingoarch: amd64pkg: gotour/ch18BenchmarkFibonacci-8&nbsp; &nbsp; &nbsp;3461616&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;343 ns/opPASSok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;2.230s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>BenchmarkFibonacci-8 ，后面的 -8 ，表示运行基准测试时对应的 GOMAXPROCS 的值</p></li><li><p>基准测试的时间默认是 1 秒，也就是 1 秒调用 3461616 次、每次调用花费 343 纳秒</p></li><li><p>如果想让测试运行的时间更长，可以通过 -benchtime 指定，比如 3 秒</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go test -bench=. -benchtime=3s ./ch18<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="计时方法"><a href="#计时方法" class="headerlink" title="计时方法"></a>计时方法</h3><blockquote><p>避免因为准备数据耗时造成的干扰</p></blockquote><p>进行基准测试之前会做一些准备，比如构建测试数据等，这些准备也需要消耗时间，所以需要<code>把这部分时间排除在外</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">func BenchmarkFibonacci(b *testing.B) {   n := 10   b.ResetTimer() //重置计时器   for i := 0; i &lt; b.N; i++ {      Fibonacci(n)   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>除了 ResetTimer 方法外，还有 StartTimer 和 StopTimer 方法，灵活地控制什么时候开始计时、什么时候停止计时。</li></ul><h3 id="内存统计"><a href="#内存统计" class="headerlink" title="内存统计"></a>内存统计</h3><p>统计每次操作分配内存的次数，以及每次操作分配的字节数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func BenchmarkFibonacci(b *testing.B) {   n := 10   b.ReportAllocs() //开启内存统计   b.ResetTimer() //重置计时器   for i := 0; i &lt; b.N; i++ {      Fibonacci(n)   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go test -bench=.&nbsp; ./ch18goos: darwingoarch: amd64pkg: gotour/ch18BenchmarkFibonacci-8&nbsp; 2486265&nbsp; 486 ns/op&nbsp;&nbsp;0 B/op&nbsp; 0 allocs/opPASSok&nbsp; &nbsp; &nbsp; gotour/ch18&nbsp; &nbsp; &nbsp;2.533s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>0 B/op</code>，表示每次操作分配了多少字节的内存</li><li><code>0 allocs/op</code>，表示每次操作分配内存的次数</li></ul><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><h4 id="逃逸实列"><a href="#逃逸实列" class="headerlink" title="逃逸实列"></a>逃逸实列</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">// ch19/main.gofunc newString() *string{   s:=new(string)   *s = "will"   return s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过 new 函数申请了一块内存；</p></li><li><p>然后把它赋值给了指针变量 s；</p></li><li><p>最后通过 return 关键字返回。</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:16:8: new(string) escapes to heap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>-m 表示打印出逃逸分析信息</li><li>-l 表示禁止内联</li><li><strong>指针</strong>作为<em>函数返回值</em> 的时候，一定会发生逃逸</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func newString() string{   s:=new(string)   *s = "will"   return *s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次通过命令查看以上代码的逃逸分析，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp;go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:14:8: new(string) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="被已经逃逸的指针-引用-的变量-也会发生逃逸"><a href="#被已经逃逸的指针-引用-的变量-也会发生逃逸" class="headerlink" title="被已经逃逸的指针 引用 的变量 也会发生逃逸"></a>被已经逃逸的指针 引用 的变量 也会发生逃逸</h4><p>==并不是不使用指针就不会发生逃逸==</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt.Println("will")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜ go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:13:13: ... argument does not escapech19/main.go:13:14: "will" escapes to heapch19/main.go:17:8: new(string) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>「will」<strong>逃逸</strong>到了堆上，这是因为「will」这个字符串<strong>被已经逃逸的指针变量</strong> <em>引用</em>，所以它也跟着逃逸了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (p *pp) printArg(arg interface{}, verb rune) {   p.arg = arg   //省略其他无关代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="被-slice、map-和-chan，这三种类型引用的指针也会发生逃逸"><a href="#被-slice、map-和-chan，这三种类型引用的指针也会发生逃逸" class="headerlink" title="被 slice、map 和 chan，这三种类型引用的指针也会发生逃逸"></a>被 slice、map 和 chan，这三种类型引用的指针也会发生逃逸</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {   m:=map[int]*string{}   s:="will"   m[0] = &amp;s}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜&nbsp; gotour go build -gcflags="-m -l" ./ch19/main.go# command-line-argumentsch19/main.go:16:2: moved to heap: sch19/main.go:15:20: map[int]*string literal does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>变量 m 没有逃逸，<strong>反而</strong>被变量 m 引用的变量 s 逃逸到了堆上</li><li>所以被map、slice 和 chan 这三种类型 引用 的指针一定会发生逃逸的</li></ul><blockquote><p>指针虽然可以减少内存的拷贝，但它同样会引起逃逸，所以要根据实际情况选择是否使用指针。</p></blockquote><h4 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h4><ol><li>尽可能避免逃逸，因为栈内存效率更高，还不用 GC。比如<strong>小对象的传参</strong>，array 要比 slice 效果好。</li><li>如果避免不了逃逸，还是在堆上分配了内存，那么对于频繁的内存申请操作，我们要学会<strong>重用内存</strong>，比如使用 sync.Pool</li><li>选用合适的算法，达到高性能的目的，比如<strong>空间换时间</strong> </li><li>尽可能避免使用锁、并发加锁的范围要尽可能小</li><li>使用 StringBuilder 做 string 和 [ ] byte 之间的转换</li><li>defer 嵌套不要太多</li></ol><blockquote><p>小提示：性能优化的时候，要结合基准测试，来验证自己的优化是否有提升。</p></blockquote><h3 id="并发基准测试"><a href="#并发基准测试" class="headerlink" title="并发基准测试"></a>并发基准测试</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func BenchmarkFibonacciRunParallel(b *testing.B) {   n := 10   b.RunParallel(func(pb *testing.PB) {      for pb.Next() {         Fibonacci(n)      }   })}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 RunParallel 方法运行并发基准测试</li><li>RunParallel 方法会创建多个 goroutine，并将 b.N 分配给这些 goroutine 执行</li></ul><h3 id="接口-依赖注入"><a href="#接口-依赖注入" class="headerlink" title="接口+依赖注入"></a>接口+依赖注入</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type transaction struct {    ID       string    BuyerID  int    SellerID int    Amount   float64    createdAt time.Time    Status TransactionStatus}func (t *transaction) Execute() bool {    if t.Status == Executed {        return true    }    if time.Now() - t.createdAt &gt; 24.hours { // 交易有有效期        t.Status = Expired        return false    }    client := BankClient.New(config.token) // 调用银行的 SDK 执行转账    if err := client.TransferMoney(id, t.BuyerID, t.SellerID, t.Amount); err != nil {        t.Status = Failed        return false    }    t.Status = Executed    return true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最重要的功能集中在<code>Execute()</code>函数中，但它却不好测试，因为它有两个外部依赖：</p><ol><li>行为不确定的<code>time.Now</code>函数，每一次调用都会产生不同的结果</li><li>银行提供的转账 SDK，我们不可能每次测试都去真的调用一下，那测试成本也忒高了</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 先将代码里使用到的方法抽象成一个接口type Transferer interface {    TransferMoney(id int, buyerID int, sellerID int, amount float64) error}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>放到<code>transaction</code>的成员属性中，重构后的<code>transaction</code>类及其构造函数就变成了这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type transaction struct {    ID       string    BuyerID  int    SellerID int    Amount   float64    createdAt time.Time    Status TransactionStatus    // 增加了一个存放接口的属性    transferer Transferer}func New(buyerID, sellerID int, amount float64, transferer Transferer) *transaction {    return &amp;transaction{        ID:         IdGenerator.generate(),        BuyerID:    buyerID,        SellerID:   sellerID,        Amount:     amount,        createdAt:  time.Now(),        Status:     TO_BE_EXECUTD,        transferer: transferer, // 注入进 transaction 类中    }}func (t *transaction) Execute() bool {    //...    //不直接创建，而是使用别人注入的接口实例    t.transferer.TransferMoney(id, t.BuyerID, t.SellerID, t.Amount)    //...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，可以在单元测试中就能够很方便的替换掉那个成本高昂的支付接口的调用了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">// 定义一个满足 Transferer 接口的 mock 类type MockedClient struct {    responseError error // 实例化的时候可以将期望的返回值保存进来}func (m *MockedClient) TransferMoney(id int, buyerID int, sellerID int, amount float64) error {    return m.responseError}func Test_transaction_Execute(t *testing.T) {    // 实例化一个可以自由控制结果的 client    transferer := &amp;MockedClient{        responseError: errors.New("insufficient balance"),    }    tnx := New(buyerID, sellerID, amount, transferer)    if succeeded := tnx.Execute(); succeeded != false {        t.Errorf("Execute() = %v, want %v", succeeded, false)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">var nowFn = time.Now //一个全局变量，用来解耦time.Now的生产者和消费者func (t *transaction) Execute() bool {    if t.Status == Executed {        return true    }    if nowFn() - t.createdAt &gt; 24.hours { // 不直接调用time.Now()        t.Status = Expired        return false    }    //...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，单元测试就能随心所欲的改变“当前时间”了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Test_expired_transaction_Execute(t *testing.T) {    // 用同样的函数签名改写业务中需要的时间函数    // 这里能改变私有的全局变量是因为测试代码跟业务代码处于同一个包中    nowFn = func() time.Time {        return time.Now().Add(-24 * time.Hour)    }    // 依旧需要实例化一个假的的 client    transferer := &amp;MockedClient{        responseError: nil,    }    tnx := New(buyerID, sellerID, amount, transferer)    //...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐式的复用了<code>time.Now</code>的<strong>函数签名</strong>，将它当做一种“接口类型”来使用</p><p>参考：<a href="https://blog.betacat.io/post/2020/03/a-pattern-for-writing-testable-go-code/#mock-timenow">编写可测试 Go 代码的一种模式</a> </p><h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p><a href="https://segmentfault.com/a/1190000016412013">pprof</a>：runtime / net</p><p><a href="https://github.com/uber-archive/go-torch">go-torch</a> </p><p> <a href="https://mp.weixin.qq.com/s/yZUE8N-Qb-AB81DgA1cV_w">golang性能诊断</a>：<code>pprof</code> / <code>trace</code> / <code>linux</code></p><h2 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h2><p>一个典型的 HTTP 服务应该如图所示：</p><p><img src="/go.assets/image-20210616203918882.png" alt="image-20210616203918882"></p><p>http服务器的工作就在于: </p><ul><li>如何接受来自客户端的请求(socket / router)</li><li>并向客户端返回响应</li></ul><p> Go HTTP 标准库  <code>net/http</code> 的实现原理: </p><p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/StanderdLibOfHttp.png"></p><ol><li>注册处理器到一个 hash 表中，可以通过键值路由匹配；</li><li>注册完之后就是开启循环监听，每监听到一个连接就会创建一个 Goroutine；</li><li>在创建好的 Goroutine 里面会循环的等待接收请求数据，然后根据请求的地址去处理器路由表中匹配对应的处理器，然后将请求交给处理器处理；</li></ol><p>这样做在连接数比较少的时候是没什么问题的，但是在连接数非常多的时候，每个连接都会创建一个 Goroutine 就会给系统带来一定的压力。</p><p>这也就造成了 <code>net/http</code>在处理高并发时的瓶颈。</p><p><code>fasthttp</code> : </p><p><img src="/go.assets/image-20210616205711264.png" alt="image-20210616205711264"></p><ol><li>启动监听；</li><li>循环监听端口获取连接；</li><li>获取到连接之后首先会去 ready 队列里获取 workerChan，获取不到就会去对象池获取；</li><li>将监听的连接传入到 workerChan 的 channel 中；</li><li>workerChan 有一个 Goroutine 一直循环获取 channel 中的数据，获取到之后就会对请求进行处理然后返回。</li></ol><p>实现方法: (类似于协程池)</p><ul><li>workerChan 其实就是一个连接处理对象，这个对象里面有一个 channel 用来传递连接；</li><li>每个 workerChan 在后台都会有一个 Goroutine 循环获取 channel 中的连接，然后进行处理。</li><li>如果没有设置最大同时连接处理数的话，默认是 <code>256 * 1024</code>个。</li><li>这样可以在并发很高的时候还可以同时保证对外提供服务。</li></ul><p>参考:</p><p><a href="https://www.luozhiyun.com/archives/574">fasthttp：比net/http快十倍的Go框架(server 篇)</a></p><p><a href="https://www.luozhiyun.com/archives/561">一文说透 Go 语言 HTTP 标准库</a> </p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p><a href="https://www.flysnow.org/2021/02/28/golang-embed-for-web.html">embed</a>：1.16 新增的embed在各流行Web框架中的应用</p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1362784031968149504&amp;__biz=MzI3MjU4Njk3Ng==#wechat_redirect">Gin实战</a>：Go 语言如何玩转 RESTful API 服务？？</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484393&amp;idx=1&amp;sn=4a27e735672c820ac266484333a806b7&amp;chksm=eb310266dc468b7081405477779b75d2b565ec8255143338f6b037f1725f91a7a468b890f7b1&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">Restful API</a> ：<code>net/http</code>请求的URL需要一个个去注册，Gin提供了URL路由的<strong>模糊匹配</strong>，比如URL路径中的参数</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484397&amp;idx=1&amp;sn=05d25b404f117cca76dd2097d3befab3&amp;chksm=eb310262dc468b74724a03d345e9b3ef21b39a38682836f4b00683d7b04fc7264a41649d6a0e&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">路由参数</a>：<code>/users/id</code> 通过这个<code>id</code>参数，获取对应的用户信息</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() {    r := gin.Default()    r.GET("/users/:id", func(c *gin.Context) {        id := c.Param("id")        c.String(200, "The user id is  %s", id)    })    r.Run(":8080")}// 输入 http://localhost:8080/users/123// The user id is  123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">Pattern: /users/:id/users/123          匹配/users/哈哈        匹配/users/123/go      不匹配/users/             不匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">Pattern: /users/*id/users/123         匹配/users/哈哈        匹配/users/123/go      匹配/users/            匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484116&amp;idx=1&amp;sn=8abf9049e47386d503d7b653541cce16&amp;chksm=eb31035bdc468a4d75b42d2f3ad82154b88665aeb46b083f466499942bb41f3483117edc1e24&amp;scene=21#wechat_redirect">HTTP路由httprouter</a>：自定义路由</p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484405&amp;idx=1&amp;sn=39eead58bac34c9b93e37f0832537e53&amp;chksm=eb31027adc468b6c9f6a8df901fc45dca2c2ad1d528e6c93a6193e15c6e8df322c72a4cdc811&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">URL查询参数的获取和原理分析</a>：Gin获取查询参数 <code>Query</code>源码分析 </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484410&amp;idx=1&amp;sn=807f89e1d6ba0f96558a66b82b08358b&amp;chksm=eb310275dc468b63fd5f94a772413edb0c223f0bae213055f14494dc0ff76e99a66b98ffe3ac&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">接收数组和 Map</a>：<code>QueryArray</code>  / <code>QueryMap</code> </p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484425&amp;idx=1&amp;sn=2a604e79d19c091410291d690d308dd5&amp;chksm=eb310586dc468c90eb0de31503ca6c2da9fa2b29ccb22eb5f3e37ed26d3b9a60fdbc7d6fba59&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">获取Form表单参数</a>：</p><table><thead><tr><th align="left">查询参数</th><th align="left">Form表单</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Query</td><td align="left">PostForm</td><td align="left">获取key对应的值，不存在为空字符串</td></tr><tr><td align="left">GetQuery</td><td align="left">GetPostForm</td><td align="left">多返回一个key是否存在的结果</td></tr><tr><td align="left">QueryArray</td><td align="left">PostFormArray</td><td align="left">获取key对应的数组，不存在返回一个空数组</td></tr><tr><td align="left">GetQueryArray</td><td align="left">GetPostFormArray</td><td align="left">多返回一个key是否存在的结果</td></tr><tr><td align="left">QueryMap</td><td align="left">PostFormMap</td><td align="left">获取key对应的map，不存在返回空map</td></tr><tr><td align="left">GetQueryMap</td><td align="left">GetPostFormMap</td><td align="left">多返回一个key是否存在的结果</td></tr><tr><td align="left">DefaultQuery</td><td align="left">DefaultPostForm</td><td align="left">key不存在的话，可以指定返回的默认值</td></tr></tbody></table><p> <a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247484434&amp;idx=1&amp;sn=0bd93e3ab59e4bf5f9ed2a965395647e&amp;chksm=eb31059ddc468c8b4bd003f680aaacf9a7cf2e9d539a5e20a7e4dca97e53cf1bf3d323aac923&amp;scene=178&amp;cur_album_id=1362784031968149504#rd">分组路由源代码分析</a>：路由中间件 / 分组路由嵌套</p><h2 id="优雅重启"><a href="#优雅重启" class="headerlink" title="优雅重启"></a>优雅重启</h2><p><a href="https://mp.weixin.qq.com/s/yryqf8SCzvt-BFj8j5bZ2w">一文讲懂服务的优雅重启和更新</a> </p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GracefulStopOfGo-zero.png" style="zoom:67%;"><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>编译Proto文件，并生成语句：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">protoc --go_out=plugins=grpc:. ./proto/*.proto<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考：</p><p><a href="https://golang2.eddycjy.com/posts/ch3/03-simple-grpc/">gRPC 的使用和了解</a> </p><p><a href="https://juejin.cn/post/6887388610367553549">gRPC服务注册发现及负载均衡的实现方案与源码解析</a> ：<code>Resolver</code> / <code>Balancer</code> / <code>RoundRobin</code> </p><h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>G — 表示 Goroutine，它是一个待执行的任务；</li><li>M — 表示操作系统的线程，它由<em>操作系统</em>的“调度器” 调度和管理；</li><li>P — 表示处理器，它可以被看做运行在线程上的<strong>本地调度器</strong>；</li></ol><p>可以在程序中使用 <a href="https://draveness.me/golang/tree/runtime.GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a> 来改变最大的活跃线程数</p><img src="go.assets/image-20210524211104374.png" alt="image-20210524211104374" style="zoom:67%;"><ul><li>默认情况下，四核机器会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 <a href="https://draveness.me/golang/tree/runtime.m"><code>runtime.m</code></a> 结构体</li></ul><h3 id="P与-G-x2F-M"><a href="#P与-G-x2F-M" class="headerlink" title="P与 G / M"></a>P与 G / M</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct P {Lock;uint32status;P*link;uint32tick;M*m;// 反向持有一个线程MCache*mcache;G**runq;// 可运行的 Goroutine 组成的环形的运行队列int32runqhead;int32runqtail;int32runqsize;G*gfree;int32gfreecnt;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GMPOfGolang.png" style="zoom:67%;"><ul><li>调度器在调度时，会从处理器(P)的队列中，选择<em>队列头</em>的 Goroutine 放到线程 M 上执行</li></ul><h3 id="GMP-amp-Thread"><a href="#GMP-amp-Thread" class="headerlink" title="GMP &amp; Thread"></a>GMP &amp; Thread</h3><ul><li><p>调度器通过使用与 CPU 数量相等的线程（CPU数量 == 线程数量）减少线程频繁切换的内存开销</p></li><li><p>同时，在每一个线程上，执行额外开销更低的 <code>Goroutine</code> 来，<strong>降低</strong>操作系统和硬件的负载</p></li></ul><p> <a href="https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw">Goroutine 数量控制在多少合适，会影响 GC 和调度？</a> </p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/GoWithMemoryLayout.png" style="zoom:67%;"><p>对应的数据结构 <a href="https://draveness.me/golang/tree/runtime.mspan"><code>runtime.mspan</code></a>、<a href="https://draveness.me/golang/tree/runtime.mcache"><code>runtime.mcache</code></a>、<a href="https://draveness.me/golang/tree/runtime.mcentral"><code>runtime.mcentral</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.mheap"><code>runtime.mheap</code></a> </p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>golang10次内存泄漏，8次goroutine泄漏，1次是真正内存泄漏，还有1次是cgo导致的内存泄漏</strong>。</p><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/memory_out_example.png" style="zoom:67%;"><ul><li>RES：常驻内存</li></ul><h3 id="泄漏情况"><a href="#泄漏情况" class="headerlink" title="泄漏情况"></a>泄漏情况</h3><p>1、可能服务分配的内存小了</p><p>2、资源没有关闭：http请求返回的rsp的body，还有一些打开的文件资源等（defer关掉）</p><p>3、goroutine泄漏</p><p>4、cgo导致的内存泄漏（cgo都是<strong>单独开一个线程</strong>进行处理的，这种是runtime不能管理的）</p><h3 id="分析命令"><a href="#分析命令" class="headerlink" title="分析命令"></a>分析命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go tool pprof -inuse_space http://ip:amdin_port/debug/pprof/heap# -inuse_space：当前服务使用的内存情况# -alloc_space：指服务启动以来总共分配的内存情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http://ip:admin_port/debug/pprof/heap?debug=1# 把当前内存分配的详情文件抓下来，本地会生成一个叫heap?debug=1的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http://ip:admin_port/debug/pprof/goroutine?debug=1# debug=1：获取服务当前goroutine的数目和大致信息wget http://ip:admin_port/debug/pprof/goroutine?debug=2# debug=2：获取服务当前goroutine的详细信息# 分别在本地生成了goroutine？debug=1和goroutine？debug=2文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 服务线程挂的子线程有多少# -m：显示所有的线程# -p：pid进程使用cpu的时间# -o：该参数后是用户自定义格式ps -mp 进程 -o THREAD,tid,time | wc -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://mp.weixin.qq.com/s/FyHEiaa-UfyLStMKl2VFGA">golang：快来抓住让我内存泄漏的“真凶”！</a>  </p><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>Golang中time包有两个定时器，分别为ticker 和 timer。两者都可以实现定时功能，但各自都有自己的使用场景。</p><p>区别：</p><ul><li><strong>ticker</strong>定时器表示每隔一段时间就执行一次，一般可执行多次。</li><li><strong>timer</strong>定时器表示在一段时间后执行，默认情况下只执行一次，如果想再次执行的话，每次都需要调用 time.Reset()方法，此时效果类似ticker定时器。同时也可以调用stop()方法取消定时器</li><li>timer定时器比ticker定时器多一个Reset()方法，两者都有Stop()方法，表示停止定时器,底层都调用了stopTimer()函数。</li></ul><p><a href="https://blog.csdn.net/qq_39397165/article/details/108698640">timer 泄漏代码</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (b *BrokerImpl) broadcast(msg interface{}, subscribers []chan interface{}) {count := len(subscribers)concurrency := 1switch {case count &gt; 1000:concurrency = 3case count &gt; 100:concurrency = 2default:concurrency = 1}pub := func(start int) {for j := start; j &lt; count; j += concurrency {select {case subscribers[j] &lt;- msg:         case &lt;-time.After(time.Millisecond * 5): // 泄漏case &lt;-b.exit:return}}}for i := 0; i &lt; concurrency; i++ {go pub(i)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修复</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func (b *BrokerImpl) broadcast(msg interface{}, subscribers []chan interface{}) {count := len(subscribers)concurrency := 1switch {case count &gt; 1000:concurrency = 3case count &gt; 100:concurrency = 2default:concurrency = 1}//采用Timer 而不是使用time.After 原因：time.After会产生内存泄漏 在计时器触发之前，垃圾回收器不会回收Timerpub := func(start int) {idleDuration := 5 * time.MillisecondidleTimeout := time.NewTimer(idleDuration)// **defer idleTimeout.Stop()   // **for j := start; j &lt; count; j += concurrency {            // **if !idleTimeout.Stop(){select {case &lt;- idleTimeout.C:default:}}idleTimeout.Reset(idleDuration)  // **select {case subscribers[j] &lt;- msg:case &lt;-idleTimeout.C:case &lt;-b.exit:return}}}for i := 0; i &lt; concurrency; i++ {go pub(i)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://flydk.gitbooks.io/go/content/ch8/ch8-07.html">ticker 泄漏</a> </p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>参考： <a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">7.2 垃圾收集器</a> </p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p> <a href="https://www.cnblogs.com/457220157-FTD/p/14703692.html">golang面向对象分析</a>：封装 / 继承 / 多态</p><p>封装：struct</p><p>继承：</p><ul><li>​    匿名组合    (Pseudo is-a)</li><li>非匿名组合    (has-a)</li></ul><p>多态：接口</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/2022/05/22/shell/"/>
      <url>/2022/05/22/shell/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><a href="https://labuladong.gitee.io/algo/%E6%8A%80%E6%9C%AF/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html?q=">Linux文件系统</a>：<code>目录结构</code> </p><p><a href="https://labuladong.gitee.io/algo/%E6%8A%80%E6%9C%AF/linux%E8%BF%9B%E7%A8%8B.html">进程、线程 和文件描述符</a>: <code>task_struct</code> </p><p><a href="https://labuladong.gitee.io/algo/%E6%8A%80%E6%9C%AF/linuxshell.html">关于Linux必须知道的知识</a>：<code>标准输入和参数</code> / <code>shell和子程序</code> / <code>单引号和双引号的区别</code> / <code>sudo找不到命令</code> </p><h2 id="shell定义"><a href="#shell定义" class="headerlink" title="shell定义"></a>shell定义</h2><blockquote><p>作用：可以<strong>更方便的</strong> 使用 <strong>操作系统</strong> 的 <code>接口</code> </p></blockquote><blockquote><p>工作原理： 负责把用户输入的字符串转换到需要执行的程序，并把结果以某个形式画出来的 </p><p>列如： 在命令行里输入 “ls -Rl” 这种字符串。</p><ul><li>这个字符串被翻译成“ls”，“-R”，“-l”</li><li>“ls”帮我们找到那个之前写好的程序，并启动它；“-R”和“-l”被作为参数传给这个程序，告诉程序走“递归所有子目录”+“输出长格式”这部分代码</li></ul></blockquote><img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/ShellOfLinux.png" style="zoom:67%;"><blockquote><p> 【bash】 + 【terminal】大概可以理解为一个以<code>字符</code>为<strong>交互</strong>方式的 <strong>Shell</strong> </p></blockquote><p>bash 负责按照某种格式把用户的输出的字符串翻译：</p><ul><li>比如对于普通非空字符翻译为程序和参数，并尝试去PATH里找对应的程序；</li><li>对“空格”翻译成分隔符；对“$XXX”尝试进行环境变量的替换；</li><li>对“｜”翻译为管道；</li><li>对 “&gt;”翻译为输出重定向；</li><li>对一个指令末尾的“&amp;”翻译为将程序转到后台执行</li></ul><p>参考： <a href="https://www.zhihu.com/question/35382632">Shell 是用来解决什么问题的</a> </p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 配置环境变量vim /etc/profile# 最后行添加路径export PATH=$PATH:/home/mysql/bin# 生效source /etc/profile# 显示当前系统定义的所有环境变量export# 输出当前的PATH环境变量的值echo $PATH <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看当前的进程的网络# 可以使用 "ss" (socket statistics) 来替代 netstatnetstat -an | grep 进程号# 查看当前进程号对应的 PIDlsof -i :进程号kill -9 PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 打印出CPU占用过高进程的线程栈jstack PID# 查看某个进程中的 "线程状态"top -H -p pid# 或者也可以采用ps命令，来查看繁忙的线程信息ps -mp pid -o THREAD,tid,time ps -Lfp pid # 后台运行程序，关掉当前shell仍然可以执行./hello.sh &amp; disown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件校验及查找"><a href="#文件校验及查找" class="headerlink" title="文件校验及查找"></a>文件校验及查找</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sha1 文件校验sha1sum 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在 “文件夹范围内” 两天内修改的文件/文件夹find 范围 -mtime -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://jingyan.baidu.com/article/636f38bb6e0bdad6b846103e.html">Linux-文件搜索命令find的使用</a></p><h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 开机自启 /sbin/chkconfig --add server_name# 自定义开机文件cd /etc/systemd/system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 停止firewallsystemctl stop firewalld.service# 禁止firewall开机启动systemctl disable firewalld.service # 关闭 selinuxvim /etc/selinux/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#修改防火墙： /etc/sysconfig/iptables文件# 查看自己目前的防火墙端口情况：iptables -L -n1、停止并屏蔽firewalld服务systemctl stop firewalldsystemctl mask firewalld2、安装iptables-services软件包yum install iptables-services3、在引导时启用iptables服务systemctl enable iptables4、启动iptables服务systemctl start iptables5、保存防火墙规则service iptables save# or/usr/libexec/iptables/iptables.init save6、附加：停止、启动，重启防火墙systemctl [stop|start|restart] iptables# 不出意外执行完这些操作之后，你应该就能轻松的发现这个文件了# 现在接着修改/etc/sysconfig/iptables文件vim /etc/sysconfig/iptables<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 修改网络vim /etc/sysconfig/network-scripts/ifcfg-enp0s3# centos6的网卡重启方法：service network restart# centos7的网卡重启方法：systemctl restart network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内存-x2F-磁盘相关"><a href="#内存-x2F-磁盘相关" class="headerlink" title="内存/磁盘相关"></a>内存/磁盘相关</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看 "内存" 包括物理内存和虚拟内存swapfree -h# 查看 "磁盘" 的使用量df -h# fdisk创建和维护分区表的程序fdisk -l # 设置分区fdisk /dev/sdb# 查看sdb的分区情况lsblk /dev/sdb# make file system, 在特定的分区上建立 linux 文件系统,mkfs -t ext4 /dev/sdb1# 挂载新磁盘mount /dev/sdb1  /mnt/newdisk# 永久挂载vim /etc/fstab/dev/sda1/dragonballext4defaults0 0hdparm -i /dev/sda1hdparm -i /dev/sdb1 |grep -i serialno# SerialNo=Z1Z0MKWS 硬盘序列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.linuxprobe.com/mount-detail-parameters.html">mount命令</a></p><p><a href="https://snapshooter.io/blog/how-to-grow-an-ext234-file-system-with-resize2fs-">How to grow file system</a>: 除了主分区外</p><p><a href="https://linuxconfig.org/how-to-resize-ext4-root-partition-live-without-umount">Resize Root Partition in Linux</a></p><p><a href="https://www.cnblogs.com/chenmh/p/5096592.html">使用fdisk扩容分区</a></p><h4 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># "xargs" 读取输入源，然后逐行处理# 删除目录中的所有class文件: find . | grep .class$ | xargs rm -rvf#把所有的rmvb文件拷贝到目录ls *.rmvb | xargs -n1 -i cp {} /mount/xiaodianying<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ssh连接设置"><a href="#ssh连接设置" class="headerlink" title="ssh连接设置"></a>ssh连接设置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 修改sshdvim /etc/ssh/sshd_config# 打开权限：# PermitRootLogin yes# PubkeyAuthentication yes# PasswordAuthentication yessystemctl restart sshd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><h4 id="整机"><a href="#整机" class="headerlink" title="整机"></a>整机</h4><ul><li>top </li><li>uptime，系统性能命令的精简版</li></ul><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul><li><p>vmstat -n 2 3    每两秒采样一次，共计采样三次</p><ul><li><p>procs：</p><ul><li>r：<code>运行/等待CPU时间片的进程数</code>，原则上1核的CPU运行队列不要超过2，整个系统的运行队列不能超过 2*总核数</li></ul></li><li><p>b：<code>等待资源的进程数</code>，比如正在等待磁盘I/O 、网络I/O等</p></li></ul></li></ul><h3 id="第三方命令"><a href="#第三方命令" class="headerlink" title="第三方命令"></a>第三方命令</h3><p><a href="https://zhuanlan.zhihu.com/p/102176365?utm_oi=1129729846456283136">shell基本语法</a> </p><h3 id="vim常用"><a href="#vim常用" class="headerlink" title="vim常用"></a>vim常用</h3><ul><li><p><code>u</code> 撤销当前操作</p></li><li><p><code>.</code> 重复上一次的命令</p></li><li><p><code>N+命令</code>重复某个命令 N 次</p></li></ul><p>参考：<a href="https://juejin.cn/post/6934580280627822599#heading-2">vim高级使用</a> </p><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>请求输入， <code>read</code> 命令读取到的文本会立即被存储在一个变量里。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash# filename: read.shread nameecho "hello $name !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>./read.sh</code> 时，会发现光标处于接收输入的状态，此时输入一个字符串 <code>will</code> 按下回车键后，控制台会打印出 <code>hello will</code> </p><h4 id="同时给几个变量赋值"><a href="#同时给几个变量赋值" class="headerlink" title="同时给几个变量赋值"></a>同时给几个变量赋值</h4><p>可以用 <code>read</code> 命令一次性给多个变量赋值， <code>read</code> 命令一个单词一个单词（空格分开）地读取你输入的参数，并且把每个参数赋值给对应的变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashread oneName towNameecho "hello $oneName $towName !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="显示提示信息"><a href="#显示提示信息" class="headerlink" title="显示提示信息"></a>显示提示信息</h4><p><code>read</code> 命令的 <code>-p</code> 参数， <code>p</code> 是 <code>prompt</code> 的首字母，表示“提示”。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashread -p "请输入您的姓名：" nameecho "hello $name !"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 换行read -p $'please input file.csv (need format is CSV UTF-8) \x0a' file_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="限制字符数目"><a href="#限制字符数目" class="headerlink" title="限制字符数目"></a>限制字符数目</h4><p>用 <code>-n</code> 参数可以限制用户输入的字符串的最大长度（字符数）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p "请输入您的姓名：" -n 5 name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="限制输入时间"><a href="#限制输入时间" class="headerlink" title="限制输入时间"></a>限制输入时间</h4><p>用 <code>-t</code> 参数可以限定用户的输入时间（单位：秒）超过这个时间，就不读取输入了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p "请输入您的姓名：" -n 5 -t 10 name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="隐藏输入内容"><a href="#隐藏输入内容" class="headerlink" title="隐藏输入内容"></a>隐藏输入内容</h4><p>用 <code>-s</code> 参数可以隐藏输入内容，在用户输入密码时使用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read -p "请输入密码：" -s password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p> Shell 变量 分为<strong>系统变量</strong>和<strong>自定义变量</strong> </p><ul><li>系统变量有$HOME、$PWD、$USER等</li></ul></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set # 显示当前shell所有变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="设置普通变量"><a href="#设置普通变量" class="headerlink" title="设置普通变量"></a>设置普通变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 等号两侧不能有空格，变量名一般习惯用大写# 变量名=变量值WILL=14# 删除变量unset WILL# 声明静态变量，静态变量不能unsetreadonly WILL# 使用变量echo $WILL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.runoob.com/linux/linux-comm-declare.html">还有declare命令</a> </p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/profile# export 变量名=变量值，将 Shell 变量输出为环境变量export JAVA_HOME=/usr/jdk1.8# source 配置文件路径，让修改后的配置信息立即生效source /etc/profile# echo $变量名，检查环境变量是否生效echo $JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><ul><li>$n ：$0 代表命令本身、$1-$9 代表第1到9个参数，10以上参数用花括号，如 ${10}。</li><li>$* ：命令行中所有参数，且把所有参数<strong>看成一个整体</strong>。</li><li>$@ ：命令行中所有参数，且把每个参数<strong>区分</strong>对待，for循环中常用。</li><li>$# ：所有参数个数。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim positionPara.sh#!/bin/bash     # 输出各个参数 echo $0 $1 $2 echo $* echo $@ echo 参数个数=$#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh positionPara.sh left right# 执行后的结果：positionPara.sh left rightleft rightleft right2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="错误号"><a href="#错误号" class="headerlink" title="错误号"></a>错误号</h3><p><code>$?</code> ： 在 Linux 下，所有的程序在结束时，都会有一个返回值，或者称为错误号 ( Error Number )</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls *.sh# ......echo $?# 0: 只要返回值是 0，就代表程序执行成功了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>应用：</strong> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo "database backup result: $? (0:successfully ;1:unsuccessfully)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>给其中所有 markdown 文件最下方添加上一篇、下一篇、目录三个页脚链接，有的文章已经有了页脚，大部分都没有</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfilename=$1# 查看文件尾部是否包含关键词tail | grep '下一篇' $filename# grep 查找到匹配会返回 0，找不到则返回非 0 值[ $? -ne 0 ] &amp;&amp; { 添加页脚; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将上次命令执行是否成功的返回值放到提示符里面去will@localhost ~ $ export PS1="[\$?]${PS1}"[0]will@localhost ~ $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>用perror查看错误提示</strong> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">perror 2 OS error code   2:  No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><blockquote><p> 在赋值定义之前，事先在 Shell 脚本中直接引用的变量 </p></blockquote><p>基本语法：</p><ul><li>$$ ：当前进程的 PID 进程号。</li><li>$! ：后台运行的最后一个进程的 PID 进程号。 <code>!$</code>, 替换成上一次命令最后的路径</li><li>$? ：最后一次执行的命令的返回状态，0为执行正确，非0执行失败。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashecho 当前的进程号=$$# &amp;：后台的方式运行进程./hello.sh &amp;echo 最后一个进程的进程号=$!echo 最后执行的命令结果=$?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@izbp17osf716ivk4ilma92z test]# sh prePara.sh 当前的进程号=4781最后一个进程的进程号=4782最后执行的命令结果=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 没有加可执行权限$ /usr/bin/script.shzsh: permission denied: /usr/bin/script.sh$ chmod +x !$chmod +x /usr/bin/script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CDPATH"><a href="#CDPATH" class="headerlink" title="CDPATH"></a>CDPATH</h3><p><strong>在环境变量 <code>CDPATH</code> 中加入你常用的工作目录</strong>，当 <code>cd</code> 命令在当前目录中找不到你指定的文件/目录时，会自动到 <code>CDPATH</code> 中的目录中寻找。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ export CDPATH='~:/var/log'# cd 命令将会在 ～ 目录和 /var/log 目录扩展搜索$ pwd/home/will/musics$ cd mysqlcd /var/log/mysql$ pwd/var/log/mysql$ cd my_picturescd /home/will/my_pictures<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>使用”$”来获取变量的时候最好加上双引号，举一个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/sh#已知当前文件夹有一个a.sh的文件var="*.sh"echo $varecho "$var"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 运行结果如下：a.sh*.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 为啥会这样呢？其实可以解释为他执行了下面的命令： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo *.shecho "*.sh"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号{}"></a>大括号{}</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cp /very/long/path/file{,.bak}# 给 file 复制一个叫做 file.bak 的副本$ rm file{1,3,5}.txt# 删除 file1.txt file3.txt file5.txt$ mv *.{c,cpp} src/# 将所有 .c 和 .cpp 为后缀的文件移入 src 文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​花括号中的每个字符都可以和之后（或之前）的字符串进行组合拼接，<strong>注意花括号和其中的逗号不可以用空格分隔，否则会被认为是普通的字符串对待</strong>。</p><h2 id="参数规范"><a href="#参数规范" class="headerlink" title="参数规范"></a>参数规范</h2><blockquote><p>当脚本需要接受参数的时候，一定要先判断参数是否合乎规范，并给出合适的回显，方便使用者了解参数的使用 </p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 判断参数的个数#!/bin/bashif [ $# != 2 ]then    echo "Parameter incorrect."    exit 1fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>获取某一段命令的执行结果，它的方式有两种：</p><ul><li><code>command</code></li><li><code>$(command)</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">all_files=`ls` # 获取ls命令的执行结果all_files=$(ls) # 效果同上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种命令替换的方式都是等价的，可以任选其一使用。</p><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><p>获取系统的所有用户并输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashindex=1for user in `cat /etc/passwd | cut -d ":" -f 1`do# cat /etc/passwd 获取系统中的所有用户和密码# cut -d ":" -f 1 根据冒号切每一行的字符串，获取切好后的第一部分# 使用for循环进行遍历，并输出用户echo "This is $index user: $user"index=$(($index + 1))done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取今年已经过了多少天和周：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo "This year have passed $(date +%j) days"echo "This year have passed $(($(date +%j)/7)) weeks"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意： <code>$(())</code> 用于数学运算， <code>$()</code> 用于命令替换，这两个是平时使用中特别容易混淆的语法。</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><code>bash</code> 中的运算方式有以下几种：</p><ul><li><code>$((...))</code> 或 <code>$[...]</code> </li><li><code>expr</code> </li><li><code>let</code> </li><li><code>bc</code> </li><li><code>declare -i</code></li></ul><h3 id="…"><a href="#…" class="headerlink" title="$((…))"></a>$((…))</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo $((2 + 2)) # 加法echo $((5 / 2)) # 除法i=0echo $((i++)) # 先返回值后运算echo $((++i)) # 先运算后返回值echo $(( (2 + 3) * 4 )) # 圆括号改变运算顺序echo $((0xff)) # 16进制转成10进制的运算echo $((16&gt;&gt;2)) # 位运算echo $((3 &gt; 2)) # 逻辑运算，如果逻辑表达式为真，返回1，否则返回0a=0echo $((a&lt;1 ? 1 : 0)) # 三元运算符echo $((a=1)) # 变量赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:  这个语法只能计算整数。</p><h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><p>语法格式： <code>expr $num1 operator $num2</code></p><p>操作符概览：</p><ul><li><code>num1 | num2</code> – <code>num1</code> 不为空且非0，返回 <code>num1</code> ; 否则返回 <code>num2</code> </li><li><code>num1 &amp; num2</code> – <code>num1</code> 不为空且非0，返回 <code>num1</code> ；否则返回0</li><li><code>num1 &lt; num2</code> – <code>num1</code> 小于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 &lt;= num2</code> – <code>num1</code> 小于等于 num2 ，返回1；否则返回0</li><li><code>num1 = num2</code> – <code>num1</code> 等于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 != num2</code> – <code>num1</code> 不等于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 &gt; num2</code> – <code>num1</code> 大于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 &gt;= num2</code> – <code>num1</code>  大于等于 <code>num2</code> ，返回1；否则返回0</li><li><code>num1 + num2</code> – 求和</li><li><code>num1 - num2</code> – 求差</li><li><code>num1 * num2</code> – 求积</li><li><code>num1 / num2</code> – 求商</li><li><code>num1 % num2</code> – 求余</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$num1=30; $num2=50expr $num1 \&gt; $num2 # 大于不成立，返回0expr $num1 \&lt; $num2 # 小于成立，返回1expr $num1 \| $num2 # 返回 num1expr $num1 \&amp; $num2 # 返回 num1expr $num1 + $num2 # 计算加法num3=`expr $num1 + $num2` # 计算结果赋值给num3expr $num1 - $num2 # 计算减法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[注意] <code>&gt;</code>、<code>&lt;</code> 等操作符是 <code>Shell</code> 中的保留关键字，因此需要进行转义。否则就变成输出和输入重定向了。</p><h4 id="练习案例"><a href="#练习案例" class="headerlink" title="练习案例"></a>练习案例</h4><p>提示用户输入一个正整数 <code>num</code> ，然后计算从 <code>1+2+3</code> 加到给定正整数。 必须对给定的 <code>num</code> 值进行是否为正整数判断，如果不是正整数则重新输入。</p><p>代码实现：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashwhile true # 无限循环接收用户输入doread -p "pls input a positive number: " num # 接收到用户的输入，存为num值expr $num + 1 2&gt;&amp;1 /dev/null # 对num进行加1的运算，运算结果重定向到/dev/null      # 由于 expr 只能运算整数，如果运算浮点数的话会报错，$?获取的是表达式执行结果，并非运算结果      # 执行结果如果是正常的返回0if [ $? -eq 0 ];then # $? 获取到上一次运算结果if [ `expr $num \&gt; 0` -eq 1 ];then # 上面判断了是否为整数，这里判断是否为正整数    # 类似JavaScript循环的写法遍历一个数值for((i=1;i&lt;=$num;i++))dosum=`expr $sum + $i` # 获取运算结果总和doneecho "1+2+3+....+$num = $sum" # 输出运算结果exit # 退出循环fifiecho "error,input enlegal" # 表示输入的值有误continue # 如果输入有误继续循环让用户输入done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><p><code>let</code> 命令声明变量时，可以直接执行算术表达式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">let "foo = 1 + 2"echo $foo # 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h3><p>支持浮点数运算</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo "scale=2;23/5" | bc # scale表示浮点位数num1=`echo "scale=2;23/5" | bc` # 运算结果保存为变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="declare-i-命令"><a href="#declare-i-命令" class="headerlink" title="declare -i 命令"></a>declare -i 命令</h3><p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -i val1=12 val2=5declare -i resultresult=val1*val2echo $result # 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h2><p><code>declare</code> 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare OPTION VARIABLE=value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-r</code> 将变量设为只读；</li><li><code>-i</code> 将变量设为整数；</li><li><code>-a</code> 将变量定义为数组；</li><li><code>-f</code> 显示此脚本前定义过的所有函数及内容；</li><li><code>-F</code> 仅显示此脚本前定义过的函数名；</li><li><code>-x</code> 将变量声明为环境变量。</li></ul><p><code>declare</code>命令如果用在函数中，声明的变量只在函数内部有效，等同于<code>local</code>命令。</p><p>不带任何参数时，<code>declare</code>命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的<code>set</code>命令。</p><h5 id="i"><a href="#i" class="headerlink" title="-i"></a><code>-i</code></h5><p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -i val1=12 val2=5declare -i resultresult=val1*val2echo $result # 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="x"><a href="#x" class="headerlink" title="-x"></a><code>-x</code></h5><p><code>-x</code> 参数等同于 <code>export</code> 命令，可以输出一个变量为子 <code>Shell</code> 的环境变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -x foo=3 # 等同于export foo=3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="r"><a href="#r" class="headerlink" title="-r"></a><code>-r</code></h5><p><code>-r</code> 参数可以声明只读变量，无法改变变量值，也不能 <code>unset</code> 变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -r bar=1# 如果此时更改barbar=2 # -bash: bar：只读变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="u"><a href="#u" class="headerlink" title="-u"></a><code>-u</code></h5><p><code>-u</code> 参数声明变量为大写字母，可以自动把变量值转成大写字母。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -u foofoo=upperecho $foo # UPPER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="l"><a href="#l" class="headerlink" title="-l"></a><code>-l</code></h5><p><code>-l</code> 参数声明变量为小写字母，可以自动把变量值转成小写字母。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">declare -l barbar=LOWERecho $bar # lower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="p"><a href="#p" class="headerlink" title="-p"></a><code>-p</code></h5><p><code>-p</code> 参数输出变量信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">foo=hellodeclare -p foo #控制台输出：declare -x foo="hello"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array=('v1' 'v2' 'v3') <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="输出数组内容"><a href="#输出数组内容" class="headerlink" title="输出数组内容"></a>输出数组内容</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">${array[@]} # 输出全部内容${array[*]} # 也是输出全部内容${array[1]} # 输出下标索引为1的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">${#array} # 数组内元素个数${#array[2]} # 数组内下标为2的元素长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">array[0]="frank" # 给数组下标为1的元素赋值为frankarray[20]="lion" # 在数组尾部添加一个新元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unset array[2] # 清除元素unset array # 清空整个数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for v in ${array[@]}dodone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim guessGame.sh#!/bin/bashecho '你猜的数字为：'$1if [ $1 -gt 7 ]then        echo '大于7'elif [ $1 -lt 4 ]then        echo '小于4'fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ condition ] : 前后都要有空格，非空返回0，0为true，否则为falseif [ : `if`距离条件方括号之间，需要有空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 是否存在文件/root/shell/isExist.txt if [ -e /root/shell/isExist.txt ] then     echo '存在' fi  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ $1 = 7 ] &amp;&amp; echo 'hello' || echo 'world' then     echo '条件满足，执行后面的语句' fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case $变量名 in"值1")如果变量值等于值1，则执行此处程序1;;"值2")如果变量值等于值2，则执行此处程序2;;...省略其它分支...*)如果变量值不等于以上列出的值，则执行此处程序;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">case $1 in"1")echo 周一;;"2")echo 周二;;*)echo 其它;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 语法1for 变量名 in 值1 值2 值3...do    程序done# 语法2for ((初始值; 循环控制条件; 变量变化))do    程序done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="语法一"><a href="#语法一" class="headerlink" title="语法一"></a>语法一</h3><p>==$*== ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash  # 使用$* for i in "$*" do         echo "the arg is $i" done # 输出：thearg is 1 2 3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> ==$@== ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash  # 使用$@ for j in "$@" do         echo "the arg is $j" done# 输出：the arg is 1 the arg is 2 the arg is 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bash SUM=0  for ((i=1;i&lt;=100;i++)) do         SUM=$[$SUM+$i] done echo $SUM# 输出从1加到100的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">while [ 条件判断式 ]do    程序done <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashSUM=0i=0while [ $i -le $1 ]do    SUM=$[$SUM+$i]    i=$[$i+1]done       echo $SUM# 输出从1加到100的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">read(选项)(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选项<ul><li>-p：指定读取值时的提示符 </li><li>-t：指定读取值时等待的时间（秒），如果没有在指定时间内输入，就不再等待</li></ul></li><li>参数<ul><li>变量名：读取值的变量名</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim guessGame.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>基本语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ function ] funname[()]{    Action;    [return int;]}# 调用funname 参数1 参数2...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>函数名后面的圆括号中<code>不加任何参数</code>，这点与主流编程语言不相同</li><li>函数的完整定义必须<code>置于函数的调用之前</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunction getSum(){    SUM=$[$n1+$n2]}   # 函数中的变量 均为全局变量，没有局部变量echo "sum=$SUM"read -p "请输入第一个参数n1：" n1read -p "请输入第二个参数n2：" n2# 调用 getSum 函数getSum $n1 $n2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashprint_something(){    echo "hello $1" # $1 获取第一个参数}print_something Lion # Lion 为参数print_something Frank # Frank 为参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p> shell中函数的返回值<code>只能是整数</code>  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashprint_something(){    echo "Hello $1"    return 1}print_something willecho "函数的返回值是 $?" # $? 获取到的是上一个函数的返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 也可以通过下面变通的方法:   通过echo或者print之类的就可以做到<code>传一些额外参数</code>的目的 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunc(){    echo "2333"}res=$(func)echo "This is from function: $res."<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的局部变量"><a href="#函数的局部变量" class="headerlink" title="函数的局部变量"></a>函数的局部变量</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashlocal_global(){# 通过 local 关键字定义局部变量  local var1='local 1'   echo "var1 is $var1"}local_global<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="巧用main函数"><a href="#巧用main函数" class="headerlink" title="巧用main函数"></a>巧用main函数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunc1(){    #do sth}func2(){    #do sth}main(){    func1    func2}main "$@"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>func1 / func2 必须定义在<strong>调用</strong>main函数之前，可以定义在main函数之后</p></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashvar=1func(){   var=2}funcecho $var# 2 : 输出结果就是2而不是1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><h3 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h3><ul><li>basename，删掉路径最后一个 / 前的所有部分（包括/），常用于获取文件名 <ul><li>basename [pathname] [suffx]</li><li>basename [string] [suffx]</li><li>如果指定 suffx，也会删掉pathname或string的后缀部分</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">basename /usr/bin/sort  # sort  basename include/stdio.h  # stdio.h  basename include/stdio.h .h # stdio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h3><ul><li>dirname，删掉路径最后一个 / 后的所有部分（包括/），常用于获取文件路径 <ul><li>dirname pathname</li><li>如果路径中不含 / ，则返回 ‘.’ （当前路径）</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dirname /usr/bin/  # /usr  dirname dir1/str dir2/str # dir1 # dir2  dirname stdio.h # .# 表示当前路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>替换规则：</p><ul><li><code>${变量名#匹配规则}</code> 从变量开头进行规则匹配，将符合最短的数据删除。</li><li><code>${变量名##匹配规则}</code> 从变量开头进行规则匹配，将符合最长的数据删除。</li><li><code>${变量名%匹配规则}</code> 从变量尾部进行规则匹配，将符合最短的数据删除。</li><li><code>${变量名%%匹配规则}</code> 从变量尾部进行规则匹配，将符合最长的数据删除。</li><li><code>${变量名/旧字符串/新字符串}</code> 变量内容符合旧字符串，则第一个旧字符串会被新字符串取代。</li><li><code>${变量名//旧字符串/新字符串}</code> 变量内容符合旧字符串，则全部旧字符串会被新字符串取代。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="I love you, Do you love me"var=${var_1#*ov} # e you, Do you love mevar=${var_1##*ov} # e mevar=${var_1%ov*} # I love you, Do you lvar=${var_1%%ov*} # I lvar_2="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"# 第一个小写bin被替换为大写的BINvar=${var_2/bin/BIN} # /usr/local/BIN:/usr/bin:/bin:/usr/sbin:/sbin # 所有小写bin会被替换为大写的BINvar=${var_2//bin/BIN} # /usr/local/BIN:/usr/BIN:/BIN:/usr/sBIN:/sBIN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算字符串的长度"><a href="#计算字符串的长度" class="headerlink" title="计算字符串的长度"></a>计算字符串的长度</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">`${#string}` `expr length "$string"` 如果 `string` 有空格则必须加双引号。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="Hello world"len=${#var_1} # 11len=`expr length "$var_1"` # 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取子串在字符串中的索引位置"><a href="#获取子串在字符串中的索引位置" class="headerlink" title="获取子串在字符串中的索引位置"></a>获取子串在字符串中的索引位置</h3><ul><li><code>expr index $string $substring</code> 从1开始计算索引位置。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="quickstart is an app"ind=`expr index "$var_1" start` # 6ind=`expr index "$var_1" uniq` # 1ind=`expr index "$var_1" f` # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它其实是按照子串的每个字符每个字符去进行匹配</p><ul><li>第一个例子匹配到的是 <code>s</code> 位置6。</li><li>第二个匹配到的是 <code>q</code> 位置1。</li><li>第三个例子什么都没有匹配到所以位置是0。</li></ul><h3 id="计算子串长度"><a href="#计算子串长度" class="headerlink" title="计算子串长度"></a>计算子串长度</h3><p><code>expr match $string substr</code>从头开始匹配子串长度，如果没有匹配到则返回0，匹配到了则返回配的子串长度。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="quickstart is an app"sub_len=`expr match "$var_1" app` # 0sub_len=`expr match "$var_1" quic` # 4sub_len=`expr match "$var_1" quic.*` # 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽取子串"><a href="#抽取子串" class="headerlink" title="抽取子串"></a>抽取子串</h3><ul><li><code>${string:position}</code> 从 <code>string</code> 的 <code>position</code> 开始。</li><li><code>${string:position:length}</code> 从 <code>position</code> 开始，匹配长度为 <code>length</code> 。</li><li><code>${string: -position}</code> 从右边开始匹配。</li><li><code>${string:(position)}</code> 从左边开始匹配。</li><li><code>expr substr $string $postion $length</code> 从 <code>position</code> 开始，匹配长度为 <code>length</code> 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var_1="quickstartisanapp"# 从索引10到最后提取子串，这种方式的索引是从0开始计算的substr=${var_1:10} # isanappsubstr=${var_1:10:2} # is# -5 前面需要添加空格，如果不添加空格也可以使用括号substr=${var_1: -5} # anappsubstr=${var_1:(-5)} # anapp# expr 这种方式的索引是从1开始substr=`expr substr "$var_1" 10 5` # tisan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h3><p>变量 <code>string="Bigdata process framework is Hadoop,Hadoop is an open source project"</code> 执行脚本后，打印输出 <code>string</code> 字符串变量，并给用户以下选项：</p><ul><li>(1)、打印 <code>string</code> 长度</li><li>(2)、删除字符串中所有的 <code>Hadoop</code> </li><li>(3)、替换第一个 <code>Hadoop</code> 为 <code>Mapreduce</code> </li><li>(4)、替换全部 <code>Hadoop</code> 为 <code>Mapreduce</code></li></ul><p>用户输入数字 <code>1|2|3|4</code> ，可以执行对应项的功能；输入 <code>q|Q</code> 则退出交互模式。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ol><li>打印字符串很简单，直接 <code>echo</code> 打印即可。</li><li>删除字符串也不难，使用 <code>${变量名//旧字符串/新字符串}</code> ，把 <code>Hadoop</code> 替换为空就从原字符串中删除了。</li><li>至于替换也是使用 <code>${变量名/旧字符串//新字符串}</code></li><li>用户输入，则使用的是上一篇文章讲到的 <code>read</code> 命令。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashstring="Bigdata process framework is Hadoop,Hadoop is an open source project"# 打印提示函数print_tips(){  echo "(1)、打印string长度"  echo "(2)、删除字符串中所有的Hadoop"  echo "(3)、替换第一个Hadoop为Mapreduce"  echo "(4)、替换全部Hadoop为Mapreduce"}# 输出字符串长度函数len_of_string(){  echo "${#string}"}# 替换Hadoop子串为空，相当于删除delete_Hadoop(){  echo "${string//Hadoop/}"}# 替换一个Hadoop为Mapreducerep_hadoop_mapreduce_first(){  echo "${string/Hadoop/Mapreduce}"}# 替换全部Hadoop为Mapreducerep_hadoop_mapreduce_all(){  echo "${string//Hadoop/Mapreduce}"}# 无限循环的接收用户输入，直到用户输入了q|Q则退出进程while truedo  echo "$string" # 打印字符串  echo # 打印一个空  print_tips # 输出提示信息  read -p "请输入你的选择(1|2|3|4|q|Q)：" choice # 接收用户输入  # 根据用户的输入，进入不同的分支，调用不同的函数  case $choice in    1)    len_of_string      ;;    2)    delete_Hadoop      ;;    3)    rep_hadoop_mapreduce_first      ;;    4)    rep_hadoop_mapreduce_all      ;;    q|Q)    exit      ;;    *)    echo "错误的输入"      ;;    esac  done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本三剑客"><a href="#文本三剑客" class="headerlink" title="文本三剑客"></a>文本三剑客</h2><p><a href="https://juejin.cn/post/6935365727205457928#heading-56">参考：文本处理</a> </p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep text file # text代表要搜索的文本，file代表供搜索的文件# 实例grep path /etc/profile# pathmunge () {#     pathmunge /usr/sbin#     pathmunge /usr/local/sbin#     pathmunge /usr/local/sbin after#     pathmunge /usr/sbin after# unset -f pathmunge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-i</code> 忽略大小写， <code>grep -i path /etc/profile</code></li><li><code>-n</code> 显示行号，<code>grep -n path /etc/profile</code></li><li><code>-v</code> 只显示搜索文本不在的那些行，<code>grep -v path /etc/profile</code></li><li><code>-r</code> 递归查找， <code>grep -r hello /etc</code> ， <code>Linux</code> 中还有一个 <code>rgrep</code> 命令，作用相当于 <code>grep -r</code></li></ul><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p><code>grep</code> 可以配合正则表达式使用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep -E path /etc/profile --&gt; 完全匹配pathgrep -E ^path /etc/profile --&gt; 匹配path开头的字符串grep -E [Pp]ath /etc/profile --&gt; 匹配path或Path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p><code>stream Editor</code> 的缩写，**<u>流编辑器</u><strong>，对</strong><em>标准输出或文件</em>** <code>逐行</code> 进行处理。</p><h4 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed [option] "pattern/command" file# 例如：sed '/python/p' name.txt # 省略了option# /python/ 为pattern正则# p 为command命令打印的意思<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：匹配模式中存在<u>变量要使用双引号</u>。</p><h4 id="选项-option"><a href="#选项-option" class="headerlink" title="选项 option"></a>选项 option</h4><h5 id="n-只打印模式匹配行"><a href="#n-只打印模式匹配行" class="headerlink" title="-n 只打印模式匹配行"></a><code>-n</code> 只打印模式匹配行</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed 'p' name.txt # 会对每一行字符串输出两遍，第一遍是原文本，第二遍是模式匹配到的文本sed -n 'p' name.txt # 加了-n参数后就只打印模式匹配到的行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="e-默认选项"><a href="#e-默认选项" class="headerlink" title="-e 默认选项"></a>-e 默认选项</h5><p>支持多个 <code>pattern command</code> 的形式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -e "pattern command" -e "pattern command" file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="f-指定动作文件"><a href="#f-指定动作文件" class="headerlink" title="-f 指定动作文件"></a>-f 指定动作文件</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 简单命令sed -n '/python/p' name.txt # 但是一旦正则比较复杂，我们就可以把它保存在一个单独文件中，使用-f进行指定sed -n -f edit.sed name.txt # '/python/p'这个命令保存在edit.sed文件中，使用-f指定# edit.sed 内容为 /python/p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="E-扩展表达式"><a href="#E-扩展表达式" class="headerlink" title="-E 扩展表达式"></a>-E 扩展表达式</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -n -E '/python|PYTHON/p' name.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="i-直接修改文件内容"><a href="#i-直接修改文件内容" class="headerlink" title="-i 直接修改文件内容"></a>-i 直接修改文件内容</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i 's/love/like/g' name.txt# -i修改原文件# 全部love替换为like<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="模式匹配-pattern"><a href="#模式匹配-pattern" class="headerlink" title="模式匹配 pattern"></a>模式匹配 pattern</h4><p><code>pattern</code> 用法表</p><table><thead><tr><th>匹配模式</th><th>含义</th><th>用法</th></tr></thead><tbody><tr><td><code>10command</code></td><td>匹配第10行</td><td><code>sed -n "17p" name.txt</code> 打印 name 文件的第17行</td></tr><tr><td><code>10,20command</code></td><td>匹配从第10行开始，到第20行结束</td><td><code>sed -n "10,20p" name.txt</code> 打印 <code>name</code> 文件的10到20行</td></tr><tr><td><code>10,+5command</code></td><td>匹配从第10行开始，到第15行结束</td><td><code>sed -n "10,+5p" name.txt</code></td></tr><tr><td><code>/pattern1/command</code></td><td>匹配到 <code>pattern1</code> 的行</td><td><code>sed -n "/^root/p" name.txt</code> 打印 <code>root</code> 开头的行</td></tr><tr><td><code>/pattern1/,/pattern2/command</code></td><td>匹配到 <code>pattern1</code> 的行开始，至匹配到 <code>pattern2</code> 的行结束</td><td><code>sed -n "/^ftp/,/^mail/p" name.txt</code></td></tr><tr><td><code>10,/pattern1/command</code></td><td>匹配从第10行开始，到匹配到 <code>pattern1</code> 的行结束</td><td><code>sed -n "4,/^ok/p" name.txt</code> 打印 <code>name</code> 文件从第4行开始匹配，直到以 <code>ok</code> 开头的行结束</td></tr><tr><td><code>/pattern1/,10command</code></td><td>匹配到 <code>pattern1</code> 的行开始，到第10行匹配结束</td><td><code>sed -n "/root/,10p" name.txt</code></td></tr></tbody></table><h4 id="命令-command"><a href="#命令-command" class="headerlink" title="命令 command"></a>命令 command</h4><ul><li>查询<ul><li><code>p</code> – 打印</li></ul></li><li>增加<ul><li><code>a</code> – 行后追加</li><li><code>i</code> – 行前追加</li><li><code>r</code> – 外部文件读入，行后追加</li><li><code>w</code> – 匹配行写入外部文件</li></ul></li><li>删除<ul><li><code>d</code> – 删除</li></ul></li><li>修改<ul><li><code>s/old/new</code> – 将行内第一个 <code>old</code> 替换为 <code>new</code></li><li><code>s/old/new/g</code> – 将行内全部的 <code>old</code> 替换为 <code>new</code></li><li><code>s/old/new/2g</code> –同一行，只替换从第二个开始到剩下所有的</li><li><code>s/old/new/ig</code> – 将行内 <code>old</code> 全部替换为 <code>new</code> ，忽略大小写</li></ul></li></ul><p>实例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed '/python/p' name.txt # 打印sed '1d' name.txt # 删除第一行sed -i '/frank/a hello' name.txt # 匹配到字符串frank就在这一行后面插入“hello”sed -i '/frank/r list' name.txt # 把list文件内容追加到匹配frank字符串后面的行sed -n '/frank/w tmp.txt' name.txt # 将匹配到frank的行全部写入tmp.txt文件中sed -i 's/love/like/g' name.txt # 全局替换love为like，并修改源文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="反向应用"><a href="#反向应用" class="headerlink" title="反向应用"></a>反向应用</h4><p>引用前面的匹配到的字符。</p><p>假设有一个文件 <code>test.txt</code> 内容为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a heAAo vbvc heBBo sdsadk heCCo mnh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在需要匹配到 <code>heAAo heBBo heCCo</code> 并在他们后面添加 <code>s</code> 。</p><p>使用反向引用可以这样做：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed -i 's/he..o/&amp;s/g' test.txt # 其中&amp;就是引用前面匹配到的字符sed -i 's/\(he..o\)/\1s/g' test.txt # 与上面的写法等价# 输出结果a heAAos vbvc heBBos sdsadk heCCos mnh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p><code>awk</code> 是一个文本处理工具，通常用于处理数据并生成结果报告。</p><h4 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{}pattern{commands}END{}' file_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>BEGIN{}</code> 正式处理数据之前执行；</li><li><code>pattern</code> 匹配模式；</li><li><code>{commands}</code> 处理命令，可能多行；</li><li><code>END{}</code> 处理完所有匹配数据后执行。</li></ul><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><ul><li><code>$0</code> – 整行内容。</li><li><code>$1-$n</code> – 当前行的第 <code>1-n</code> 个字段。</li><li><code>NF</code> – <code>Number Field</code> 的缩写，表示当前行的字段个数，也就是有多少列。</li><li><code>NR</code> – <code>Number Row</code> 的缩写，表示当前行的行号，从1开始计数。</li><li><code>FNR</code> – <code>File Number Row</code> 的缩写，表示多文本处理时，每个文件行号单独计数，都是从1开始。</li><li><code>FS</code> – <code>Field Separator</code> 的缩写，表示输入字段分隔符，不指定默认以空格或 <code>tab</code> 键分割。</li><li><code>RS</code> – <code>Row Separator</code> 的缩写，表示输入行分隔符，默认回车换行 <code>\n</code> 。</li><li><code>OFS</code> – <code>Output Field Separator</code> ，表示输出字段分隔符，默认为空格。</li><li><code>ORS</code> – <code>Output Row Separator</code> 的缩写，表示输出行分隔符，默认为回车换行。</li><li><code>FILENAME</code> – 当前输入的文件名字。</li><li><code>ARGC</code> – 命令行参数个数。</li><li><code>ARGV</code> – 命令行参数数组。</li></ul><p>注意：字段个数，非字符个数，例如 <code>"frank lion alan"</code> 这一行有3个字段。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk '{print $0}' /etc/passwd # 只有处理命令，输出每一行的内容awk 'BEGIN{FS=":"}{print $1}' /etc/passwd # 处理文本之前先定义好分隔符为冒号，然后打印每一行被冒号分割后的文本的第一个字段awk 'BEGIN{FS=":"}{print $NF}' /etc/passwd # 输出每一行的最后一列，NF中存的总列数，因此$NF表示最后一列的字段awk '{print $NF}' /etc/passwd # 输出每一行的字段个数（默认以空格分割后的字段个数）awk '{print NR}' /etc/passwd # 输出文件的行号awk '{print FNR}' /etc/passwd name.txt # 输出两个文件的行号，每个文件单独计数awk 'BEGIN{RS="---"}{print $0}' /etc/passwd # 行分隔符设置为---awk 'BEGIN{ORS="---"}{print $0}' /etc/passwd # 定义输出的每一行的分隔符为 --- awk 'BEGIN{ORS="---";RS="---"}{print $0}' /etc/passwd # BEGIN 中定义多个变量需要;分割awk '{print FILENAME}' name.txt # 输出name.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>备注：<code>/etc/passwd</code> 就是 <code>Linux</code> 系统中的密码文本，后续会一直使用，大概是如下格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 切割字符串，并生成数组cat excel-utf8.csv | while read linedo        #echo ${line} | awk 'BEGIN {FS=",";OFS=" "} {print $1, $2}'                # 读取每行，以","号分割，生成数组        arr=(`echo ${line} | awk '{len=split($0,a,","); for(i=1; i&lt;=len; i++) print a[i]}'`)                # 输出数组元素        echo "coustomer: ${arr[0]}, path: ${arr[1]}"done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.runoob.com/linux/linux-comm-cut.html">cut 可以从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出</a> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk -F : 'BEGIN {print "start1, start7"} {print $1 "," $7} END {print "end1, end7"}' /etc/passwd# NF,浏览记录的字段个数（Field) ; NR,已读的记录数, 每行依次递增; awk -F : '{ print NR  " "  NF  " "  $NF}' /etc/passwd  1 7 /bin/bash2 7 /sbin/nologin3 7 /sbin/nologin4 7 /sbin/nologin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><p><code>awk</code> 格式化输出。</p><p>格式符：</p><ul><li><code>%s</code> – 打印字符串；</li><li><code>%d</code> – 打印10进制数；</li><li><code>%f</code> – 打印浮点数；</li><li><code>%x</code> – 打印16进制数；</li><li><code>%o</code> – 打印8进制数；</li><li><code>%e</code> – 打印数字的科学计数法格式；</li><li><code>%c</code> – 打印单个字符的 <code>ASCII</code> 码。</li></ul><p>修饰符：</p><ul><li><code>-</code> – 左对齐；</li><li><code>+</code> – 右对齐；</li><li><code>#</code> – 显示8进制在前面加0，显示16进制在前面加 <code>0x</code> 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf $1}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入上面 <code>awk</code> 命令打印后得到这样的结果： <img src="https://cdn.jsdelivr.net/gh/MicroWiller/photobed@master/AWKPrintf.png"> 不再像使用 <code>print</code> 命令会默认以换行符作为默认的输出了，而是全部集中在一行，因此使用 <code>printf</code> 需要自定义输出格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf "%s\n",$1}' /etc/passwd # %s表示打印字符串 \n表示换行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <code>printf</code> 在处理多个字段的分隔符上是非常方便的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf "%20s %20s\n",$1,$7}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>%20s</code> 表示 <code>20</code> 个字符，如果实际字符不够会默认使用空格补全</li><li><code>$1</code> 表示第一部分， <code>$7</code> 表示第 <code>7</code> 部分</li></ul><p>默认是右对齐，也可以添加修饰符，使其左对齐：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{printf "%-20s %-20s\n",$1,$7}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d88954a4d18c4b62bff3bcbdbb8f71f0~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p>其它示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"} {printf "%d\n", $3}' /etc/passwd # 打印十进制数字，默认是左对齐的awk 'BEGIN{FS=":"} {printf "%20d\n", $3}' /etc/passwd # %20d 不够的位数默认补全空格，因此它是右对齐awk 'BEGIN{FS=":"} {printf "%f\n", $3}' /etc/passwd # 打印浮点数，默认保留小数点后6位置awk 'BEGIN{FS=":"} {printf "%0.2f\n", $3}' /etc/passwd # 打印浮点数，保留小数点后2位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模式匹配-pattern-1"><a href="#模式匹配-pattern-1" class="headerlink" title="模式匹配 pattern"></a>模式匹配 pattern</h4><p>它与 <code>sed</code> 的 <code>pattern</code> 非常类似，都是<code>按行</code>进行匹配。</p><p>模式匹配的两种用法：</p><ol><li>按正则表达式匹配</li><li>运算符匹配</li></ol><p>正则匹配：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 匹配/etc/passwd文件行中包含root字符串的所有行awk '/root/{print $0}' /etc/passwd# 匹配/etc/passwd文件行中以lion开头的所有行awk '/^lion/{print $0}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运算符匹配：</p><ul><li><code>&lt;</code> 小于</li><li><code>&gt;</code> 大于</li><li><code>&lt;=</code> 小于等于</li><li><code>&gt;=</code> 大于等于</li><li><code>==</code> 等于</li><li><code>!=</code> 不等于</li><li><code>~</code> 匹配正则表达式</li><li><code>!~</code> 不匹配正则表达式</li><li><code>||</code> 或</li><li><code>&amp;&amp;</code> 与</li><li><code>!</code> 非</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以:为分隔符，匹配/etc/passwd文件中第三个字段小于50的所有信息awk 'BEGIN{FS=":"}$3&lt;50{print $0}' /etc/passwd# 输出第三个字段值等于1的行awk 'BEGIN{FS=":"}$3==1{print $0}' /etc/passwd# 输出第七个字段值等于 /bin/bash 的行awk 'BEGIN{FS=":"}$7=="/bin/bash"{print $0}' /etc/passwd# 输出第三个字段值的位数大于3的行awk 'BEGIN{FS=":"}$3~/[0-9]{3,}/{print $0}' /etc/passwd# 以:为分隔符，匹配/etc/passwd文件中第一个字段包含hdfs或yarn的所有行信息awk 'BEGIN{FS=":"}$1=="lion" || $1=="frank" {print $0}' /etc/passwd# 以:为分隔符，匹配/etc/passwd文件中第三个字段小于50并且第四个字段大于50的所有行信息awk 'BEGIN{FS=":"}$3&lt;50 &amp;&amp; $4&gt;50{print $0}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="awk-中的表达式"><a href="#awk-中的表达式" class="headerlink" title="awk 中的表达式"></a>awk 中的表达式</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{var=20;var1="aaa";print var,var1}' # 输出 20 aaaawk 'BEGIN{n1=20;n2+=n1;print n1,n2}' # 20 20awk 'BEGIN{n1=20;n2=30;printf "%0.2f\n",n1/n2}' # 输出浮点数，精确到小数点后两位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在 <code>BEGIN</code> 和 <code>END</code> 中都可以正常执行表达式。</p><h5 id="练习：使用-awk-计算-etc-services-中的空白行数量"><a href="#练习：使用-awk-计算-etc-services-中的空白行数量" class="headerlink" title="练习：使用 awk 计算 /etc/services 中的空白行数量"></a>练习：使用 awk 计算 <code>/etc/services</code> 中的空白行数量</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># BEGIN 定义变量，通过正则/^$/匹配到空行后，执行sum++，全面匹配结束后在打印sum的值awk 'BEGIN{sum=0}/^$/{sum++}END{print sum}' /etc/services <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="awk-中的条件语句"><a href="#awk-中的条件语句" class="headerlink" title="awk 中的条件语句"></a>awk 中的条件语句</h4><p>语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if(条件表达式){动作1} else if(条件表达式){动作2}else{动作3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>练习：以冒号为分隔符，只打印 <code>/etc/passwd</code> 中第3个字段的数值在 <code>50-100</code> 范围内的行信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{ if($3&gt;50 &amp;&amp; $3&lt;100){print $0} }' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="awk-中的循环语句"><a href="#awk-中的循环语句" class="headerlink" title="awk 中的循环语句"></a>awk 中的循环语句</h4><p>语法格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># while 循环while(条件表达式)  动作    # do while 循环do  动作while(条件表达式)  # for循环for(初始化计数器;计数器测试;计数器变更)  动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="计算-1-2-3-…-100-的和"><a href="#计算-1-2-3-…-100-的和" class="headerlink" title="计算 1+2+3+…+100 的和"></a>计算 1+2+3+…+100 的和</h5><p><code>while</code> 循环：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建文件：while.awkBEGIN{  while(i&lt;=100){    sum+=i    i++  }  print sum}执行命令：awk -f while.awk # 以脚本的方式执行awk动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>for</code> 循环：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建文件：for.awkBEGIN{  for(i=0;i&lt;=100;i++)  {  sum+=i  }  print sum}执行命令：awk -f for.awk # 以脚本的方式执行awk动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>do...while</code> 循环：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">创建文件：do-while.awkBEGIN{  do  {    sum+=i    i++  }while(i&lt;=100)  print sum}执行命令：awk -f do-while.awk # 以脚本的方式执行awk动作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="awk-字符串函数"><a href="#awk-字符串函数" class="headerlink" title="awk 字符串函数"></a>awk 字符串函数</h4><ul><li><code>length(str)</code> 计算长度；</li><li><code>index(str1,str2)</code> 返回在 <code>str1</code> 中查询到的 <code>str2</code> 的位置；</li><li><code>tolower(str)</code> 小写转换；</li><li><code>toupper(str)</code> 大写转换；</li><li><code>split(str,arr,fs)</code> 分隔符字符串，并保存到数组中；</li><li><code>match(str,RE)</code> 返回正则表达式匹配到的子串位置；</li><li><code>substr(str,m,n)</code> 截取子串，从 <code>m</code> 个字符开始，截取 <code>n</code> 位。若 <code>n</code> 不指定，则默认截取到字符串末尾；</li><li><code>sub(RE,ReqStr,str)</code> 替换查找到的第一个子串；</li><li><code>gsub(RE,ReqStr,str)</code> 替换查找到的所有子串。</li></ul><h5 id="length-str"><a href="#length-str" class="headerlink" title="length(str)"></a>length(str)</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{print length($3)}' /etc/passwd # 计算第三个字段的长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="index-str1-str2"><a href="#index-str1-str2" class="headerlink" title="index(str1,str2)"></a>index(str1,str2)</h5><p>返回在 <code>str1</code> 中查询到的 <code>str2</code> 的位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{print index("I have a dream","ea")}' # 查找ea在字符串中的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="tolower-str"><a href="#tolower-str" class="headerlink" title="tolower(str)"></a>tolower(str)</h5><p>转换为小写字符</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{print tolower("I have a dream")}' # i have a dream<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="toupper-str"><a href="#toupper-str" class="headerlink" title="toupper(str)"></a>toupper(str)</h5><p>转换为大写字符</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{print toupper("I have a dream")}' # I HAVE A DREAM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="split-str-arr-fs"><a href="#split-str-arr-fs" class="headerlink" title="split(str,arr,fs)"></a>split(str,arr,fs)</h5><p>分隔符字符串，并保存到数组中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 将字符串"I have a dream"按照空格进行分割awk 'BEGIN{str="I have a dream";split(str,arr," ");for(a in arr) print arr[a]}'# 输出# dream# I# have# a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>for…in</code> 得到是无序的数组。如果需要得到有序数组，需要通过下标获得：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{str="I have a dream";len = split(str,arr," ");for(i=1;i&lt;=len;i++) print arr[i]}'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="match-str-RE"><a href="#match-str-RE" class="headerlink" title="match(str,RE)"></a>match(str,RE)</h5><p>返回正则表达式匹配到的子串位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 输出字符串第一个数字出现所在的位置awk 'BEGIN{str="I have 1 dream";print match(str,/[0-9]/)}' # 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="substr-str-m-n"><a href="#substr-str-m-n" class="headerlink" title="substr(str,m,n)"></a>substr(str,m,n)</h5><p>截取子串，从 <code>m</code> 个字符开始，截取 <code>n</code> 位。若 <code>n</code> 不指定，则默认截取到字符串末尾。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 截取字符串"I have a dream"的子串，从第四个位置开始，一直到最后awk 'BEGIN{str="I have a dream";print substr(str,4)}' # ave a dream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="sub-RE-ReqStr-str"><a href="#sub-RE-ReqStr-str" class="headerlink" title="sub(RE,ReqStr,str)"></a>sub(RE,ReqStr,str)</h5><p>替换查找到的第一个子串。</p><ul><li><code>RE</code> 为正则表达式</li><li><code>ReqStr</code> 为要替换的字符串</li><li><code>str</code> 为源字符串</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 替换字符串"I have 123 dream"中第一个数字为$符号awk 'BEGIN{str="I have 123 dream";sub(/[0-9]+/,"$",str);print str}' # I have $ dream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="gsub-RE-ReqStr-str"><a href="#gsub-RE-ReqStr-str" class="headerlink" title="gsub(RE,ReqStr,str)"></a>gsub(RE,ReqStr,str)</h5><p>替换查找到的所有子串</p><ul><li><code>RE</code> 为正则表达式</li><li><code>ReqStr</code> 为要替换的字符串</li><li><code>str</code> 为源字符串</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 替换字符串"I have 123 dream 456"中第一个数字为$符号awk 'BEGIN{str="I have 123 dream 456";gsub(/[0-9]+/,"$",str);print str}' # I have $ dream $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="选项-option-1"><a href="#选项-option-1" class="headerlink" title="选项 option"></a>选项 option</h4><ul><li><code>-v</code> 参数传递</li><li><code>-f</code> 指定脚本文件</li><li><code>-F</code> 指定分隔符</li><li><code>-V</code> 查看 <code>awk</code> 的版本号</li></ul><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><p><code>awk</code> 的 <code>BEGIN</code> 中不能直接使用 <code>shell</code> 中定义的变量，需要通过 <code>-v</code> 参数进行传递</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lion ~]# var=20[root@lion ~]# num=30[root@lion ~]# awk -v var1="$var" -v var2="$num" 'BEGIN{print var1,var2}'20 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="指定脚本文件"><a href="#指定脚本文件" class="headerlink" title="指定脚本文件"></a>指定脚本文件</h5><p><code>'BEGIN{}pattern{commands}END{}'</code> 这里的内容可以写在一个独立的文件中，通过 <code>-f</code> 参数来引入。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># test.awkBEGIN{  var=30  print var}awk -f test.awk # 输出30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法更易于编写和维护，适合复杂 <code>awk</code> 语句。</p><h5 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{print length($3)}' /etc/passwd等同于：awk -F : '{print length($3)}' /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="查看-awk-的版本号"><a href="#查看-awk-的版本号" class="headerlink" title="查看 awk 的版本号"></a>查看 awk 的版本号</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@lion ~]# awk -VGNU Awk 4.0.2Copyright (C) 1989, 1991-2012 Free Software Foundation....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># data.txt# 要求取反"糗大了": "qd","左哼哼": "zhh","右哼哼": "yhh","快哭了": "kk","左太极": "zuotj","右太极": "youtj","棒棒糖": "bbtang",<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">awk 'BEGIN{FS=":"}{print (substr($2,0,length($2)-1) ":" $1 ",") }' data.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="awk-处理生产数据实例"><a href="#awk-处理生产数据实例" class="headerlink" title="awk 处理生产数据实例"></a>awk 处理生产数据实例</h4><p>假设有一堆以下格式数据保存在文件 <code>data.txt</code> 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">2020-01-01 00:01:01 1000 Batches: user frank insert 2010 records databases:product table:detail, insert 1000 records successfully,failed 1010 records2020-01-01 00:01:02 1001 Batches: user lion insert 1030 records databases:product table:detail, insert 989 records successfully,failed 41 records2020-01-01 00:01:03 1002 Batches: user mike insert 1290 records databases:product table:detail, insert 235 records successfully,failed 1055 records2020-01-01 00:01:04 1003 Batches: user alan insert 3452 records databases:product table:detail, insert 1257 records successfully,failed 2195 records2020-01-01 00:01:05 1004 Batches: user ben insert 4353 records databases:product table:detail, insert 2245 records successfully,failed 2108 records2020-01-01 00:01:06 1005 Batches: user bily insert 5633 records databases:product table:detail, insert 3456 records successfully,failed 2177 records2020-01-01 00:01:07 1006 Batches: user frank insert 2010 records databases:product table:detail, insert 1000 records successfully,failed 1010 records<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计每个人员分别插入了多少条 record 进数据库，预期结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">USERTotal Recordsfrank4020lion  1030...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码演示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># data.awkBEGIN{printf "%-10s %-10s\n", "User", "Total Records"}{USER[$6]+=$8 # USER为数组，空格分割后$6这个变量是用户名，$8是records，每次都去数组中取出$6的值进行相加以获取重复用户的总Records}END{    for(u in USER) # 遍历USER数组，打印数组每一项    {    printf "%-10s %-10d\n", u , USER[u]    }}# awk 语句awk -f data.awk data.txt# 输出结果User       Total Recordsfrank      4020      mike       1290      bily       5633      alan       3452      lion       1030      ben        4353 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="heredocs"><a href="#heredocs" class="headerlink" title="heredocs"></a><strong>heredocs</strong></h2><p> 使用heredocs，可以非常方便的生成一些模板文件： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat&gt;&gt;/etc/rsyncd.conf &lt;&lt; EOFlog file = /usr/local/logs/rsyncd.logtransfer logging = yeslog format = %t %a %m %f %bsyslog facility = local3EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="脚本执行路径"><a href="#脚本执行路径" class="headerlink" title="脚本执行路径"></a>脚本执行路径</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pwd# pwd获得的是当前shell的执行路径，而不是当前脚本的执行路径# /home/will/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 正确的做法应该是下面这两种：script_dir=$(cd $(dirname $0) &amp;&amp; pwd)script_dir=$(dirname $(readlink -f $0 ))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p> 先cd进 当前脚本的目录然后再pwd，或者直接读取当前脚本的所在路径。 </p></blockquote><h2 id="并行化-执行"><a href="#并行化-执行" class="headerlink" title="并行化 执行"></a><strong>并行化 执行</strong></h2><p> shell中最简单的并行化是通过”&amp;”以及”wait”命令来做 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashfunc(){    #do sth｝for((i=0;i&lt;10;i++))do    func &amp;donewait<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里并行的次数不能太多，否则机器会卡死。</p><p>如果图省事可以使用<strong>parallel</strong>命令来做，或者是用 <strong>xargs</strong> 来处理。</p><h2 id="a到-z的意思"><a href="#a到-z的意思" class="headerlink" title="-a到-z的意思"></a>-a到-z的意思</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ -a FILE ] 如果 FILE 存在则为真。[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。[ -d FILE ] 如果 FILE 存在且是一个目录则为真。[ -e FILE ] 如果 FILE 存在则为真。[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。[ -r FILE ] 如果 FILE 存在且是可读的则为真。[ -s FILE ] 如果 FILE 存在且大小不为o则为真。[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。[ -x FILE ] 如果 FILE 存在且是可执行的则为真。[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。[ -z STRING ] “STRING” 的长度为零则为真。[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。[ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。[ STRING1 != STRING2 ] 如果字符串不相等则为真。[ STRING1 &lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。[ STRING1 &gt; STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。[ -z “echo 111s|sed 's/[0-9]//g'” ] &amp;&amp; echo 1 || echo 0 #把字符串中的数字都替换掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[[ $test =~ ^[0-9]+ ]] &amp;&amp; echo 1 || echo 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> <code> ~</code> 其实是对后面的正则表达式表示匹配的意思，如果匹配就输出1， 不匹配就输出0 </p><h2 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h2><p>​    <em><strong>*-eq(equal)*</strong></em>   : 测试两个整数是否相等；比如 $A -eq $B</p><p>​    <em><strong>*-ne**(**inequality*</strong></em><em><strong>*)*</strong></em> : 测试两个整数是否不等；不等，为真；相等，为假；</p><p>​    <em><strong>*-gt(greter than)*</strong></em> : 测试一个数是否大于另一个数；大于，为真；否则，为假；</p><p>​    <em><strong>*-lt*</strong></em><em><strong>*(less than)*</strong></em> : 测试一个数是否小于另一个数；小于，为真；否则，为假；</p><p>​    <strong><em>*-ge**(greter equal)**</em>*</strong>: 大于或等于</p><p>​     <em><strong>*-le*</strong></em><em><strong>*(less equal)*</strong></em> ：小于或等于</p><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p><a href="http://www.zsythink.net/archives/1199">iptables详解</a></p><h2 id="进程结构体"><a href="#进程结构体" class="headerlink" title="进程结构体"></a>进程结构体</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct task_struct {    // 进程状态    long              state;    // 虚拟内存结构体    struct mm_struct  *mm;    // 进程号    pid_t              pid;    // 指向父进程的指针    struct task_struct __rcu  *parent;    // 子进程列表    struct list_head        children;    // 存放文件系统信息的指针    struct fs_struct        *fs;    // 一个数组，包含该进程打开的文件指针    struct files_struct        *files;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://zhuanlan.zhihu.com/p/389045898">如何让Linux命令在后台运行 - 知乎 (zhihu.com)</a>  </p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
